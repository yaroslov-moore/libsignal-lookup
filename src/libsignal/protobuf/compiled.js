/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.signalservice = (function() {

    /**
     * Namespace signalservice.
     * @exports signalservice
     * @namespace
     */
    var signalservice = {};

    signalservice.CDSClientRequest = (function() {

        /**
         * Properties of a CDSClientRequest.
         * @memberof signalservice
         * @interface ICDSClientRequest
         * @property {Uint8Array|null} [aciUakPairs] CDSClientRequest aciUakPairs
         * @property {Uint8Array|null} [prevE164s] CDSClientRequest prevE164s
         * @property {Uint8Array|null} [newE164s] CDSClientRequest newE164s
         * @property {Uint8Array|null} [discardE164s] CDSClientRequest discardE164s
         * @property {boolean|null} [hasMore] CDSClientRequest hasMore
         * @property {Uint8Array|null} [token] CDSClientRequest token
         * @property {boolean|null} [tokenAck] CDSClientRequest tokenAck
         * @property {boolean|null} [returnAcisWithoutUaks] CDSClientRequest returnAcisWithoutUaks
         */

        /**
         * Constructs a new CDSClientRequest.
         * @memberof signalservice
         * @classdesc Represents a CDSClientRequest.
         * @implements ICDSClientRequest
         * @constructor
         * @param {signalservice.ICDSClientRequest=} [properties] Properties to set
         */
        function CDSClientRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CDSClientRequest aciUakPairs.
         * @member {Uint8Array} aciUakPairs
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.aciUakPairs = $util.newBuffer([]);

        /**
         * CDSClientRequest prevE164s.
         * @member {Uint8Array} prevE164s
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.prevE164s = $util.newBuffer([]);

        /**
         * CDSClientRequest newE164s.
         * @member {Uint8Array} newE164s
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.newE164s = $util.newBuffer([]);

        /**
         * CDSClientRequest discardE164s.
         * @member {Uint8Array} discardE164s
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.discardE164s = $util.newBuffer([]);

        /**
         * CDSClientRequest hasMore.
         * @member {boolean} hasMore
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.hasMore = false;

        /**
         * CDSClientRequest token.
         * @member {Uint8Array} token
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.token = $util.newBuffer([]);

        /**
         * CDSClientRequest tokenAck.
         * @member {boolean} tokenAck
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.tokenAck = false;

        /**
         * CDSClientRequest returnAcisWithoutUaks.
         * @member {boolean} returnAcisWithoutUaks
         * @memberof signalservice.CDSClientRequest
         * @instance
         */
        CDSClientRequest.prototype.returnAcisWithoutUaks = false;

        /**
         * Encodes the specified CDSClientRequest message. Does not implicitly {@link signalservice.CDSClientRequest.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {signalservice.ICDSClientRequest} message CDSClientRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDSClientRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.CDSClientRequest.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.aciUakPairs != null && Object.hasOwnProperty.call(message, "aciUakPairs"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.aciUakPairs);
            if (message.prevE164s != null && Object.hasOwnProperty.call(message, "prevE164s"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prevE164s);
            if (message.newE164s != null && Object.hasOwnProperty.call(message, "newE164s"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.newE164s);
            if (message.discardE164s != null && Object.hasOwnProperty.call(message, "discardE164s"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.discardE164s);
            if (message.hasMore != null && Object.hasOwnProperty.call(message, "hasMore"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasMore);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.token);
            if (message.tokenAck != null && Object.hasOwnProperty.call(message, "tokenAck"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.tokenAck);
            if (message.returnAcisWithoutUaks != null && Object.hasOwnProperty.call(message, "returnAcisWithoutUaks"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.returnAcisWithoutUaks);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified CDSClientRequest message, length delimited. Does not implicitly {@link signalservice.CDSClientRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {signalservice.ICDSClientRequest} message CDSClientRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDSClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CDSClientRequest message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CDSClientRequest} CDSClientRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDSClientRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CDSClientRequest();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.aciUakPairs = reader.bytes();
                    break;
                case 2:
                    message.prevE164s = reader.bytes();
                    break;
                case 3:
                    message.newE164s = reader.bytes();
                    break;
                case 4:
                    message.discardE164s = reader.bytes();
                    break;
                case 5:
                    message.hasMore = reader.bool();
                    break;
                case 6:
                    message.token = reader.bytes();
                    break;
                case 7:
                    message.tokenAck = reader.bool();
                    break;
                case 8:
                    message.returnAcisWithoutUaks = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CDSClientRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CDSClientRequest} CDSClientRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDSClientRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a CDSClientRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CDSClientRequest} CDSClientRequest
         */
        CDSClientRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CDSClientRequest)
                return object;
            var message = new $root.signalservice.CDSClientRequest();
            if (object.aciUakPairs != null)
                if (typeof object.aciUakPairs === "string")
                    $util.base64.decode(object.aciUakPairs, message.aciUakPairs = $util.newBuffer($util.base64.length(object.aciUakPairs)), 0);
                else if (object.aciUakPairs.length)
                    message.aciUakPairs = object.aciUakPairs;
            if (object.prevE164s != null)
                if (typeof object.prevE164s === "string")
                    $util.base64.decode(object.prevE164s, message.prevE164s = $util.newBuffer($util.base64.length(object.prevE164s)), 0);
                else if (object.prevE164s.length)
                    message.prevE164s = object.prevE164s;
            if (object.newE164s != null)
                if (typeof object.newE164s === "string")
                    $util.base64.decode(object.newE164s, message.newE164s = $util.newBuffer($util.base64.length(object.newE164s)), 0);
                else if (object.newE164s.length)
                    message.newE164s = object.newE164s;
            if (object.discardE164s != null)
                if (typeof object.discardE164s === "string")
                    $util.base64.decode(object.discardE164s, message.discardE164s = $util.newBuffer($util.base64.length(object.discardE164s)), 0);
                else if (object.discardE164s.length)
                    message.discardE164s = object.discardE164s;
            if (object.hasMore != null)
                message.hasMore = Boolean(object.hasMore);
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.tokenAck != null)
                message.tokenAck = Boolean(object.tokenAck);
            if (object.returnAcisWithoutUaks != null)
                message.returnAcisWithoutUaks = Boolean(object.returnAcisWithoutUaks);
            return message;
        };

        /**
         * Creates a plain object from a CDSClientRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CDSClientRequest
         * @static
         * @param {signalservice.CDSClientRequest} message CDSClientRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDSClientRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.aciUakPairs = "";
                else {
                    object.aciUakPairs = [];
                    if (options.bytes !== Array)
                        object.aciUakPairs = $util.newBuffer(object.aciUakPairs);
                }
                if (options.bytes === String)
                    object.prevE164s = "";
                else {
                    object.prevE164s = [];
                    if (options.bytes !== Array)
                        object.prevE164s = $util.newBuffer(object.prevE164s);
                }
                if (options.bytes === String)
                    object.newE164s = "";
                else {
                    object.newE164s = [];
                    if (options.bytes !== Array)
                        object.newE164s = $util.newBuffer(object.newE164s);
                }
                if (options.bytes === String)
                    object.discardE164s = "";
                else {
                    object.discardE164s = [];
                    if (options.bytes !== Array)
                        object.discardE164s = $util.newBuffer(object.discardE164s);
                }
                object.hasMore = false;
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.tokenAck = false;
                object.returnAcisWithoutUaks = false;
            }
            if (message.aciUakPairs != null && message.hasOwnProperty("aciUakPairs"))
                object.aciUakPairs = options.bytes === String ? $util.base64.encode(message.aciUakPairs, 0, message.aciUakPairs.length) : options.bytes === Array ? Array.prototype.slice.call(message.aciUakPairs) : message.aciUakPairs;
            if (message.prevE164s != null && message.hasOwnProperty("prevE164s"))
                object.prevE164s = options.bytes === String ? $util.base64.encode(message.prevE164s, 0, message.prevE164s.length) : options.bytes === Array ? Array.prototype.slice.call(message.prevE164s) : message.prevE164s;
            if (message.newE164s != null && message.hasOwnProperty("newE164s"))
                object.newE164s = options.bytes === String ? $util.base64.encode(message.newE164s, 0, message.newE164s.length) : options.bytes === Array ? Array.prototype.slice.call(message.newE164s) : message.newE164s;
            if (message.discardE164s != null && message.hasOwnProperty("discardE164s"))
                object.discardE164s = options.bytes === String ? $util.base64.encode(message.discardE164s, 0, message.discardE164s.length) : options.bytes === Array ? Array.prototype.slice.call(message.discardE164s) : message.discardE164s;
            if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                object.hasMore = message.hasMore;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.tokenAck != null && message.hasOwnProperty("tokenAck"))
                object.tokenAck = message.tokenAck;
            if (message.returnAcisWithoutUaks != null && message.hasOwnProperty("returnAcisWithoutUaks"))
                object.returnAcisWithoutUaks = message.returnAcisWithoutUaks;
            return object;
        };

        /**
         * Converts this CDSClientRequest to JSON.
         * @function toJSON
         * @memberof signalservice.CDSClientRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDSClientRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CDSClientRequest;
    })();

    signalservice.CDSClientResponse = (function() {

        /**
         * Properties of a CDSClientResponse.
         * @memberof signalservice
         * @interface ICDSClientResponse
         * @property {Uint8Array|null} [e164PniAciTriples] CDSClientResponse e164PniAciTriples
         * @property {number|null} [retryAfterSecs] CDSClientResponse retryAfterSecs
         * @property {Uint8Array|null} [token] CDSClientResponse token
         */

        /**
         * Constructs a new CDSClientResponse.
         * @memberof signalservice
         * @classdesc Represents a CDSClientResponse.
         * @implements ICDSClientResponse
         * @constructor
         * @param {signalservice.ICDSClientResponse=} [properties] Properties to set
         */
        function CDSClientResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CDSClientResponse e164PniAciTriples.
         * @member {Uint8Array} e164PniAciTriples
         * @memberof signalservice.CDSClientResponse
         * @instance
         */
        CDSClientResponse.prototype.e164PniAciTriples = $util.newBuffer([]);

        /**
         * CDSClientResponse retryAfterSecs.
         * @member {number} retryAfterSecs
         * @memberof signalservice.CDSClientResponse
         * @instance
         */
        CDSClientResponse.prototype.retryAfterSecs = 0;

        /**
         * CDSClientResponse token.
         * @member {Uint8Array} token
         * @memberof signalservice.CDSClientResponse
         * @instance
         */
        CDSClientResponse.prototype.token = $util.newBuffer([]);

        /**
         * Encodes the specified CDSClientResponse message. Does not implicitly {@link signalservice.CDSClientResponse.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {signalservice.ICDSClientResponse} message CDSClientResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDSClientResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.CDSClientResponse.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.e164PniAciTriples != null && Object.hasOwnProperty.call(message, "e164PniAciTriples"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.e164PniAciTriples);
            if (message.retryAfterSecs != null && Object.hasOwnProperty.call(message, "retryAfterSecs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.retryAfterSecs);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified CDSClientResponse message, length delimited. Does not implicitly {@link signalservice.CDSClientResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {signalservice.ICDSClientResponse} message CDSClientResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDSClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CDSClientResponse message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CDSClientResponse} CDSClientResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDSClientResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CDSClientResponse();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.e164PniAciTriples = reader.bytes();
                    break;
                case 2:
                    message.retryAfterSecs = reader.int32();
                    break;
                case 3:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CDSClientResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CDSClientResponse} CDSClientResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDSClientResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a CDSClientResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CDSClientResponse} CDSClientResponse
         */
        CDSClientResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CDSClientResponse)
                return object;
            var message = new $root.signalservice.CDSClientResponse();
            if (object.e164PniAciTriples != null)
                if (typeof object.e164PniAciTriples === "string")
                    $util.base64.decode(object.e164PniAciTriples, message.e164PniAciTriples = $util.newBuffer($util.base64.length(object.e164PniAciTriples)), 0);
                else if (object.e164PniAciTriples.length)
                    message.e164PniAciTriples = object.e164PniAciTriples;
            if (object.retryAfterSecs != null)
                message.retryAfterSecs = object.retryAfterSecs | 0;
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a CDSClientResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CDSClientResponse
         * @static
         * @param {signalservice.CDSClientResponse} message CDSClientResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDSClientResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.e164PniAciTriples = "";
                else {
                    object.e164PniAciTriples = [];
                    if (options.bytes !== Array)
                        object.e164PniAciTriples = $util.newBuffer(object.e164PniAciTriples);
                }
                object.retryAfterSecs = 0;
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            }
            if (message.e164PniAciTriples != null && message.hasOwnProperty("e164PniAciTriples"))
                object.e164PniAciTriples = options.bytes === String ? $util.base64.encode(message.e164PniAciTriples, 0, message.e164PniAciTriples.length) : options.bytes === Array ? Array.prototype.slice.call(message.e164PniAciTriples) : message.e164PniAciTriples;
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                object.retryAfterSecs = message.retryAfterSecs;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this CDSClientResponse to JSON.
         * @function toJSON
         * @memberof signalservice.CDSClientResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDSClientResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CDSClientResponse;
    })();

    signalservice.CrashReport = (function() {

        /**
         * Properties of a CrashReport.
         * @memberof signalservice
         * @interface ICrashReport
         * @property {string|null} [filename] CrashReport filename
         * @property {Uint8Array|null} [content] CrashReport content
         */

        /**
         * Constructs a new CrashReport.
         * @memberof signalservice
         * @classdesc Represents a CrashReport.
         * @implements ICrashReport
         * @constructor
         * @param {signalservice.ICrashReport=} [properties] Properties to set
         */
        function CrashReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrashReport filename.
         * @member {string} filename
         * @memberof signalservice.CrashReport
         * @instance
         */
        CrashReport.prototype.filename = "";

        /**
         * CrashReport content.
         * @member {Uint8Array} content
         * @memberof signalservice.CrashReport
         * @instance
         */
        CrashReport.prototype.content = $util.newBuffer([]);

        /**
         * Encodes the specified CrashReport message. Does not implicitly {@link signalservice.CrashReport.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CrashReport
         * @static
         * @param {signalservice.ICrashReport} message CrashReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrashReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.CrashReport.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filename);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified CrashReport message, length delimited. Does not implicitly {@link signalservice.CrashReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CrashReport
         * @static
         * @param {signalservice.ICrashReport} message CrashReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrashReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrashReport message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CrashReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CrashReport} CrashReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrashReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CrashReport();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.filename = reader.string();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrashReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CrashReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CrashReport} CrashReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrashReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a CrashReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CrashReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CrashReport} CrashReport
         */
        CrashReport.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CrashReport)
                return object;
            var message = new $root.signalservice.CrashReport();
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a CrashReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CrashReport
         * @static
         * @param {signalservice.CrashReport} message CrashReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrashReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filename = "";
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this CrashReport to JSON.
         * @function toJSON
         * @memberof signalservice.CrashReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrashReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrashReport;
    })();

    signalservice.CrashReportList = (function() {

        /**
         * Properties of a CrashReportList.
         * @memberof signalservice
         * @interface ICrashReportList
         * @property {Array.<signalservice.ICrashReport>|null} [reports] CrashReportList reports
         */

        /**
         * Constructs a new CrashReportList.
         * @memberof signalservice
         * @classdesc Represents a CrashReportList.
         * @implements ICrashReportList
         * @constructor
         * @param {signalservice.ICrashReportList=} [properties] Properties to set
         */
        function CrashReportList(properties) {
            this.reports = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrashReportList reports.
         * @member {Array.<signalservice.ICrashReport>} reports
         * @memberof signalservice.CrashReportList
         * @instance
         */
        CrashReportList.prototype.reports = $util.emptyArray;

        /**
         * Encodes the specified CrashReportList message. Does not implicitly {@link signalservice.CrashReportList.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CrashReportList
         * @static
         * @param {signalservice.ICrashReportList} message CrashReportList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrashReportList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.CrashReportList.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.reports != null && message.reports.length)
                for (var i = 0; i < message.reports.length; ++i)
                    $root.signalservice.CrashReport.encode(message.reports[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified CrashReportList message, length delimited. Does not implicitly {@link signalservice.CrashReportList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CrashReportList
         * @static
         * @param {signalservice.ICrashReportList} message CrashReportList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrashReportList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrashReportList message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CrashReportList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CrashReportList} CrashReportList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrashReportList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CrashReportList();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reports && message.reports.length))
                        message.reports = [];
                    message.reports.push($root.signalservice.CrashReport.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrashReportList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CrashReportList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CrashReportList} CrashReportList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrashReportList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a CrashReportList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CrashReportList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CrashReportList} CrashReportList
         */
        CrashReportList.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CrashReportList)
                return object;
            var message = new $root.signalservice.CrashReportList();
            if (object.reports) {
                if (!Array.isArray(object.reports))
                    throw TypeError(".signalservice.CrashReportList.reports: array expected");
                message.reports = [];
                for (var i = 0; i < object.reports.length; ++i) {
                    if (typeof object.reports[i] !== "object")
                        throw TypeError(".signalservice.CrashReportList.reports: object expected");
                    message.reports[i] = $root.signalservice.CrashReport.fromObject(object.reports[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CrashReportList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CrashReportList
         * @static
         * @param {signalservice.CrashReportList} message CrashReportList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrashReportList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reports = [];
            if (message.reports && message.reports.length) {
                object.reports = [];
                for (var j = 0; j < message.reports.length; ++j)
                    object.reports[j] = $root.signalservice.CrashReport.toObject(message.reports[j], options);
            }
            return object;
        };

        /**
         * Converts this CrashReportList to JSON.
         * @function toJSON
         * @memberof signalservice.CrashReportList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrashReportList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrashReportList;
    })();

    signalservice.ProvisioningUuid = (function() {

        /**
         * Properties of a ProvisioningUuid.
         * @memberof signalservice
         * @interface IProvisioningUuid
         * @property {string|null} [uuid] ProvisioningUuid uuid
         */

        /**
         * Constructs a new ProvisioningUuid.
         * @memberof signalservice
         * @classdesc Represents a ProvisioningUuid.
         * @implements IProvisioningUuid
         * @constructor
         * @param {signalservice.IProvisioningUuid=} [properties] Properties to set
         */
        function ProvisioningUuid(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisioningUuid uuid.
         * @member {string} uuid
         * @memberof signalservice.ProvisioningUuid
         * @instance
         */
        ProvisioningUuid.prototype.uuid = "";

        /**
         * Encodes the specified ProvisioningUuid message. Does not implicitly {@link signalservice.ProvisioningUuid.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.IProvisioningUuid} message ProvisioningUuid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisioningUuid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ProvisioningUuid.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ProvisioningUuid message, length delimited. Does not implicitly {@link signalservice.ProvisioningUuid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.IProvisioningUuid} message ProvisioningUuid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisioningUuid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisioningUuid message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisioningUuid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisioningUuid();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uuid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisioningUuid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisioningUuid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ProvisioningUuid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         */
        ProvisioningUuid.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisioningUuid)
                return object;
            var message = new $root.signalservice.ProvisioningUuid();
            if (object.uuid != null)
                message.uuid = String(object.uuid);
            return message;
        };

        /**
         * Creates a plain object from a ProvisioningUuid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.ProvisioningUuid} message ProvisioningUuid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisioningUuid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uuid = "";
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                object.uuid = message.uuid;
            return object;
        };

        /**
         * Converts this ProvisioningUuid to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisioningUuid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisioningUuid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProvisioningUuid;
    })();

    signalservice.ProvisionEnvelope = (function() {

        /**
         * Properties of a ProvisionEnvelope.
         * @memberof signalservice
         * @interface IProvisionEnvelope
         * @property {Uint8Array|null} [publicKey] ProvisionEnvelope publicKey
         * @property {Uint8Array|null} [body] ProvisionEnvelope body
         */

        /**
         * Constructs a new ProvisionEnvelope.
         * @memberof signalservice
         * @classdesc Represents a ProvisionEnvelope.
         * @implements IProvisionEnvelope
         * @constructor
         * @param {signalservice.IProvisionEnvelope=} [properties] Properties to set
         */
        function ProvisionEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisionEnvelope publicKey.
         * @member {Uint8Array} publicKey
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         */
        ProvisionEnvelope.prototype.publicKey = $util.newBuffer([]);

        /**
         * ProvisionEnvelope body.
         * @member {Uint8Array} body
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         */
        ProvisionEnvelope.prototype.body = $util.newBuffer([]);

        /**
         * Encodes the specified ProvisionEnvelope message. Does not implicitly {@link signalservice.ProvisionEnvelope.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.IProvisionEnvelope} message ProvisionEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ProvisionEnvelope.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.body);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ProvisionEnvelope message, length delimited. Does not implicitly {@link signalservice.ProvisionEnvelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.IProvisionEnvelope} message ProvisionEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisionEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisionEnvelope();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisionEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ProvisionEnvelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         */
        ProvisionEnvelope.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisionEnvelope)
                return object;
            var message = new $root.signalservice.ProvisionEnvelope();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a ProvisionEnvelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.ProvisionEnvelope} message ProvisionEnvelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisionEnvelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this ProvisionEnvelope to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisionEnvelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProvisionEnvelope;
    })();

    signalservice.ProvisionMessage = (function() {

        /**
         * Properties of a ProvisionMessage.
         * @memberof signalservice
         * @interface IProvisionMessage
         * @property {Uint8Array|null} [aciIdentityKeyPublic] ProvisionMessage aciIdentityKeyPublic
         * @property {Uint8Array|null} [aciIdentityKeyPrivate] ProvisionMessage aciIdentityKeyPrivate
         * @property {Uint8Array|null} [pniIdentityKeyPublic] ProvisionMessage pniIdentityKeyPublic
         * @property {Uint8Array|null} [pniIdentityKeyPrivate] ProvisionMessage pniIdentityKeyPrivate
         * @property {string|null} [aci] ProvisionMessage aci
         * @property {string|null} [pni] ProvisionMessage pni
         * @property {string|null} [number] ProvisionMessage number
         * @property {string|null} [provisioningCode] ProvisionMessage provisioningCode
         * @property {string|null} [userAgent] ProvisionMessage userAgent
         * @property {Uint8Array|null} [profileKey] ProvisionMessage profileKey
         * @property {boolean|null} [readReceipts] ProvisionMessage readReceipts
         * @property {number|null} [ProvisioningVersion] ProvisionMessage ProvisioningVersion
         */

        /**
         * Constructs a new ProvisionMessage.
         * @memberof signalservice
         * @classdesc Represents a ProvisionMessage.
         * @implements IProvisionMessage
         * @constructor
         * @param {signalservice.IProvisionMessage=} [properties] Properties to set
         */
        function ProvisionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisionMessage aciIdentityKeyPublic.
         * @member {Uint8Array} aciIdentityKeyPublic
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aciIdentityKeyPublic = $util.newBuffer([]);

        /**
         * ProvisionMessage aciIdentityKeyPrivate.
         * @member {Uint8Array} aciIdentityKeyPrivate
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aciIdentityKeyPrivate = $util.newBuffer([]);

        /**
         * ProvisionMessage pniIdentityKeyPublic.
         * @member {Uint8Array} pniIdentityKeyPublic
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pniIdentityKeyPublic = $util.newBuffer([]);

        /**
         * ProvisionMessage pniIdentityKeyPrivate.
         * @member {Uint8Array} pniIdentityKeyPrivate
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pniIdentityKeyPrivate = $util.newBuffer([]);

        /**
         * ProvisionMessage aci.
         * @member {string} aci
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aci = "";

        /**
         * ProvisionMessage pni.
         * @member {string} pni
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pni = "";

        /**
         * ProvisionMessage number.
         * @member {string} number
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.number = "";

        /**
         * ProvisionMessage provisioningCode.
         * @member {string} provisioningCode
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.provisioningCode = "";

        /**
         * ProvisionMessage userAgent.
         * @member {string} userAgent
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.userAgent = "";

        /**
         * ProvisionMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * ProvisionMessage readReceipts.
         * @member {boolean} readReceipts
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.readReceipts = false;

        /**
         * ProvisionMessage ProvisioningVersion.
         * @member {number} ProvisioningVersion
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.ProvisioningVersion = 0;

        /**
         * Encodes the specified ProvisionMessage message. Does not implicitly {@link signalservice.ProvisionMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.IProvisionMessage} message ProvisionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ProvisionMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.aciIdentityKeyPublic != null && Object.hasOwnProperty.call(message, "aciIdentityKeyPublic"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.aciIdentityKeyPublic);
            if (message.aciIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "aciIdentityKeyPrivate"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.aciIdentityKeyPrivate);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.number);
            if (message.provisioningCode != null && Object.hasOwnProperty.call(message, "provisioningCode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.provisioningCode);
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.userAgent);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.profileKey);
            if (message.readReceipts != null && Object.hasOwnProperty.call(message, "readReceipts"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.readReceipts);
            if (message.aci != null && Object.hasOwnProperty.call(message, "aci"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.aci);
            if (message.ProvisioningVersion != null && Object.hasOwnProperty.call(message, "ProvisioningVersion"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ProvisioningVersion);
            if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.pni);
            if (message.pniIdentityKeyPublic != null && Object.hasOwnProperty.call(message, "pniIdentityKeyPublic"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.pniIdentityKeyPublic);
            if (message.pniIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "pniIdentityKeyPrivate"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.pniIdentityKeyPrivate);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ProvisionMessage message, length delimited. Does not implicitly {@link signalservice.ProvisionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.IProvisionMessage} message ProvisionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisionMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.aciIdentityKeyPublic = reader.bytes();
                    break;
                case 2:
                    message.aciIdentityKeyPrivate = reader.bytes();
                    break;
                case 11:
                    message.pniIdentityKeyPublic = reader.bytes();
                    break;
                case 12:
                    message.pniIdentityKeyPrivate = reader.bytes();
                    break;
                case 8:
                    message.aci = reader.string();
                    break;
                case 10:
                    message.pni = reader.string();
                    break;
                case 3:
                    message.number = reader.string();
                    break;
                case 4:
                    message.provisioningCode = reader.string();
                    break;
                case 5:
                    message.userAgent = reader.string();
                    break;
                case 6:
                    message.profileKey = reader.bytes();
                    break;
                case 7:
                    message.readReceipts = reader.bool();
                    break;
                case 9:
                    message.ProvisioningVersion = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ProvisionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         */
        ProvisionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisionMessage)
                return object;
            var message = new $root.signalservice.ProvisionMessage();
            if (object.aciIdentityKeyPublic != null)
                if (typeof object.aciIdentityKeyPublic === "string")
                    $util.base64.decode(object.aciIdentityKeyPublic, message.aciIdentityKeyPublic = $util.newBuffer($util.base64.length(object.aciIdentityKeyPublic)), 0);
                else if (object.aciIdentityKeyPublic.length)
                    message.aciIdentityKeyPublic = object.aciIdentityKeyPublic;
            if (object.aciIdentityKeyPrivate != null)
                if (typeof object.aciIdentityKeyPrivate === "string")
                    $util.base64.decode(object.aciIdentityKeyPrivate, message.aciIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.aciIdentityKeyPrivate)), 0);
                else if (object.aciIdentityKeyPrivate.length)
                    message.aciIdentityKeyPrivate = object.aciIdentityKeyPrivate;
            if (object.pniIdentityKeyPublic != null)
                if (typeof object.pniIdentityKeyPublic === "string")
                    $util.base64.decode(object.pniIdentityKeyPublic, message.pniIdentityKeyPublic = $util.newBuffer($util.base64.length(object.pniIdentityKeyPublic)), 0);
                else if (object.pniIdentityKeyPublic.length)
                    message.pniIdentityKeyPublic = object.pniIdentityKeyPublic;
            if (object.pniIdentityKeyPrivate != null)
                if (typeof object.pniIdentityKeyPrivate === "string")
                    $util.base64.decode(object.pniIdentityKeyPrivate, message.pniIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.pniIdentityKeyPrivate)), 0);
                else if (object.pniIdentityKeyPrivate.length)
                    message.pniIdentityKeyPrivate = object.pniIdentityKeyPrivate;
            if (object.aci != null)
                message.aci = String(object.aci);
            if (object.pni != null)
                message.pni = String(object.pni);
            if (object.number != null)
                message.number = String(object.number);
            if (object.provisioningCode != null)
                message.provisioningCode = String(object.provisioningCode);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.readReceipts != null)
                message.readReceipts = Boolean(object.readReceipts);
            if (object.ProvisioningVersion != null)
                message.ProvisioningVersion = object.ProvisioningVersion >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProvisionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.ProvisionMessage} message ProvisionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.aciIdentityKeyPublic = "";
                else {
                    object.aciIdentityKeyPublic = [];
                    if (options.bytes !== Array)
                        object.aciIdentityKeyPublic = $util.newBuffer(object.aciIdentityKeyPublic);
                }
                if (options.bytes === String)
                    object.aciIdentityKeyPrivate = "";
                else {
                    object.aciIdentityKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.aciIdentityKeyPrivate = $util.newBuffer(object.aciIdentityKeyPrivate);
                }
                object.number = "";
                object.provisioningCode = "";
                object.userAgent = "";
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.readReceipts = false;
                object.aci = "";
                object.ProvisioningVersion = 0;
                object.pni = "";
                if (options.bytes === String)
                    object.pniIdentityKeyPublic = "";
                else {
                    object.pniIdentityKeyPublic = [];
                    if (options.bytes !== Array)
                        object.pniIdentityKeyPublic = $util.newBuffer(object.pniIdentityKeyPublic);
                }
                if (options.bytes === String)
                    object.pniIdentityKeyPrivate = "";
                else {
                    object.pniIdentityKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.pniIdentityKeyPrivate = $util.newBuffer(object.pniIdentityKeyPrivate);
                }
            }
            if (message.aciIdentityKeyPublic != null && message.hasOwnProperty("aciIdentityKeyPublic"))
                object.aciIdentityKeyPublic = options.bytes === String ? $util.base64.encode(message.aciIdentityKeyPublic, 0, message.aciIdentityKeyPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.aciIdentityKeyPublic) : message.aciIdentityKeyPublic;
            if (message.aciIdentityKeyPrivate != null && message.hasOwnProperty("aciIdentityKeyPrivate"))
                object.aciIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.aciIdentityKeyPrivate, 0, message.aciIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.aciIdentityKeyPrivate) : message.aciIdentityKeyPrivate;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.provisioningCode != null && message.hasOwnProperty("provisioningCode"))
                object.provisioningCode = message.provisioningCode;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                object.readReceipts = message.readReceipts;
            if (message.aci != null && message.hasOwnProperty("aci"))
                object.aci = message.aci;
            if (message.ProvisioningVersion != null && message.hasOwnProperty("ProvisioningVersion"))
                object.ProvisioningVersion = message.ProvisioningVersion;
            if (message.pni != null && message.hasOwnProperty("pni"))
                object.pni = message.pni;
            if (message.pniIdentityKeyPublic != null && message.hasOwnProperty("pniIdentityKeyPublic"))
                object.pniIdentityKeyPublic = options.bytes === String ? $util.base64.encode(message.pniIdentityKeyPublic, 0, message.pniIdentityKeyPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.pniIdentityKeyPublic) : message.pniIdentityKeyPublic;
            if (message.pniIdentityKeyPrivate != null && message.hasOwnProperty("pniIdentityKeyPrivate"))
                object.pniIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.pniIdentityKeyPrivate, 0, message.pniIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.pniIdentityKeyPrivate) : message.pniIdentityKeyPrivate;
            return object;
        };

        /**
         * Converts this ProvisionMessage to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProvisionMessage;
    })();

    /**
     * ProvisioningVersion enum.
     * @name signalservice.ProvisioningVersion
     * @enum {number}
     * @property {number} INITIAL=0 INITIAL value
     * @property {number} TABLET_SUPPORT=1 TABLET_SUPPORT value
     * @property {number} CURRENT=1 CURRENT value
     */
    signalservice.ProvisioningVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INITIAL"] = 0;
        values[valuesById[1] = "TABLET_SUPPORT"] = 1;
        values["CURRENT"] = 1;
        return values;
    })();

    signalservice.DeviceName = (function() {

        /**
         * Properties of a DeviceName.
         * @memberof signalservice
         * @interface IDeviceName
         * @property {Uint8Array|null} [ephemeralPublic] DeviceName ephemeralPublic
         * @property {Uint8Array|null} [syntheticIv] DeviceName syntheticIv
         * @property {Uint8Array|null} [ciphertext] DeviceName ciphertext
         */

        /**
         * Constructs a new DeviceName.
         * @memberof signalservice
         * @classdesc Represents a DeviceName.
         * @implements IDeviceName
         * @constructor
         * @param {signalservice.IDeviceName=} [properties] Properties to set
         */
        function DeviceName(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceName ephemeralPublic.
         * @member {Uint8Array} ephemeralPublic
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.ephemeralPublic = $util.newBuffer([]);

        /**
         * DeviceName syntheticIv.
         * @member {Uint8Array} syntheticIv
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.syntheticIv = $util.newBuffer([]);

        /**
         * DeviceName ciphertext.
         * @member {Uint8Array} ciphertext
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.ciphertext = $util.newBuffer([]);

        /**
         * Encodes the specified DeviceName message. Does not implicitly {@link signalservice.DeviceName.verify|verify} messages.
         * @function encode
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.IDeviceName} message DeviceName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.DeviceName.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.ephemeralPublic != null && Object.hasOwnProperty.call(message, "ephemeralPublic"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeralPublic);
            if (message.syntheticIv != null && Object.hasOwnProperty.call(message, "syntheticIv"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.syntheticIv);
            if (message.ciphertext != null && Object.hasOwnProperty.call(message, "ciphertext"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ciphertext);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified DeviceName message, length delimited. Does not implicitly {@link signalservice.DeviceName.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.IDeviceName} message DeviceName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceName.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceName message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.DeviceName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.DeviceName} DeviceName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DeviceName();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ephemeralPublic = reader.bytes();
                    break;
                case 2:
                    message.syntheticIv = reader.bytes();
                    break;
                case 3:
                    message.ciphertext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.DeviceName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.DeviceName} DeviceName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a DeviceName message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.DeviceName
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.DeviceName} DeviceName
         */
        DeviceName.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.DeviceName)
                return object;
            var message = new $root.signalservice.DeviceName();
            if (object.ephemeralPublic != null)
                if (typeof object.ephemeralPublic === "string")
                    $util.base64.decode(object.ephemeralPublic, message.ephemeralPublic = $util.newBuffer($util.base64.length(object.ephemeralPublic)), 0);
                else if (object.ephemeralPublic.length)
                    message.ephemeralPublic = object.ephemeralPublic;
            if (object.syntheticIv != null)
                if (typeof object.syntheticIv === "string")
                    $util.base64.decode(object.syntheticIv, message.syntheticIv = $util.newBuffer($util.base64.length(object.syntheticIv)), 0);
                else if (object.syntheticIv.length)
                    message.syntheticIv = object.syntheticIv;
            if (object.ciphertext != null)
                if (typeof object.ciphertext === "string")
                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);
                else if (object.ciphertext.length)
                    message.ciphertext = object.ciphertext;
            return message;
        };

        /**
         * Creates a plain object from a DeviceName message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.DeviceName} message DeviceName
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceName.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeralPublic = "";
                else {
                    object.ephemeralPublic = [];
                    if (options.bytes !== Array)
                        object.ephemeralPublic = $util.newBuffer(object.ephemeralPublic);
                }
                if (options.bytes === String)
                    object.syntheticIv = "";
                else {
                    object.syntheticIv = [];
                    if (options.bytes !== Array)
                        object.syntheticIv = $util.newBuffer(object.syntheticIv);
                }
                if (options.bytes === String)
                    object.ciphertext = "";
                else {
                    object.ciphertext = [];
                    if (options.bytes !== Array)
                        object.ciphertext = $util.newBuffer(object.ciphertext);
                }
            }
            if (message.ephemeralPublic != null && message.hasOwnProperty("ephemeralPublic"))
                object.ephemeralPublic = options.bytes === String ? $util.base64.encode(message.ephemeralPublic, 0, message.ephemeralPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralPublic) : message.ephemeralPublic;
            if (message.syntheticIv != null && message.hasOwnProperty("syntheticIv"))
                object.syntheticIv = options.bytes === String ? $util.base64.encode(message.syntheticIv, 0, message.syntheticIv.length) : options.bytes === Array ? Array.prototype.slice.call(message.syntheticIv) : message.syntheticIv;
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;
            return object;
        };

        /**
         * Converts this DeviceName to JSON.
         * @function toJSON
         * @memberof signalservice.DeviceName
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceName.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceName;
    })();

    signalservice.AvatarUploadAttributes = (function() {

        /**
         * Properties of an AvatarUploadAttributes.
         * @memberof signalservice
         * @interface IAvatarUploadAttributes
         * @property {string|null} [key] AvatarUploadAttributes key
         * @property {string|null} [credential] AvatarUploadAttributes credential
         * @property {string|null} [acl] AvatarUploadAttributes acl
         * @property {string|null} [algorithm] AvatarUploadAttributes algorithm
         * @property {string|null} [date] AvatarUploadAttributes date
         * @property {string|null} [policy] AvatarUploadAttributes policy
         * @property {string|null} [signature] AvatarUploadAttributes signature
         */

        /**
         * Constructs a new AvatarUploadAttributes.
         * @memberof signalservice
         * @classdesc Represents an AvatarUploadAttributes.
         * @implements IAvatarUploadAttributes
         * @constructor
         * @param {signalservice.IAvatarUploadAttributes=} [properties] Properties to set
         */
        function AvatarUploadAttributes(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AvatarUploadAttributes key.
         * @member {string} key
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.key = "";

        /**
         * AvatarUploadAttributes credential.
         * @member {string} credential
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.credential = "";

        /**
         * AvatarUploadAttributes acl.
         * @member {string} acl
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.acl = "";

        /**
         * AvatarUploadAttributes algorithm.
         * @member {string} algorithm
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.algorithm = "";

        /**
         * AvatarUploadAttributes date.
         * @member {string} date
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.date = "";

        /**
         * AvatarUploadAttributes policy.
         * @member {string} policy
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.policy = "";

        /**
         * AvatarUploadAttributes signature.
         * @member {string} signature
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         */
        AvatarUploadAttributes.prototype.signature = "";

        /**
         * Encodes the specified AvatarUploadAttributes message. Does not implicitly {@link signalservice.AvatarUploadAttributes.verify|verify} messages.
         * @function encode
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {signalservice.IAvatarUploadAttributes} message AvatarUploadAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvatarUploadAttributes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.AvatarUploadAttributes.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.credential != null && Object.hasOwnProperty.call(message, "credential"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.credential);
            if (message.acl != null && Object.hasOwnProperty.call(message, "acl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.acl);
            if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.algorithm);
            if (message.date != null && Object.hasOwnProperty.call(message, "date"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.date);
            if (message.policy != null && Object.hasOwnProperty.call(message, "policy"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.policy);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.signature);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified AvatarUploadAttributes message, length delimited. Does not implicitly {@link signalservice.AvatarUploadAttributes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {signalservice.IAvatarUploadAttributes} message AvatarUploadAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvatarUploadAttributes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AvatarUploadAttributes message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.AvatarUploadAttributes} AvatarUploadAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvatarUploadAttributes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AvatarUploadAttributes();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.credential = reader.string();
                    break;
                case 3:
                    message.acl = reader.string();
                    break;
                case 4:
                    message.algorithm = reader.string();
                    break;
                case 5:
                    message.date = reader.string();
                    break;
                case 6:
                    message.policy = reader.string();
                    break;
                case 7:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AvatarUploadAttributes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.AvatarUploadAttributes} AvatarUploadAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvatarUploadAttributes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an AvatarUploadAttributes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.AvatarUploadAttributes} AvatarUploadAttributes
         */
        AvatarUploadAttributes.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.AvatarUploadAttributes)
                return object;
            var message = new $root.signalservice.AvatarUploadAttributes();
            if (object.key != null)
                message.key = String(object.key);
            if (object.credential != null)
                message.credential = String(object.credential);
            if (object.acl != null)
                message.acl = String(object.acl);
            if (object.algorithm != null)
                message.algorithm = String(object.algorithm);
            if (object.date != null)
                message.date = String(object.date);
            if (object.policy != null)
                message.policy = String(object.policy);
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from an AvatarUploadAttributes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.AvatarUploadAttributes
         * @static
         * @param {signalservice.AvatarUploadAttributes} message AvatarUploadAttributes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AvatarUploadAttributes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.credential = "";
                object.acl = "";
                object.algorithm = "";
                object.date = "";
                object.policy = "";
                object.signature = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.credential != null && message.hasOwnProperty("credential"))
                object.credential = message.credential;
            if (message.acl != null && message.hasOwnProperty("acl"))
                object.acl = message.acl;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            if (message.date != null && message.hasOwnProperty("date"))
                object.date = message.date;
            if (message.policy != null && message.hasOwnProperty("policy"))
                object.policy = message.policy;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this AvatarUploadAttributes to JSON.
         * @function toJSON
         * @memberof signalservice.AvatarUploadAttributes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AvatarUploadAttributes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AvatarUploadAttributes;
    })();

    signalservice.Member = (function() {

        /**
         * Properties of a Member.
         * @memberof signalservice
         * @interface IMember
         * @property {Uint8Array|null} [userId] Member userId
         * @property {signalservice.Member.Role|null} [role] Member role
         * @property {Uint8Array|null} [profileKey] Member profileKey
         * @property {Uint8Array|null} [presentation] Member presentation
         * @property {number|null} [joinedAtVersion] Member joinedAtVersion
         */

        /**
         * Constructs a new Member.
         * @memberof signalservice
         * @classdesc Represents a Member.
         * @implements IMember
         * @constructor
         * @param {signalservice.IMember=} [properties] Properties to set
         */
        function Member(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Member userId.
         * @member {Uint8Array} userId
         * @memberof signalservice.Member
         * @instance
         */
        Member.prototype.userId = $util.newBuffer([]);

        /**
         * Member role.
         * @member {signalservice.Member.Role} role
         * @memberof signalservice.Member
         * @instance
         */
        Member.prototype.role = 0;

        /**
         * Member profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.Member
         * @instance
         */
        Member.prototype.profileKey = $util.newBuffer([]);

        /**
         * Member presentation.
         * @member {Uint8Array} presentation
         * @memberof signalservice.Member
         * @instance
         */
        Member.prototype.presentation = $util.newBuffer([]);

        /**
         * Member joinedAtVersion.
         * @member {number} joinedAtVersion
         * @memberof signalservice.Member
         * @instance
         */
        Member.prototype.joinedAtVersion = 0;

        /**
         * Encodes the specified Member message. Does not implicitly {@link signalservice.Member.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Member
         * @static
         * @param {signalservice.IMember} message Member message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Member.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.Member.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userId);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.profileKey);
            if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.presentation);
            if (message.joinedAtVersion != null && Object.hasOwnProperty.call(message, "joinedAtVersion"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.joinedAtVersion);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified Member message, length delimited. Does not implicitly {@link signalservice.Member.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Member
         * @static
         * @param {signalservice.IMember} message Member message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Member.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Member message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Member
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Member} Member
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Member.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Member();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.bytes();
                    break;
                case 2:
                    message.role = reader.int32();
                    break;
                case 3:
                    message.profileKey = reader.bytes();
                    break;
                case 4:
                    message.presentation = reader.bytes();
                    break;
                case 5:
                    message.joinedAtVersion = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Member message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Member
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Member} Member
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Member.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a Member message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Member
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Member} Member
         */
        Member.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Member)
                return object;
            var message = new $root.signalservice.Member();
            if (object.userId != null)
                if (typeof object.userId === "string")
                    $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                else if (object.userId.length)
                    message.userId = object.userId;
            switch (object.role) {
            case "UNKNOWN":
            case 0:
                message.role = 0;
                break;
            case "DEFAULT":
            case 1:
                message.role = 1;
                break;
            case "ADMINISTRATOR":
            case 2:
                message.role = 2;
                break;
            }
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.presentation != null)
                if (typeof object.presentation === "string")
                    $util.base64.decode(object.presentation, message.presentation = $util.newBuffer($util.base64.length(object.presentation)), 0);
                else if (object.presentation.length)
                    message.presentation = object.presentation;
            if (object.joinedAtVersion != null)
                message.joinedAtVersion = object.joinedAtVersion >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Member message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Member
         * @static
         * @param {signalservice.Member} message Member
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Member.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.userId = "";
                else {
                    object.userId = [];
                    if (options.bytes !== Array)
                        object.userId = $util.newBuffer(object.userId);
                }
                object.role = options.enums === String ? "UNKNOWN" : 0;
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                if (options.bytes === String)
                    object.presentation = "";
                else {
                    object.presentation = [];
                    if (options.bytes !== Array)
                        object.presentation = $util.newBuffer(object.presentation);
                }
                object.joinedAtVersion = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = options.enums === String ? $root.signalservice.Member.Role[message.role] : message.role;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.presentation != null && message.hasOwnProperty("presentation"))
                object.presentation = options.bytes === String ? $util.base64.encode(message.presentation, 0, message.presentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.presentation) : message.presentation;
            if (message.joinedAtVersion != null && message.hasOwnProperty("joinedAtVersion"))
                object.joinedAtVersion = message.joinedAtVersion;
            return object;
        };

        /**
         * Converts this Member to JSON.
         * @function toJSON
         * @memberof signalservice.Member
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Member.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Role enum.
         * @name signalservice.Member.Role
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} DEFAULT=1 DEFAULT value
         * @property {number} ADMINISTRATOR=2 ADMINISTRATOR value
         */
        Member.Role = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "DEFAULT"] = 1;
            values[valuesById[2] = "ADMINISTRATOR"] = 2;
            return values;
        })();

        return Member;
    })();

    signalservice.MemberPendingProfileKey = (function() {

        /**
         * Properties of a MemberPendingProfileKey.
         * @memberof signalservice
         * @interface IMemberPendingProfileKey
         * @property {signalservice.IMember|null} [member] MemberPendingProfileKey member
         * @property {Uint8Array|null} [addedByUserId] MemberPendingProfileKey addedByUserId
         * @property {Long|null} [timestamp] MemberPendingProfileKey timestamp
         */

        /**
         * Constructs a new MemberPendingProfileKey.
         * @memberof signalservice
         * @classdesc Represents a MemberPendingProfileKey.
         * @implements IMemberPendingProfileKey
         * @constructor
         * @param {signalservice.IMemberPendingProfileKey=} [properties] Properties to set
         */
        function MemberPendingProfileKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberPendingProfileKey member.
         * @member {signalservice.IMember|null|undefined} member
         * @memberof signalservice.MemberPendingProfileKey
         * @instance
         */
        MemberPendingProfileKey.prototype.member = null;

        /**
         * MemberPendingProfileKey addedByUserId.
         * @member {Uint8Array} addedByUserId
         * @memberof signalservice.MemberPendingProfileKey
         * @instance
         */
        MemberPendingProfileKey.prototype.addedByUserId = $util.newBuffer([]);

        /**
         * MemberPendingProfileKey timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.MemberPendingProfileKey
         * @instance
         */
        MemberPendingProfileKey.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified MemberPendingProfileKey message. Does not implicitly {@link signalservice.MemberPendingProfileKey.verify|verify} messages.
         * @function encode
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {signalservice.IMemberPendingProfileKey} message MemberPendingProfileKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberPendingProfileKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.MemberPendingProfileKey.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.member != null && Object.hasOwnProperty.call(message, "member"))
                $root.signalservice.Member.encode(message.member, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.addedByUserId != null && Object.hasOwnProperty.call(message, "addedByUserId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.addedByUserId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified MemberPendingProfileKey message, length delimited. Does not implicitly {@link signalservice.MemberPendingProfileKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {signalservice.IMemberPendingProfileKey} message MemberPendingProfileKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberPendingProfileKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemberPendingProfileKey message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.MemberPendingProfileKey} MemberPendingProfileKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberPendingProfileKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.MemberPendingProfileKey();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.member = $root.signalservice.Member.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.addedByUserId = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemberPendingProfileKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.MemberPendingProfileKey} MemberPendingProfileKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberPendingProfileKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a MemberPendingProfileKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.MemberPendingProfileKey} MemberPendingProfileKey
         */
        MemberPendingProfileKey.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.MemberPendingProfileKey)
                return object;
            var message = new $root.signalservice.MemberPendingProfileKey();
            if (object.member != null) {
                if (typeof object.member !== "object")
                    throw TypeError(".signalservice.MemberPendingProfileKey.member: object expected");
                message.member = $root.signalservice.Member.fromObject(object.member);
            }
            if (object.addedByUserId != null)
                if (typeof object.addedByUserId === "string")
                    $util.base64.decode(object.addedByUserId, message.addedByUserId = $util.newBuffer($util.base64.length(object.addedByUserId)), 0);
                else if (object.addedByUserId.length)
                    message.addedByUserId = object.addedByUserId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a MemberPendingProfileKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.MemberPendingProfileKey
         * @static
         * @param {signalservice.MemberPendingProfileKey} message MemberPendingProfileKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemberPendingProfileKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.member = null;
                if (options.bytes === String)
                    object.addedByUserId = "";
                else {
                    object.addedByUserId = [];
                    if (options.bytes !== Array)
                        object.addedByUserId = $util.newBuffer(object.addedByUserId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.member != null && message.hasOwnProperty("member"))
                object.member = $root.signalservice.Member.toObject(message.member, options);
            if (message.addedByUserId != null && message.hasOwnProperty("addedByUserId"))
                object.addedByUserId = options.bytes === String ? $util.base64.encode(message.addedByUserId, 0, message.addedByUserId.length) : options.bytes === Array ? Array.prototype.slice.call(message.addedByUserId) : message.addedByUserId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this MemberPendingProfileKey to JSON.
         * @function toJSON
         * @memberof signalservice.MemberPendingProfileKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemberPendingProfileKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemberPendingProfileKey;
    })();

    signalservice.MemberPendingAdminApproval = (function() {

        /**
         * Properties of a MemberPendingAdminApproval.
         * @memberof signalservice
         * @interface IMemberPendingAdminApproval
         * @property {Uint8Array|null} [userId] MemberPendingAdminApproval userId
         * @property {Uint8Array|null} [profileKey] MemberPendingAdminApproval profileKey
         * @property {Uint8Array|null} [presentation] MemberPendingAdminApproval presentation
         * @property {Long|null} [timestamp] MemberPendingAdminApproval timestamp
         */

        /**
         * Constructs a new MemberPendingAdminApproval.
         * @memberof signalservice
         * @classdesc Represents a MemberPendingAdminApproval.
         * @implements IMemberPendingAdminApproval
         * @constructor
         * @param {signalservice.IMemberPendingAdminApproval=} [properties] Properties to set
         */
        function MemberPendingAdminApproval(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberPendingAdminApproval userId.
         * @member {Uint8Array} userId
         * @memberof signalservice.MemberPendingAdminApproval
         * @instance
         */
        MemberPendingAdminApproval.prototype.userId = $util.newBuffer([]);

        /**
         * MemberPendingAdminApproval profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.MemberPendingAdminApproval
         * @instance
         */
        MemberPendingAdminApproval.prototype.profileKey = $util.newBuffer([]);

        /**
         * MemberPendingAdminApproval presentation.
         * @member {Uint8Array} presentation
         * @memberof signalservice.MemberPendingAdminApproval
         * @instance
         */
        MemberPendingAdminApproval.prototype.presentation = $util.newBuffer([]);

        /**
         * MemberPendingAdminApproval timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.MemberPendingAdminApproval
         * @instance
         */
        MemberPendingAdminApproval.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified MemberPendingAdminApproval message. Does not implicitly {@link signalservice.MemberPendingAdminApproval.verify|verify} messages.
         * @function encode
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {signalservice.IMemberPendingAdminApproval} message MemberPendingAdminApproval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberPendingAdminApproval.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.MemberPendingAdminApproval.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userId);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.profileKey);
            if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.presentation);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestamp);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified MemberPendingAdminApproval message, length delimited. Does not implicitly {@link signalservice.MemberPendingAdminApproval.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {signalservice.IMemberPendingAdminApproval} message MemberPendingAdminApproval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberPendingAdminApproval.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemberPendingAdminApproval message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.MemberPendingAdminApproval} MemberPendingAdminApproval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberPendingAdminApproval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.MemberPendingAdminApproval();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.bytes();
                    break;
                case 2:
                    message.profileKey = reader.bytes();
                    break;
                case 3:
                    message.presentation = reader.bytes();
                    break;
                case 4:
                    message.timestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemberPendingAdminApproval message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.MemberPendingAdminApproval} MemberPendingAdminApproval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberPendingAdminApproval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a MemberPendingAdminApproval message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.MemberPendingAdminApproval} MemberPendingAdminApproval
         */
        MemberPendingAdminApproval.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.MemberPendingAdminApproval)
                return object;
            var message = new $root.signalservice.MemberPendingAdminApproval();
            if (object.userId != null)
                if (typeof object.userId === "string")
                    $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                else if (object.userId.length)
                    message.userId = object.userId;
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.presentation != null)
                if (typeof object.presentation === "string")
                    $util.base64.decode(object.presentation, message.presentation = $util.newBuffer($util.base64.length(object.presentation)), 0);
                else if (object.presentation.length)
                    message.presentation = object.presentation;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a MemberPendingAdminApproval message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.MemberPendingAdminApproval
         * @static
         * @param {signalservice.MemberPendingAdminApproval} message MemberPendingAdminApproval
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemberPendingAdminApproval.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.userId = "";
                else {
                    object.userId = [];
                    if (options.bytes !== Array)
                        object.userId = $util.newBuffer(object.userId);
                }
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                if (options.bytes === String)
                    object.presentation = "";
                else {
                    object.presentation = [];
                    if (options.bytes !== Array)
                        object.presentation = $util.newBuffer(object.presentation);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.presentation != null && message.hasOwnProperty("presentation"))
                object.presentation = options.bytes === String ? $util.base64.encode(message.presentation, 0, message.presentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.presentation) : message.presentation;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this MemberPendingAdminApproval to JSON.
         * @function toJSON
         * @memberof signalservice.MemberPendingAdminApproval
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemberPendingAdminApproval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemberPendingAdminApproval;
    })();

    signalservice.MemberBanned = (function() {

        /**
         * Properties of a MemberBanned.
         * @memberof signalservice
         * @interface IMemberBanned
         * @property {Uint8Array|null} [userId] MemberBanned userId
         * @property {Long|null} [timestamp] MemberBanned timestamp
         */

        /**
         * Constructs a new MemberBanned.
         * @memberof signalservice
         * @classdesc Represents a MemberBanned.
         * @implements IMemberBanned
         * @constructor
         * @param {signalservice.IMemberBanned=} [properties] Properties to set
         */
        function MemberBanned(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberBanned userId.
         * @member {Uint8Array} userId
         * @memberof signalservice.MemberBanned
         * @instance
         */
        MemberBanned.prototype.userId = $util.newBuffer([]);

        /**
         * MemberBanned timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.MemberBanned
         * @instance
         */
        MemberBanned.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified MemberBanned message. Does not implicitly {@link signalservice.MemberBanned.verify|verify} messages.
         * @function encode
         * @memberof signalservice.MemberBanned
         * @static
         * @param {signalservice.IMemberBanned} message MemberBanned message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberBanned.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.MemberBanned.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified MemberBanned message, length delimited. Does not implicitly {@link signalservice.MemberBanned.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.MemberBanned
         * @static
         * @param {signalservice.IMemberBanned} message MemberBanned message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberBanned.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemberBanned message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.MemberBanned
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.MemberBanned} MemberBanned
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberBanned.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.MemberBanned();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.bytes();
                    break;
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemberBanned message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.MemberBanned
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.MemberBanned} MemberBanned
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberBanned.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a MemberBanned message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.MemberBanned
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.MemberBanned} MemberBanned
         */
        MemberBanned.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.MemberBanned)
                return object;
            var message = new $root.signalservice.MemberBanned();
            if (object.userId != null)
                if (typeof object.userId === "string")
                    $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                else if (object.userId.length)
                    message.userId = object.userId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a MemberBanned message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.MemberBanned
         * @static
         * @param {signalservice.MemberBanned} message MemberBanned
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemberBanned.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.userId = "";
                else {
                    object.userId = [];
                    if (options.bytes !== Array)
                        object.userId = $util.newBuffer(object.userId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this MemberBanned to JSON.
         * @function toJSON
         * @memberof signalservice.MemberBanned
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemberBanned.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemberBanned;
    })();

    signalservice.AccessControl = (function() {

        /**
         * Properties of an AccessControl.
         * @memberof signalservice
         * @interface IAccessControl
         * @property {signalservice.AccessControl.AccessRequired|null} [attributes] AccessControl attributes
         * @property {signalservice.AccessControl.AccessRequired|null} [members] AccessControl members
         * @property {signalservice.AccessControl.AccessRequired|null} [addFromInviteLink] AccessControl addFromInviteLink
         */

        /**
         * Constructs a new AccessControl.
         * @memberof signalservice
         * @classdesc Represents an AccessControl.
         * @implements IAccessControl
         * @constructor
         * @param {signalservice.IAccessControl=} [properties] Properties to set
         */
        function AccessControl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccessControl attributes.
         * @member {signalservice.AccessControl.AccessRequired} attributes
         * @memberof signalservice.AccessControl
         * @instance
         */
        AccessControl.prototype.attributes = 0;

        /**
         * AccessControl members.
         * @member {signalservice.AccessControl.AccessRequired} members
         * @memberof signalservice.AccessControl
         * @instance
         */
        AccessControl.prototype.members = 0;

        /**
         * AccessControl addFromInviteLink.
         * @member {signalservice.AccessControl.AccessRequired} addFromInviteLink
         * @memberof signalservice.AccessControl
         * @instance
         */
        AccessControl.prototype.addFromInviteLink = 0;

        /**
         * Encodes the specified AccessControl message. Does not implicitly {@link signalservice.AccessControl.verify|verify} messages.
         * @function encode
         * @memberof signalservice.AccessControl
         * @static
         * @param {signalservice.IAccessControl} message AccessControl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.AccessControl.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attributes);
            if (message.members != null && Object.hasOwnProperty.call(message, "members"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.members);
            if (message.addFromInviteLink != null && Object.hasOwnProperty.call(message, "addFromInviteLink"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addFromInviteLink);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified AccessControl message, length delimited. Does not implicitly {@link signalservice.AccessControl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.AccessControl
         * @static
         * @param {signalservice.IAccessControl} message AccessControl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccessControl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccessControl message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.AccessControl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.AccessControl} AccessControl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AccessControl();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attributes = reader.int32();
                    break;
                case 2:
                    message.members = reader.int32();
                    break;
                case 3:
                    message.addFromInviteLink = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccessControl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.AccessControl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.AccessControl} AccessControl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccessControl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an AccessControl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.AccessControl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.AccessControl} AccessControl
         */
        AccessControl.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.AccessControl)
                return object;
            var message = new $root.signalservice.AccessControl();
            switch (object.attributes) {
            case "UNKNOWN":
            case 0:
                message.attributes = 0;
                break;
            case "ANY":
            case 1:
                message.attributes = 1;
                break;
            case "MEMBER":
            case 2:
                message.attributes = 2;
                break;
            case "ADMINISTRATOR":
            case 3:
                message.attributes = 3;
                break;
            case "UNSATISFIABLE":
            case 4:
                message.attributes = 4;
                break;
            }
            switch (object.members) {
            case "UNKNOWN":
            case 0:
                message.members = 0;
                break;
            case "ANY":
            case 1:
                message.members = 1;
                break;
            case "MEMBER":
            case 2:
                message.members = 2;
                break;
            case "ADMINISTRATOR":
            case 3:
                message.members = 3;
                break;
            case "UNSATISFIABLE":
            case 4:
                message.members = 4;
                break;
            }
            switch (object.addFromInviteLink) {
            case "UNKNOWN":
            case 0:
                message.addFromInviteLink = 0;
                break;
            case "ANY":
            case 1:
                message.addFromInviteLink = 1;
                break;
            case "MEMBER":
            case 2:
                message.addFromInviteLink = 2;
                break;
            case "ADMINISTRATOR":
            case 3:
                message.addFromInviteLink = 3;
                break;
            case "UNSATISFIABLE":
            case 4:
                message.addFromInviteLink = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AccessControl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.AccessControl
         * @static
         * @param {signalservice.AccessControl} message AccessControl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccessControl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attributes = options.enums === String ? "UNKNOWN" : 0;
                object.members = options.enums === String ? "UNKNOWN" : 0;
                object.addFromInviteLink = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.attributes != null && message.hasOwnProperty("attributes"))
                object.attributes = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.attributes] : message.attributes;
            if (message.members != null && message.hasOwnProperty("members"))
                object.members = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.members] : message.members;
            if (message.addFromInviteLink != null && message.hasOwnProperty("addFromInviteLink"))
                object.addFromInviteLink = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.addFromInviteLink] : message.addFromInviteLink;
            return object;
        };

        /**
         * Converts this AccessControl to JSON.
         * @function toJSON
         * @memberof signalservice.AccessControl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccessControl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AccessRequired enum.
         * @name signalservice.AccessControl.AccessRequired
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} ANY=1 ANY value
         * @property {number} MEMBER=2 MEMBER value
         * @property {number} ADMINISTRATOR=3 ADMINISTRATOR value
         * @property {number} UNSATISFIABLE=4 UNSATISFIABLE value
         */
        AccessControl.AccessRequired = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "ANY"] = 1;
            values[valuesById[2] = "MEMBER"] = 2;
            values[valuesById[3] = "ADMINISTRATOR"] = 3;
            values[valuesById[4] = "UNSATISFIABLE"] = 4;
            return values;
        })();

        return AccessControl;
    })();

    signalservice.Group = (function() {

        /**
         * Properties of a Group.
         * @memberof signalservice
         * @interface IGroup
         * @property {Uint8Array|null} [publicKey] Group publicKey
         * @property {Uint8Array|null} [title] Group title
         * @property {string|null} [avatar] Group avatar
         * @property {Uint8Array|null} [disappearingMessagesTimer] Group disappearingMessagesTimer
         * @property {signalservice.IAccessControl|null} [accessControl] Group accessControl
         * @property {number|null} [version] Group version
         * @property {Array.<signalservice.IMember>|null} [members] Group members
         * @property {Array.<signalservice.IMemberPendingProfileKey>|null} [membersPendingProfileKey] Group membersPendingProfileKey
         * @property {Array.<signalservice.IMemberPendingAdminApproval>|null} [membersPendingAdminApproval] Group membersPendingAdminApproval
         * @property {Uint8Array|null} [inviteLinkPassword] Group inviteLinkPassword
         * @property {Uint8Array|null} [descriptionBytes] Group descriptionBytes
         * @property {boolean|null} [announcementsOnly] Group announcementsOnly
         * @property {Array.<signalservice.IMemberBanned>|null} [membersBanned] Group membersBanned
         */

        /**
         * Constructs a new Group.
         * @memberof signalservice
         * @classdesc Represents a Group.
         * @implements IGroup
         * @constructor
         * @param {signalservice.IGroup=} [properties] Properties to set
         */
        function Group(properties) {
            this.members = [];
            this.membersPendingProfileKey = [];
            this.membersPendingAdminApproval = [];
            this.membersBanned = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Group publicKey.
         * @member {Uint8Array} publicKey
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.publicKey = $util.newBuffer([]);

        /**
         * Group title.
         * @member {Uint8Array} title
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.title = $util.newBuffer([]);

        /**
         * Group avatar.
         * @member {string} avatar
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.avatar = "";

        /**
         * Group disappearingMessagesTimer.
         * @member {Uint8Array} disappearingMessagesTimer
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.disappearingMessagesTimer = $util.newBuffer([]);

        /**
         * Group accessControl.
         * @member {signalservice.IAccessControl|null|undefined} accessControl
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.accessControl = null;

        /**
         * Group version.
         * @member {number} version
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.version = 0;

        /**
         * Group members.
         * @member {Array.<signalservice.IMember>} members
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.members = $util.emptyArray;

        /**
         * Group membersPendingProfileKey.
         * @member {Array.<signalservice.IMemberPendingProfileKey>} membersPendingProfileKey
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.membersPendingProfileKey = $util.emptyArray;

        /**
         * Group membersPendingAdminApproval.
         * @member {Array.<signalservice.IMemberPendingAdminApproval>} membersPendingAdminApproval
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.membersPendingAdminApproval = $util.emptyArray;

        /**
         * Group inviteLinkPassword.
         * @member {Uint8Array} inviteLinkPassword
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.inviteLinkPassword = $util.newBuffer([]);

        /**
         * Group descriptionBytes.
         * @member {Uint8Array} descriptionBytes
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.descriptionBytes = $util.newBuffer([]);

        /**
         * Group announcementsOnly.
         * @member {boolean} announcementsOnly
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.announcementsOnly = false;

        /**
         * Group membersBanned.
         * @member {Array.<signalservice.IMemberBanned>} membersBanned
         * @memberof signalservice.Group
         * @instance
         */
        Group.prototype.membersBanned = $util.emptyArray;

        /**
         * Encodes the specified Group message. Does not implicitly {@link signalservice.Group.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Group
         * @static
         * @param {signalservice.IGroup} message Group message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Group.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.Group.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.title);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar);
            if (message.disappearingMessagesTimer != null && Object.hasOwnProperty.call(message, "disappearingMessagesTimer"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.disappearingMessagesTimer);
            if (message.accessControl != null && Object.hasOwnProperty.call(message, "accessControl"))
                $root.signalservice.AccessControl.encode(message.accessControl, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.version);
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.signalservice.Member.encode(message.members[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.membersPendingProfileKey != null && message.membersPendingProfileKey.length)
                for (var i = 0; i < message.membersPendingProfileKey.length; ++i)
                    $root.signalservice.MemberPendingProfileKey.encode(message.membersPendingProfileKey[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.membersPendingAdminApproval != null && message.membersPendingAdminApproval.length)
                for (var i = 0; i < message.membersPendingAdminApproval.length; ++i)
                    $root.signalservice.MemberPendingAdminApproval.encode(message.membersPendingAdminApproval[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.inviteLinkPassword != null && Object.hasOwnProperty.call(message, "inviteLinkPassword"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.inviteLinkPassword);
            if (message.descriptionBytes != null && Object.hasOwnProperty.call(message, "descriptionBytes"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.descriptionBytes);
            if (message.announcementsOnly != null && Object.hasOwnProperty.call(message, "announcementsOnly"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.announcementsOnly);
            if (message.membersBanned != null && message.membersBanned.length)
                for (var i = 0; i < message.membersBanned.length; ++i)
                    $root.signalservice.MemberBanned.encode(message.membersBanned[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified Group message, length delimited. Does not implicitly {@link signalservice.Group.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Group
         * @static
         * @param {signalservice.IGroup} message Group message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Group.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Group message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Group();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.title = reader.bytes();
                    break;
                case 3:
                    message.avatar = reader.string();
                    break;
                case 4:
                    message.disappearingMessagesTimer = reader.bytes();
                    break;
                case 5:
                    message.accessControl = $root.signalservice.AccessControl.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.version = reader.uint32();
                    break;
                case 7:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.signalservice.Member.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.membersPendingProfileKey && message.membersPendingProfileKey.length))
                        message.membersPendingProfileKey = [];
                    message.membersPendingProfileKey.push($root.signalservice.MemberPendingProfileKey.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.membersPendingAdminApproval && message.membersPendingAdminApproval.length))
                        message.membersPendingAdminApproval = [];
                    message.membersPendingAdminApproval.push($root.signalservice.MemberPendingAdminApproval.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.inviteLinkPassword = reader.bytes();
                    break;
                case 11:
                    message.descriptionBytes = reader.bytes();
                    break;
                case 12:
                    message.announcementsOnly = reader.bool();
                    break;
                case 13:
                    if (!(message.membersBanned && message.membersBanned.length))
                        message.membersBanned = [];
                    message.membersBanned.push($root.signalservice.MemberBanned.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Group message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a Group message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Group
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Group} Group
         */
        Group.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Group)
                return object;
            var message = new $root.signalservice.Group();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.title != null)
                if (typeof object.title === "string")
                    $util.base64.decode(object.title, message.title = $util.newBuffer($util.base64.length(object.title)), 0);
                else if (object.title.length)
                    message.title = object.title;
            if (object.avatar != null)
                message.avatar = String(object.avatar);
            if (object.disappearingMessagesTimer != null)
                if (typeof object.disappearingMessagesTimer === "string")
                    $util.base64.decode(object.disappearingMessagesTimer, message.disappearingMessagesTimer = $util.newBuffer($util.base64.length(object.disappearingMessagesTimer)), 0);
                else if (object.disappearingMessagesTimer.length)
                    message.disappearingMessagesTimer = object.disappearingMessagesTimer;
            if (object.accessControl != null) {
                if (typeof object.accessControl !== "object")
                    throw TypeError(".signalservice.Group.accessControl: object expected");
                message.accessControl = $root.signalservice.AccessControl.fromObject(object.accessControl);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".signalservice.Group.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".signalservice.Group.members: object expected");
                    message.members[i] = $root.signalservice.Member.fromObject(object.members[i]);
                }
            }
            if (object.membersPendingProfileKey) {
                if (!Array.isArray(object.membersPendingProfileKey))
                    throw TypeError(".signalservice.Group.membersPendingProfileKey: array expected");
                message.membersPendingProfileKey = [];
                for (var i = 0; i < object.membersPendingProfileKey.length; ++i) {
                    if (typeof object.membersPendingProfileKey[i] !== "object")
                        throw TypeError(".signalservice.Group.membersPendingProfileKey: object expected");
                    message.membersPendingProfileKey[i] = $root.signalservice.MemberPendingProfileKey.fromObject(object.membersPendingProfileKey[i]);
                }
            }
            if (object.membersPendingAdminApproval) {
                if (!Array.isArray(object.membersPendingAdminApproval))
                    throw TypeError(".signalservice.Group.membersPendingAdminApproval: array expected");
                message.membersPendingAdminApproval = [];
                for (var i = 0; i < object.membersPendingAdminApproval.length; ++i) {
                    if (typeof object.membersPendingAdminApproval[i] !== "object")
                        throw TypeError(".signalservice.Group.membersPendingAdminApproval: object expected");
                    message.membersPendingAdminApproval[i] = $root.signalservice.MemberPendingAdminApproval.fromObject(object.membersPendingAdminApproval[i]);
                }
            }
            if (object.inviteLinkPassword != null)
                if (typeof object.inviteLinkPassword === "string")
                    $util.base64.decode(object.inviteLinkPassword, message.inviteLinkPassword = $util.newBuffer($util.base64.length(object.inviteLinkPassword)), 0);
                else if (object.inviteLinkPassword.length)
                    message.inviteLinkPassword = object.inviteLinkPassword;
            if (object.descriptionBytes != null)
                if (typeof object.descriptionBytes === "string")
                    $util.base64.decode(object.descriptionBytes, message.descriptionBytes = $util.newBuffer($util.base64.length(object.descriptionBytes)), 0);
                else if (object.descriptionBytes.length)
                    message.descriptionBytes = object.descriptionBytes;
            if (object.announcementsOnly != null)
                message.announcementsOnly = Boolean(object.announcementsOnly);
            if (object.membersBanned) {
                if (!Array.isArray(object.membersBanned))
                    throw TypeError(".signalservice.Group.membersBanned: array expected");
                message.membersBanned = [];
                for (var i = 0; i < object.membersBanned.length; ++i) {
                    if (typeof object.membersBanned[i] !== "object")
                        throw TypeError(".signalservice.Group.membersBanned: object expected");
                    message.membersBanned[i] = $root.signalservice.MemberBanned.fromObject(object.membersBanned[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Group message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Group
         * @static
         * @param {signalservice.Group} message Group
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Group.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.members = [];
                object.membersPendingProfileKey = [];
                object.membersPendingAdminApproval = [];
                object.membersBanned = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.title = "";
                else {
                    object.title = [];
                    if (options.bytes !== Array)
                        object.title = $util.newBuffer(object.title);
                }
                object.avatar = "";
                if (options.bytes === String)
                    object.disappearingMessagesTimer = "";
                else {
                    object.disappearingMessagesTimer = [];
                    if (options.bytes !== Array)
                        object.disappearingMessagesTimer = $util.newBuffer(object.disappearingMessagesTimer);
                }
                object.accessControl = null;
                object.version = 0;
                if (options.bytes === String)
                    object.inviteLinkPassword = "";
                else {
                    object.inviteLinkPassword = [];
                    if (options.bytes !== Array)
                        object.inviteLinkPassword = $util.newBuffer(object.inviteLinkPassword);
                }
                if (options.bytes === String)
                    object.descriptionBytes = "";
                else {
                    object.descriptionBytes = [];
                    if (options.bytes !== Array)
                        object.descriptionBytes = $util.newBuffer(object.descriptionBytes);
                }
                object.announcementsOnly = false;
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = options.bytes === String ? $util.base64.encode(message.title, 0, message.title.length) : options.bytes === Array ? Array.prototype.slice.call(message.title) : message.title;
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = message.avatar;
            if (message.disappearingMessagesTimer != null && message.hasOwnProperty("disappearingMessagesTimer"))
                object.disappearingMessagesTimer = options.bytes === String ? $util.base64.encode(message.disappearingMessagesTimer, 0, message.disappearingMessagesTimer.length) : options.bytes === Array ? Array.prototype.slice.call(message.disappearingMessagesTimer) : message.disappearingMessagesTimer;
            if (message.accessControl != null && message.hasOwnProperty("accessControl"))
                object.accessControl = $root.signalservice.AccessControl.toObject(message.accessControl, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.signalservice.Member.toObject(message.members[j], options);
            }
            if (message.membersPendingProfileKey && message.membersPendingProfileKey.length) {
                object.membersPendingProfileKey = [];
                for (var j = 0; j < message.membersPendingProfileKey.length; ++j)
                    object.membersPendingProfileKey[j] = $root.signalservice.MemberPendingProfileKey.toObject(message.membersPendingProfileKey[j], options);
            }
            if (message.membersPendingAdminApproval && message.membersPendingAdminApproval.length) {
                object.membersPendingAdminApproval = [];
                for (var j = 0; j < message.membersPendingAdminApproval.length; ++j)
                    object.membersPendingAdminApproval[j] = $root.signalservice.MemberPendingAdminApproval.toObject(message.membersPendingAdminApproval[j], options);
            }
            if (message.inviteLinkPassword != null && message.hasOwnProperty("inviteLinkPassword"))
                object.inviteLinkPassword = options.bytes === String ? $util.base64.encode(message.inviteLinkPassword, 0, message.inviteLinkPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.inviteLinkPassword) : message.inviteLinkPassword;
            if (message.descriptionBytes != null && message.hasOwnProperty("descriptionBytes"))
                object.descriptionBytes = options.bytes === String ? $util.base64.encode(message.descriptionBytes, 0, message.descriptionBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionBytes) : message.descriptionBytes;
            if (message.announcementsOnly != null && message.hasOwnProperty("announcementsOnly"))
                object.announcementsOnly = message.announcementsOnly;
            if (message.membersBanned && message.membersBanned.length) {
                object.membersBanned = [];
                for (var j = 0; j < message.membersBanned.length; ++j)
                    object.membersBanned[j] = $root.signalservice.MemberBanned.toObject(message.membersBanned[j], options);
            }
            return object;
        };

        /**
         * Converts this Group to JSON.
         * @function toJSON
         * @memberof signalservice.Group
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Group.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Group;
    })();

    signalservice.GroupChange = (function() {

        /**
         * Properties of a GroupChange.
         * @memberof signalservice
         * @interface IGroupChange
         * @property {Uint8Array|null} [actions] GroupChange actions
         * @property {Uint8Array|null} [serverSignature] GroupChange serverSignature
         * @property {number|null} [changeEpoch] GroupChange changeEpoch
         */

        /**
         * Constructs a new GroupChange.
         * @memberof signalservice
         * @classdesc Represents a GroupChange.
         * @implements IGroupChange
         * @constructor
         * @param {signalservice.IGroupChange=} [properties] Properties to set
         */
        function GroupChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChange actions.
         * @member {Uint8Array} actions
         * @memberof signalservice.GroupChange
         * @instance
         */
        GroupChange.prototype.actions = $util.newBuffer([]);

        /**
         * GroupChange serverSignature.
         * @member {Uint8Array} serverSignature
         * @memberof signalservice.GroupChange
         * @instance
         */
        GroupChange.prototype.serverSignature = $util.newBuffer([]);

        /**
         * GroupChange changeEpoch.
         * @member {number} changeEpoch
         * @memberof signalservice.GroupChange
         * @instance
         */
        GroupChange.prototype.changeEpoch = 0;

        /**
         * Encodes the specified GroupChange message. Does not implicitly {@link signalservice.GroupChange.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupChange
         * @static
         * @param {signalservice.IGroupChange} message GroupChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupChange.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.actions != null && Object.hasOwnProperty.call(message, "actions"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.actions);
            if (message.serverSignature != null && Object.hasOwnProperty.call(message, "serverSignature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverSignature);
            if (message.changeEpoch != null && Object.hasOwnProperty.call(message, "changeEpoch"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.changeEpoch);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupChange message, length delimited. Does not implicitly {@link signalservice.GroupChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupChange
         * @static
         * @param {signalservice.IGroupChange} message GroupChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChange message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupChange} GroupChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actions = reader.bytes();
                    break;
                case 2:
                    message.serverSignature = reader.bytes();
                    break;
                case 3:
                    message.changeEpoch = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupChange} GroupChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupChange} GroupChange
         */
        GroupChange.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupChange)
                return object;
            var message = new $root.signalservice.GroupChange();
            if (object.actions != null)
                if (typeof object.actions === "string")
                    $util.base64.decode(object.actions, message.actions = $util.newBuffer($util.base64.length(object.actions)), 0);
                else if (object.actions.length)
                    message.actions = object.actions;
            if (object.serverSignature != null)
                if (typeof object.serverSignature === "string")
                    $util.base64.decode(object.serverSignature, message.serverSignature = $util.newBuffer($util.base64.length(object.serverSignature)), 0);
                else if (object.serverSignature.length)
                    message.serverSignature = object.serverSignature;
            if (object.changeEpoch != null)
                message.changeEpoch = object.changeEpoch >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupChange
         * @static
         * @param {signalservice.GroupChange} message GroupChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.actions = "";
                else {
                    object.actions = [];
                    if (options.bytes !== Array)
                        object.actions = $util.newBuffer(object.actions);
                }
                if (options.bytes === String)
                    object.serverSignature = "";
                else {
                    object.serverSignature = [];
                    if (options.bytes !== Array)
                        object.serverSignature = $util.newBuffer(object.serverSignature);
                }
                object.changeEpoch = 0;
            }
            if (message.actions != null && message.hasOwnProperty("actions"))
                object.actions = options.bytes === String ? $util.base64.encode(message.actions, 0, message.actions.length) : options.bytes === Array ? Array.prototype.slice.call(message.actions) : message.actions;
            if (message.serverSignature != null && message.hasOwnProperty("serverSignature"))
                object.serverSignature = options.bytes === String ? $util.base64.encode(message.serverSignature, 0, message.serverSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverSignature) : message.serverSignature;
            if (message.changeEpoch != null && message.hasOwnProperty("changeEpoch"))
                object.changeEpoch = message.changeEpoch;
            return object;
        };

        /**
         * Converts this GroupChange to JSON.
         * @function toJSON
         * @memberof signalservice.GroupChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GroupChange.Actions = (function() {

            /**
             * Properties of an Actions.
             * @memberof signalservice.GroupChange
             * @interface IActions
             * @property {Uint8Array|null} [sourceUuid] Actions sourceUuid
             * @property {number|null} [version] Actions version
             * @property {Array.<signalservice.GroupChange.Actions.IAddMemberAction>|null} [addMembers] Actions addMembers
             * @property {Array.<signalservice.GroupChange.Actions.IDeleteMemberAction>|null} [deleteMembers] Actions deleteMembers
             * @property {Array.<signalservice.GroupChange.Actions.IModifyMemberRoleAction>|null} [modifyMemberRoles] Actions modifyMemberRoles
             * @property {Array.<signalservice.GroupChange.Actions.IModifyMemberProfileKeyAction>|null} [modifyMemberProfileKeys] Actions modifyMemberProfileKeys
             * @property {Array.<signalservice.GroupChange.Actions.IAddMemberPendingProfileKeyAction>|null} [addPendingMembers] Actions addPendingMembers
             * @property {Array.<signalservice.GroupChange.Actions.IDeleteMemberPendingProfileKeyAction>|null} [deletePendingMembers] Actions deletePendingMembers
             * @property {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingProfileKeyAction>|null} [promotePendingMembers] Actions promotePendingMembers
             * @property {signalservice.GroupChange.Actions.IModifyTitleAction|null} [modifyTitle] Actions modifyTitle
             * @property {signalservice.GroupChange.Actions.IModifyAvatarAction|null} [modifyAvatar] Actions modifyAvatar
             * @property {signalservice.GroupChange.Actions.IModifyDisappearingMessagesTimerAction|null} [modifyDisappearingMessagesTimer] Actions modifyDisappearingMessagesTimer
             * @property {signalservice.GroupChange.Actions.IModifyAttributesAccessControlAction|null} [modifyAttributesAccess] Actions modifyAttributesAccess
             * @property {signalservice.GroupChange.Actions.IModifyMembersAccessControlAction|null} [modifyMemberAccess] Actions modifyMemberAccess
             * @property {signalservice.GroupChange.Actions.IModifyAddFromInviteLinkAccessControlAction|null} [modifyAddFromInviteLinkAccess] Actions modifyAddFromInviteLinkAccess
             * @property {Array.<signalservice.GroupChange.Actions.IAddMemberPendingAdminApprovalAction>|null} [addMemberPendingAdminApprovals] Actions addMemberPendingAdminApprovals
             * @property {Array.<signalservice.GroupChange.Actions.IDeleteMemberPendingAdminApprovalAction>|null} [deleteMemberPendingAdminApprovals] Actions deleteMemberPendingAdminApprovals
             * @property {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingAdminApprovalAction>|null} [promoteMemberPendingAdminApprovals] Actions promoteMemberPendingAdminApprovals
             * @property {signalservice.GroupChange.Actions.IModifyInviteLinkPasswordAction|null} [modifyInviteLinkPassword] Actions modifyInviteLinkPassword
             * @property {signalservice.GroupChange.Actions.IModifyDescriptionAction|null} [modifyDescription] Actions modifyDescription
             * @property {signalservice.GroupChange.Actions.IModifyAnnouncementsOnlyAction|null} [modifyAnnouncementsOnly] Actions modifyAnnouncementsOnly
             * @property {Array.<signalservice.GroupChange.Actions.IAddMemberBannedAction>|null} [addMembersBanned] Actions addMembersBanned
             * @property {Array.<signalservice.GroupChange.Actions.IDeleteMemberBannedAction>|null} [deleteMembersBanned] Actions deleteMembersBanned
             * @property {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingPniAciProfileKeyAction>|null} [promoteMembersPendingPniAciProfileKey] Actions promoteMembersPendingPniAciProfileKey
             */

            /**
             * Constructs a new Actions.
             * @memberof signalservice.GroupChange
             * @classdesc Represents an Actions.
             * @implements IActions
             * @constructor
             * @param {signalservice.GroupChange.IActions=} [properties] Properties to set
             */
            function Actions(properties) {
                this.addMembers = [];
                this.deleteMembers = [];
                this.modifyMemberRoles = [];
                this.modifyMemberProfileKeys = [];
                this.addPendingMembers = [];
                this.deletePendingMembers = [];
                this.promotePendingMembers = [];
                this.addMemberPendingAdminApprovals = [];
                this.deleteMemberPendingAdminApprovals = [];
                this.promoteMemberPendingAdminApprovals = [];
                this.addMembersBanned = [];
                this.deleteMembersBanned = [];
                this.promoteMembersPendingPniAciProfileKey = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Actions sourceUuid.
             * @member {Uint8Array} sourceUuid
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.sourceUuid = $util.newBuffer([]);

            /**
             * Actions version.
             * @member {number} version
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.version = 0;

            /**
             * Actions addMembers.
             * @member {Array.<signalservice.GroupChange.Actions.IAddMemberAction>} addMembers
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.addMembers = $util.emptyArray;

            /**
             * Actions deleteMembers.
             * @member {Array.<signalservice.GroupChange.Actions.IDeleteMemberAction>} deleteMembers
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.deleteMembers = $util.emptyArray;

            /**
             * Actions modifyMemberRoles.
             * @member {Array.<signalservice.GroupChange.Actions.IModifyMemberRoleAction>} modifyMemberRoles
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyMemberRoles = $util.emptyArray;

            /**
             * Actions modifyMemberProfileKeys.
             * @member {Array.<signalservice.GroupChange.Actions.IModifyMemberProfileKeyAction>} modifyMemberProfileKeys
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyMemberProfileKeys = $util.emptyArray;

            /**
             * Actions addPendingMembers.
             * @member {Array.<signalservice.GroupChange.Actions.IAddMemberPendingProfileKeyAction>} addPendingMembers
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.addPendingMembers = $util.emptyArray;

            /**
             * Actions deletePendingMembers.
             * @member {Array.<signalservice.GroupChange.Actions.IDeleteMemberPendingProfileKeyAction>} deletePendingMembers
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.deletePendingMembers = $util.emptyArray;

            /**
             * Actions promotePendingMembers.
             * @member {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingProfileKeyAction>} promotePendingMembers
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.promotePendingMembers = $util.emptyArray;

            /**
             * Actions modifyTitle.
             * @member {signalservice.GroupChange.Actions.IModifyTitleAction|null|undefined} modifyTitle
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyTitle = null;

            /**
             * Actions modifyAvatar.
             * @member {signalservice.GroupChange.Actions.IModifyAvatarAction|null|undefined} modifyAvatar
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyAvatar = null;

            /**
             * Actions modifyDisappearingMessagesTimer.
             * @member {signalservice.GroupChange.Actions.IModifyDisappearingMessagesTimerAction|null|undefined} modifyDisappearingMessagesTimer
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyDisappearingMessagesTimer = null;

            /**
             * Actions modifyAttributesAccess.
             * @member {signalservice.GroupChange.Actions.IModifyAttributesAccessControlAction|null|undefined} modifyAttributesAccess
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyAttributesAccess = null;

            /**
             * Actions modifyMemberAccess.
             * @member {signalservice.GroupChange.Actions.IModifyMembersAccessControlAction|null|undefined} modifyMemberAccess
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyMemberAccess = null;

            /**
             * Actions modifyAddFromInviteLinkAccess.
             * @member {signalservice.GroupChange.Actions.IModifyAddFromInviteLinkAccessControlAction|null|undefined} modifyAddFromInviteLinkAccess
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyAddFromInviteLinkAccess = null;

            /**
             * Actions addMemberPendingAdminApprovals.
             * @member {Array.<signalservice.GroupChange.Actions.IAddMemberPendingAdminApprovalAction>} addMemberPendingAdminApprovals
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.addMemberPendingAdminApprovals = $util.emptyArray;

            /**
             * Actions deleteMemberPendingAdminApprovals.
             * @member {Array.<signalservice.GroupChange.Actions.IDeleteMemberPendingAdminApprovalAction>} deleteMemberPendingAdminApprovals
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.deleteMemberPendingAdminApprovals = $util.emptyArray;

            /**
             * Actions promoteMemberPendingAdminApprovals.
             * @member {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingAdminApprovalAction>} promoteMemberPendingAdminApprovals
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.promoteMemberPendingAdminApprovals = $util.emptyArray;

            /**
             * Actions modifyInviteLinkPassword.
             * @member {signalservice.GroupChange.Actions.IModifyInviteLinkPasswordAction|null|undefined} modifyInviteLinkPassword
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyInviteLinkPassword = null;

            /**
             * Actions modifyDescription.
             * @member {signalservice.GroupChange.Actions.IModifyDescriptionAction|null|undefined} modifyDescription
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyDescription = null;

            /**
             * Actions modifyAnnouncementsOnly.
             * @member {signalservice.GroupChange.Actions.IModifyAnnouncementsOnlyAction|null|undefined} modifyAnnouncementsOnly
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.modifyAnnouncementsOnly = null;

            /**
             * Actions addMembersBanned.
             * @member {Array.<signalservice.GroupChange.Actions.IAddMemberBannedAction>} addMembersBanned
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.addMembersBanned = $util.emptyArray;

            /**
             * Actions deleteMembersBanned.
             * @member {Array.<signalservice.GroupChange.Actions.IDeleteMemberBannedAction>} deleteMembersBanned
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.deleteMembersBanned = $util.emptyArray;

            /**
             * Actions promoteMembersPendingPniAciProfileKey.
             * @member {Array.<signalservice.GroupChange.Actions.IPromoteMemberPendingPniAciProfileKeyAction>} promoteMembersPendingPniAciProfileKey
             * @memberof signalservice.GroupChange.Actions
             * @instance
             */
            Actions.prototype.promoteMembersPendingPniAciProfileKey = $util.emptyArray;

            /**
             * Encodes the specified Actions message. Does not implicitly {@link signalservice.GroupChange.Actions.verify|verify} messages.
             * @function encode
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {signalservice.GroupChange.IActions} message Actions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Actions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.GroupChange.Actions.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.sourceUuid != null && Object.hasOwnProperty.call(message, "sourceUuid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sourceUuid);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                if (message.addMembers != null && message.addMembers.length)
                    for (var i = 0; i < message.addMembers.length; ++i)
                        $root.signalservice.GroupChange.Actions.AddMemberAction.encode(message.addMembers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.deleteMembers != null && message.deleteMembers.length)
                    for (var i = 0; i < message.deleteMembers.length; ++i)
                        $root.signalservice.GroupChange.Actions.DeleteMemberAction.encode(message.deleteMembers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.modifyMemberRoles != null && message.modifyMemberRoles.length)
                    for (var i = 0; i < message.modifyMemberRoles.length; ++i)
                        $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction.encode(message.modifyMemberRoles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.modifyMemberProfileKeys != null && message.modifyMemberProfileKeys.length)
                    for (var i = 0; i < message.modifyMemberProfileKeys.length; ++i)
                        $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.encode(message.modifyMemberProfileKeys[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.addPendingMembers != null && message.addPendingMembers.length)
                    for (var i = 0; i < message.addPendingMembers.length; ++i)
                        $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.encode(message.addPendingMembers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.deletePendingMembers != null && message.deletePendingMembers.length)
                    for (var i = 0; i < message.deletePendingMembers.length; ++i)
                        $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.encode(message.deletePendingMembers[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.promotePendingMembers != null && message.promotePendingMembers.length)
                    for (var i = 0; i < message.promotePendingMembers.length; ++i)
                        $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.encode(message.promotePendingMembers[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.modifyTitle != null && Object.hasOwnProperty.call(message, "modifyTitle"))
                    $root.signalservice.GroupChange.Actions.ModifyTitleAction.encode(message.modifyTitle, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.modifyAvatar != null && Object.hasOwnProperty.call(message, "modifyAvatar"))
                    $root.signalservice.GroupChange.Actions.ModifyAvatarAction.encode(message.modifyAvatar, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.modifyDisappearingMessagesTimer != null && Object.hasOwnProperty.call(message, "modifyDisappearingMessagesTimer"))
                    $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.encode(message.modifyDisappearingMessagesTimer, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.modifyAttributesAccess != null && Object.hasOwnProperty.call(message, "modifyAttributesAccess"))
                    $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.encode(message.modifyAttributesAccess, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.modifyMemberAccess != null && Object.hasOwnProperty.call(message, "modifyMemberAccess"))
                    $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.encode(message.modifyMemberAccess, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.modifyAddFromInviteLinkAccess != null && Object.hasOwnProperty.call(message, "modifyAddFromInviteLinkAccess"))
                    $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.encode(message.modifyAddFromInviteLinkAccess, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.addMemberPendingAdminApprovals != null && message.addMemberPendingAdminApprovals.length)
                    for (var i = 0; i < message.addMemberPendingAdminApprovals.length; ++i)
                        $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.encode(message.addMemberPendingAdminApprovals[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.deleteMemberPendingAdminApprovals != null && message.deleteMemberPendingAdminApprovals.length)
                    for (var i = 0; i < message.deleteMemberPendingAdminApprovals.length; ++i)
                        $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.encode(message.deleteMemberPendingAdminApprovals[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.promoteMemberPendingAdminApprovals != null && message.promoteMemberPendingAdminApprovals.length)
                    for (var i = 0; i < message.promoteMemberPendingAdminApprovals.length; ++i)
                        $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.encode(message.promoteMemberPendingAdminApprovals[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.modifyInviteLinkPassword != null && Object.hasOwnProperty.call(message, "modifyInviteLinkPassword"))
                    $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.encode(message.modifyInviteLinkPassword, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.modifyDescription != null && Object.hasOwnProperty.call(message, "modifyDescription"))
                    $root.signalservice.GroupChange.Actions.ModifyDescriptionAction.encode(message.modifyDescription, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.modifyAnnouncementsOnly != null && Object.hasOwnProperty.call(message, "modifyAnnouncementsOnly"))
                    $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.encode(message.modifyAnnouncementsOnly, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.addMembersBanned != null && message.addMembersBanned.length)
                    for (var i = 0; i < message.addMembersBanned.length; ++i)
                        $root.signalservice.GroupChange.Actions.AddMemberBannedAction.encode(message.addMembersBanned[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.deleteMembersBanned != null && message.deleteMembersBanned.length)
                    for (var i = 0; i < message.deleteMembersBanned.length; ++i)
                        $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction.encode(message.deleteMembersBanned[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.promoteMembersPendingPniAciProfileKey != null && message.promoteMembersPendingPniAciProfileKey.length)
                    for (var i = 0; i < message.promoteMembersPendingPniAciProfileKey.length; ++i)
                        $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.encode(message.promoteMembersPendingPniAciProfileKey[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Actions message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {signalservice.GroupChange.IActions} message Actions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Actions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Actions message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.GroupChange.Actions} Actions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Actions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sourceUuid = reader.bytes();
                        break;
                    case 2:
                        message.version = reader.uint32();
                        break;
                    case 3:
                        if (!(message.addMembers && message.addMembers.length))
                            message.addMembers = [];
                        message.addMembers.push($root.signalservice.GroupChange.Actions.AddMemberAction.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.deleteMembers && message.deleteMembers.length))
                            message.deleteMembers = [];
                        message.deleteMembers.push($root.signalservice.GroupChange.Actions.DeleteMemberAction.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.modifyMemberRoles && message.modifyMemberRoles.length))
                            message.modifyMemberRoles = [];
                        message.modifyMemberRoles.push($root.signalservice.GroupChange.Actions.ModifyMemberRoleAction.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.modifyMemberProfileKeys && message.modifyMemberProfileKeys.length))
                            message.modifyMemberProfileKeys = [];
                        message.modifyMemberProfileKeys.push($root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.addPendingMembers && message.addPendingMembers.length))
                            message.addPendingMembers = [];
                        message.addPendingMembers.push($root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.deletePendingMembers && message.deletePendingMembers.length))
                            message.deletePendingMembers = [];
                        message.deletePendingMembers.push($root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.promotePendingMembers && message.promotePendingMembers.length))
                            message.promotePendingMembers = [];
                        message.promotePendingMembers.push($root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.modifyTitle = $root.signalservice.GroupChange.Actions.ModifyTitleAction.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.modifyAvatar = $root.signalservice.GroupChange.Actions.ModifyAvatarAction.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.modifyDisappearingMessagesTimer = $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.modifyAttributesAccess = $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.modifyMemberAccess = $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.modifyAddFromInviteLinkAccess = $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.decode(reader, reader.uint32());
                        break;
                    case 16:
                        if (!(message.addMemberPendingAdminApprovals && message.addMemberPendingAdminApprovals.length))
                            message.addMemberPendingAdminApprovals = [];
                        message.addMemberPendingAdminApprovals.push($root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        if (!(message.deleteMemberPendingAdminApprovals && message.deleteMemberPendingAdminApprovals.length))
                            message.deleteMemberPendingAdminApprovals = [];
                        message.deleteMemberPendingAdminApprovals.push($root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        if (!(message.promoteMemberPendingAdminApprovals && message.promoteMemberPendingAdminApprovals.length))
                            message.promoteMemberPendingAdminApprovals = [];
                        message.promoteMemberPendingAdminApprovals.push($root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.decode(reader, reader.uint32()));
                        break;
                    case 19:
                        message.modifyInviteLinkPassword = $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.modifyDescription = $root.signalservice.GroupChange.Actions.ModifyDescriptionAction.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.modifyAnnouncementsOnly = $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.decode(reader, reader.uint32());
                        break;
                    case 22:
                        if (!(message.addMembersBanned && message.addMembersBanned.length))
                            message.addMembersBanned = [];
                        message.addMembersBanned.push($root.signalservice.GroupChange.Actions.AddMemberBannedAction.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        if (!(message.deleteMembersBanned && message.deleteMembersBanned.length))
                            message.deleteMembersBanned = [];
                        message.deleteMembersBanned.push($root.signalservice.GroupChange.Actions.DeleteMemberBannedAction.decode(reader, reader.uint32()));
                        break;
                    case 24:
                        if (!(message.promoteMembersPendingPniAciProfileKey && message.promoteMembersPendingPniAciProfileKey.length))
                            message.promoteMembersPendingPniAciProfileKey = [];
                        message.promoteMembersPendingPniAciProfileKey.push($root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Actions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.GroupChange.Actions} Actions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Actions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Actions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.GroupChange.Actions} Actions
             */
            Actions.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.GroupChange.Actions)
                    return object;
                var message = new $root.signalservice.GroupChange.Actions();
                if (object.sourceUuid != null)
                    if (typeof object.sourceUuid === "string")
                        $util.base64.decode(object.sourceUuid, message.sourceUuid = $util.newBuffer($util.base64.length(object.sourceUuid)), 0);
                    else if (object.sourceUuid.length)
                        message.sourceUuid = object.sourceUuid;
                if (object.version != null)
                    message.version = object.version >>> 0;
                if (object.addMembers) {
                    if (!Array.isArray(object.addMembers))
                        throw TypeError(".signalservice.GroupChange.Actions.addMembers: array expected");
                    message.addMembers = [];
                    for (var i = 0; i < object.addMembers.length; ++i) {
                        if (typeof object.addMembers[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.addMembers: object expected");
                        message.addMembers[i] = $root.signalservice.GroupChange.Actions.AddMemberAction.fromObject(object.addMembers[i]);
                    }
                }
                if (object.deleteMembers) {
                    if (!Array.isArray(object.deleteMembers))
                        throw TypeError(".signalservice.GroupChange.Actions.deleteMembers: array expected");
                    message.deleteMembers = [];
                    for (var i = 0; i < object.deleteMembers.length; ++i) {
                        if (typeof object.deleteMembers[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.deleteMembers: object expected");
                        message.deleteMembers[i] = $root.signalservice.GroupChange.Actions.DeleteMemberAction.fromObject(object.deleteMembers[i]);
                    }
                }
                if (object.modifyMemberRoles) {
                    if (!Array.isArray(object.modifyMemberRoles))
                        throw TypeError(".signalservice.GroupChange.Actions.modifyMemberRoles: array expected");
                    message.modifyMemberRoles = [];
                    for (var i = 0; i < object.modifyMemberRoles.length; ++i) {
                        if (typeof object.modifyMemberRoles[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.modifyMemberRoles: object expected");
                        message.modifyMemberRoles[i] = $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction.fromObject(object.modifyMemberRoles[i]);
                    }
                }
                if (object.modifyMemberProfileKeys) {
                    if (!Array.isArray(object.modifyMemberProfileKeys))
                        throw TypeError(".signalservice.GroupChange.Actions.modifyMemberProfileKeys: array expected");
                    message.modifyMemberProfileKeys = [];
                    for (var i = 0; i < object.modifyMemberProfileKeys.length; ++i) {
                        if (typeof object.modifyMemberProfileKeys[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.modifyMemberProfileKeys: object expected");
                        message.modifyMemberProfileKeys[i] = $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.fromObject(object.modifyMemberProfileKeys[i]);
                    }
                }
                if (object.addPendingMembers) {
                    if (!Array.isArray(object.addPendingMembers))
                        throw TypeError(".signalservice.GroupChange.Actions.addPendingMembers: array expected");
                    message.addPendingMembers = [];
                    for (var i = 0; i < object.addPendingMembers.length; ++i) {
                        if (typeof object.addPendingMembers[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.addPendingMembers: object expected");
                        message.addPendingMembers[i] = $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.fromObject(object.addPendingMembers[i]);
                    }
                }
                if (object.deletePendingMembers) {
                    if (!Array.isArray(object.deletePendingMembers))
                        throw TypeError(".signalservice.GroupChange.Actions.deletePendingMembers: array expected");
                    message.deletePendingMembers = [];
                    for (var i = 0; i < object.deletePendingMembers.length; ++i) {
                        if (typeof object.deletePendingMembers[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.deletePendingMembers: object expected");
                        message.deletePendingMembers[i] = $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.fromObject(object.deletePendingMembers[i]);
                    }
                }
                if (object.promotePendingMembers) {
                    if (!Array.isArray(object.promotePendingMembers))
                        throw TypeError(".signalservice.GroupChange.Actions.promotePendingMembers: array expected");
                    message.promotePendingMembers = [];
                    for (var i = 0; i < object.promotePendingMembers.length; ++i) {
                        if (typeof object.promotePendingMembers[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.promotePendingMembers: object expected");
                        message.promotePendingMembers[i] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.fromObject(object.promotePendingMembers[i]);
                    }
                }
                if (object.modifyTitle != null) {
                    if (typeof object.modifyTitle !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyTitle: object expected");
                    message.modifyTitle = $root.signalservice.GroupChange.Actions.ModifyTitleAction.fromObject(object.modifyTitle);
                }
                if (object.modifyAvatar != null) {
                    if (typeof object.modifyAvatar !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyAvatar: object expected");
                    message.modifyAvatar = $root.signalservice.GroupChange.Actions.ModifyAvatarAction.fromObject(object.modifyAvatar);
                }
                if (object.modifyDisappearingMessagesTimer != null) {
                    if (typeof object.modifyDisappearingMessagesTimer !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyDisappearingMessagesTimer: object expected");
                    message.modifyDisappearingMessagesTimer = $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.fromObject(object.modifyDisappearingMessagesTimer);
                }
                if (object.modifyAttributesAccess != null) {
                    if (typeof object.modifyAttributesAccess !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyAttributesAccess: object expected");
                    message.modifyAttributesAccess = $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.fromObject(object.modifyAttributesAccess);
                }
                if (object.modifyMemberAccess != null) {
                    if (typeof object.modifyMemberAccess !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyMemberAccess: object expected");
                    message.modifyMemberAccess = $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.fromObject(object.modifyMemberAccess);
                }
                if (object.modifyAddFromInviteLinkAccess != null) {
                    if (typeof object.modifyAddFromInviteLinkAccess !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyAddFromInviteLinkAccess: object expected");
                    message.modifyAddFromInviteLinkAccess = $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.fromObject(object.modifyAddFromInviteLinkAccess);
                }
                if (object.addMemberPendingAdminApprovals) {
                    if (!Array.isArray(object.addMemberPendingAdminApprovals))
                        throw TypeError(".signalservice.GroupChange.Actions.addMemberPendingAdminApprovals: array expected");
                    message.addMemberPendingAdminApprovals = [];
                    for (var i = 0; i < object.addMemberPendingAdminApprovals.length; ++i) {
                        if (typeof object.addMemberPendingAdminApprovals[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.addMemberPendingAdminApprovals: object expected");
                        message.addMemberPendingAdminApprovals[i] = $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.fromObject(object.addMemberPendingAdminApprovals[i]);
                    }
                }
                if (object.deleteMemberPendingAdminApprovals) {
                    if (!Array.isArray(object.deleteMemberPendingAdminApprovals))
                        throw TypeError(".signalservice.GroupChange.Actions.deleteMemberPendingAdminApprovals: array expected");
                    message.deleteMemberPendingAdminApprovals = [];
                    for (var i = 0; i < object.deleteMemberPendingAdminApprovals.length; ++i) {
                        if (typeof object.deleteMemberPendingAdminApprovals[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.deleteMemberPendingAdminApprovals: object expected");
                        message.deleteMemberPendingAdminApprovals[i] = $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.fromObject(object.deleteMemberPendingAdminApprovals[i]);
                    }
                }
                if (object.promoteMemberPendingAdminApprovals) {
                    if (!Array.isArray(object.promoteMemberPendingAdminApprovals))
                        throw TypeError(".signalservice.GroupChange.Actions.promoteMemberPendingAdminApprovals: array expected");
                    message.promoteMemberPendingAdminApprovals = [];
                    for (var i = 0; i < object.promoteMemberPendingAdminApprovals.length; ++i) {
                        if (typeof object.promoteMemberPendingAdminApprovals[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.promoteMemberPendingAdminApprovals: object expected");
                        message.promoteMemberPendingAdminApprovals[i] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.fromObject(object.promoteMemberPendingAdminApprovals[i]);
                    }
                }
                if (object.modifyInviteLinkPassword != null) {
                    if (typeof object.modifyInviteLinkPassword !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyInviteLinkPassword: object expected");
                    message.modifyInviteLinkPassword = $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.fromObject(object.modifyInviteLinkPassword);
                }
                if (object.modifyDescription != null) {
                    if (typeof object.modifyDescription !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyDescription: object expected");
                    message.modifyDescription = $root.signalservice.GroupChange.Actions.ModifyDescriptionAction.fromObject(object.modifyDescription);
                }
                if (object.modifyAnnouncementsOnly != null) {
                    if (typeof object.modifyAnnouncementsOnly !== "object")
                        throw TypeError(".signalservice.GroupChange.Actions.modifyAnnouncementsOnly: object expected");
                    message.modifyAnnouncementsOnly = $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.fromObject(object.modifyAnnouncementsOnly);
                }
                if (object.addMembersBanned) {
                    if (!Array.isArray(object.addMembersBanned))
                        throw TypeError(".signalservice.GroupChange.Actions.addMembersBanned: array expected");
                    message.addMembersBanned = [];
                    for (var i = 0; i < object.addMembersBanned.length; ++i) {
                        if (typeof object.addMembersBanned[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.addMembersBanned: object expected");
                        message.addMembersBanned[i] = $root.signalservice.GroupChange.Actions.AddMemberBannedAction.fromObject(object.addMembersBanned[i]);
                    }
                }
                if (object.deleteMembersBanned) {
                    if (!Array.isArray(object.deleteMembersBanned))
                        throw TypeError(".signalservice.GroupChange.Actions.deleteMembersBanned: array expected");
                    message.deleteMembersBanned = [];
                    for (var i = 0; i < object.deleteMembersBanned.length; ++i) {
                        if (typeof object.deleteMembersBanned[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.deleteMembersBanned: object expected");
                        message.deleteMembersBanned[i] = $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction.fromObject(object.deleteMembersBanned[i]);
                    }
                }
                if (object.promoteMembersPendingPniAciProfileKey) {
                    if (!Array.isArray(object.promoteMembersPendingPniAciProfileKey))
                        throw TypeError(".signalservice.GroupChange.Actions.promoteMembersPendingPniAciProfileKey: array expected");
                    message.promoteMembersPendingPniAciProfileKey = [];
                    for (var i = 0; i < object.promoteMembersPendingPniAciProfileKey.length; ++i) {
                        if (typeof object.promoteMembersPendingPniAciProfileKey[i] !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.promoteMembersPendingPniAciProfileKey: object expected");
                        message.promoteMembersPendingPniAciProfileKey[i] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.fromObject(object.promoteMembersPendingPniAciProfileKey[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Actions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.GroupChange.Actions
             * @static
             * @param {signalservice.GroupChange.Actions} message Actions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Actions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.addMembers = [];
                    object.deleteMembers = [];
                    object.modifyMemberRoles = [];
                    object.modifyMemberProfileKeys = [];
                    object.addPendingMembers = [];
                    object.deletePendingMembers = [];
                    object.promotePendingMembers = [];
                    object.addMemberPendingAdminApprovals = [];
                    object.deleteMemberPendingAdminApprovals = [];
                    object.promoteMemberPendingAdminApprovals = [];
                    object.addMembersBanned = [];
                    object.deleteMembersBanned = [];
                    object.promoteMembersPendingPniAciProfileKey = [];
                }
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sourceUuid = "";
                    else {
                        object.sourceUuid = [];
                        if (options.bytes !== Array)
                            object.sourceUuid = $util.newBuffer(object.sourceUuid);
                    }
                    object.version = 0;
                    object.modifyTitle = null;
                    object.modifyAvatar = null;
                    object.modifyDisappearingMessagesTimer = null;
                    object.modifyAttributesAccess = null;
                    object.modifyMemberAccess = null;
                    object.modifyAddFromInviteLinkAccess = null;
                    object.modifyInviteLinkPassword = null;
                    object.modifyDescription = null;
                    object.modifyAnnouncementsOnly = null;
                }
                if (message.sourceUuid != null && message.hasOwnProperty("sourceUuid"))
                    object.sourceUuid = options.bytes === String ? $util.base64.encode(message.sourceUuid, 0, message.sourceUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.sourceUuid) : message.sourceUuid;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.addMembers && message.addMembers.length) {
                    object.addMembers = [];
                    for (var j = 0; j < message.addMembers.length; ++j)
                        object.addMembers[j] = $root.signalservice.GroupChange.Actions.AddMemberAction.toObject(message.addMembers[j], options);
                }
                if (message.deleteMembers && message.deleteMembers.length) {
                    object.deleteMembers = [];
                    for (var j = 0; j < message.deleteMembers.length; ++j)
                        object.deleteMembers[j] = $root.signalservice.GroupChange.Actions.DeleteMemberAction.toObject(message.deleteMembers[j], options);
                }
                if (message.modifyMemberRoles && message.modifyMemberRoles.length) {
                    object.modifyMemberRoles = [];
                    for (var j = 0; j < message.modifyMemberRoles.length; ++j)
                        object.modifyMemberRoles[j] = $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction.toObject(message.modifyMemberRoles[j], options);
                }
                if (message.modifyMemberProfileKeys && message.modifyMemberProfileKeys.length) {
                    object.modifyMemberProfileKeys = [];
                    for (var j = 0; j < message.modifyMemberProfileKeys.length; ++j)
                        object.modifyMemberProfileKeys[j] = $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.toObject(message.modifyMemberProfileKeys[j], options);
                }
                if (message.addPendingMembers && message.addPendingMembers.length) {
                    object.addPendingMembers = [];
                    for (var j = 0; j < message.addPendingMembers.length; ++j)
                        object.addPendingMembers[j] = $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.toObject(message.addPendingMembers[j], options);
                }
                if (message.deletePendingMembers && message.deletePendingMembers.length) {
                    object.deletePendingMembers = [];
                    for (var j = 0; j < message.deletePendingMembers.length; ++j)
                        object.deletePendingMembers[j] = $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.toObject(message.deletePendingMembers[j], options);
                }
                if (message.promotePendingMembers && message.promotePendingMembers.length) {
                    object.promotePendingMembers = [];
                    for (var j = 0; j < message.promotePendingMembers.length; ++j)
                        object.promotePendingMembers[j] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.toObject(message.promotePendingMembers[j], options);
                }
                if (message.modifyTitle != null && message.hasOwnProperty("modifyTitle"))
                    object.modifyTitle = $root.signalservice.GroupChange.Actions.ModifyTitleAction.toObject(message.modifyTitle, options);
                if (message.modifyAvatar != null && message.hasOwnProperty("modifyAvatar"))
                    object.modifyAvatar = $root.signalservice.GroupChange.Actions.ModifyAvatarAction.toObject(message.modifyAvatar, options);
                if (message.modifyDisappearingMessagesTimer != null && message.hasOwnProperty("modifyDisappearingMessagesTimer"))
                    object.modifyDisappearingMessagesTimer = $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.toObject(message.modifyDisappearingMessagesTimer, options);
                if (message.modifyAttributesAccess != null && message.hasOwnProperty("modifyAttributesAccess"))
                    object.modifyAttributesAccess = $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.toObject(message.modifyAttributesAccess, options);
                if (message.modifyMemberAccess != null && message.hasOwnProperty("modifyMemberAccess"))
                    object.modifyMemberAccess = $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.toObject(message.modifyMemberAccess, options);
                if (message.modifyAddFromInviteLinkAccess != null && message.hasOwnProperty("modifyAddFromInviteLinkAccess"))
                    object.modifyAddFromInviteLinkAccess = $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.toObject(message.modifyAddFromInviteLinkAccess, options);
                if (message.addMemberPendingAdminApprovals && message.addMemberPendingAdminApprovals.length) {
                    object.addMemberPendingAdminApprovals = [];
                    for (var j = 0; j < message.addMemberPendingAdminApprovals.length; ++j)
                        object.addMemberPendingAdminApprovals[j] = $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.toObject(message.addMemberPendingAdminApprovals[j], options);
                }
                if (message.deleteMemberPendingAdminApprovals && message.deleteMemberPendingAdminApprovals.length) {
                    object.deleteMemberPendingAdminApprovals = [];
                    for (var j = 0; j < message.deleteMemberPendingAdminApprovals.length; ++j)
                        object.deleteMemberPendingAdminApprovals[j] = $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.toObject(message.deleteMemberPendingAdminApprovals[j], options);
                }
                if (message.promoteMemberPendingAdminApprovals && message.promoteMemberPendingAdminApprovals.length) {
                    object.promoteMemberPendingAdminApprovals = [];
                    for (var j = 0; j < message.promoteMemberPendingAdminApprovals.length; ++j)
                        object.promoteMemberPendingAdminApprovals[j] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.toObject(message.promoteMemberPendingAdminApprovals[j], options);
                }
                if (message.modifyInviteLinkPassword != null && message.hasOwnProperty("modifyInviteLinkPassword"))
                    object.modifyInviteLinkPassword = $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.toObject(message.modifyInviteLinkPassword, options);
                if (message.modifyDescription != null && message.hasOwnProperty("modifyDescription"))
                    object.modifyDescription = $root.signalservice.GroupChange.Actions.ModifyDescriptionAction.toObject(message.modifyDescription, options);
                if (message.modifyAnnouncementsOnly != null && message.hasOwnProperty("modifyAnnouncementsOnly"))
                    object.modifyAnnouncementsOnly = $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.toObject(message.modifyAnnouncementsOnly, options);
                if (message.addMembersBanned && message.addMembersBanned.length) {
                    object.addMembersBanned = [];
                    for (var j = 0; j < message.addMembersBanned.length; ++j)
                        object.addMembersBanned[j] = $root.signalservice.GroupChange.Actions.AddMemberBannedAction.toObject(message.addMembersBanned[j], options);
                }
                if (message.deleteMembersBanned && message.deleteMembersBanned.length) {
                    object.deleteMembersBanned = [];
                    for (var j = 0; j < message.deleteMembersBanned.length; ++j)
                        object.deleteMembersBanned[j] = $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction.toObject(message.deleteMembersBanned[j], options);
                }
                if (message.promoteMembersPendingPniAciProfileKey && message.promoteMembersPendingPniAciProfileKey.length) {
                    object.promoteMembersPendingPniAciProfileKey = [];
                    for (var j = 0; j < message.promoteMembersPendingPniAciProfileKey.length; ++j)
                        object.promoteMembersPendingPniAciProfileKey[j] = $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.toObject(message.promoteMembersPendingPniAciProfileKey[j], options);
                }
                return object;
            };

            /**
             * Converts this Actions to JSON.
             * @function toJSON
             * @memberof signalservice.GroupChange.Actions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Actions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Actions.AddMemberAction = (function() {

                /**
                 * Properties of an AddMemberAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IAddMemberAction
                 * @property {signalservice.IMember|null} [added] AddMemberAction added
                 * @property {boolean|null} [joinFromInviteLink] AddMemberAction joinFromInviteLink
                 */

                /**
                 * Constructs a new AddMemberAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents an AddMemberAction.
                 * @implements IAddMemberAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IAddMemberAction=} [properties] Properties to set
                 */
                function AddMemberAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddMemberAction added.
                 * @member {signalservice.IMember|null|undefined} added
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @instance
                 */
                AddMemberAction.prototype.added = null;

                /**
                 * AddMemberAction joinFromInviteLink.
                 * @member {boolean} joinFromInviteLink
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @instance
                 */
                AddMemberAction.prototype.joinFromInviteLink = false;

                /**
                 * Encodes the specified AddMemberAction message. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberAction} message AddMemberAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.AddMemberAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.added != null && Object.hasOwnProperty.call(message, "added"))
                        $root.signalservice.Member.encode(message.added, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.joinFromInviteLink != null && Object.hasOwnProperty.call(message, "joinFromInviteLink"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.joinFromInviteLink);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified AddMemberAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberAction} message AddMemberAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddMemberAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.AddMemberAction} AddMemberAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.AddMemberAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.added = $root.signalservice.Member.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.joinFromInviteLink = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddMemberAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.AddMemberAction} AddMemberAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an AddMemberAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.AddMemberAction} AddMemberAction
                 */
                AddMemberAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.AddMemberAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.AddMemberAction();
                    if (object.added != null) {
                        if (typeof object.added !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.AddMemberAction.added: object expected");
                        message.added = $root.signalservice.Member.fromObject(object.added);
                    }
                    if (object.joinFromInviteLink != null)
                        message.joinFromInviteLink = Boolean(object.joinFromInviteLink);
                    return message;
                };

                /**
                 * Creates a plain object from an AddMemberAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.AddMemberAction} message AddMemberAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddMemberAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.added = null;
                        object.joinFromInviteLink = false;
                    }
                    if (message.added != null && message.hasOwnProperty("added"))
                        object.added = $root.signalservice.Member.toObject(message.added, options);
                    if (message.joinFromInviteLink != null && message.hasOwnProperty("joinFromInviteLink"))
                        object.joinFromInviteLink = message.joinFromInviteLink;
                    return object;
                };

                /**
                 * Converts this AddMemberAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.AddMemberAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddMemberAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AddMemberAction;
            })();

            Actions.DeleteMemberAction = (function() {

                /**
                 * Properties of a DeleteMemberAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IDeleteMemberAction
                 * @property {Uint8Array|null} [deletedUserId] DeleteMemberAction deletedUserId
                 */

                /**
                 * Constructs a new DeleteMemberAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a DeleteMemberAction.
                 * @implements IDeleteMemberAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberAction=} [properties] Properties to set
                 */
                function DeleteMemberAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteMemberAction deletedUserId.
                 * @member {Uint8Array} deletedUserId
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @instance
                 */
                DeleteMemberAction.prototype.deletedUserId = $util.newBuffer([]);

                /**
                 * Encodes the specified DeleteMemberAction message. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberAction} message DeleteMemberAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.DeleteMemberAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.deletedUserId != null && Object.hasOwnProperty.call(message, "deletedUserId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deletedUserId);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified DeleteMemberAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberAction} message DeleteMemberAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteMemberAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberAction} DeleteMemberAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.DeleteMemberAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deletedUserId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteMemberAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberAction} DeleteMemberAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a DeleteMemberAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberAction} DeleteMemberAction
                 */
                DeleteMemberAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.DeleteMemberAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.DeleteMemberAction();
                    if (object.deletedUserId != null)
                        if (typeof object.deletedUserId === "string")
                            $util.base64.decode(object.deletedUserId, message.deletedUserId = $util.newBuffer($util.base64.length(object.deletedUserId)), 0);
                        else if (object.deletedUserId.length)
                            message.deletedUserId = object.deletedUserId;
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteMemberAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.DeleteMemberAction} message DeleteMemberAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteMemberAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.deletedUserId = "";
                        else {
                            object.deletedUserId = [];
                            if (options.bytes !== Array)
                                object.deletedUserId = $util.newBuffer(object.deletedUserId);
                        }
                    if (message.deletedUserId != null && message.hasOwnProperty("deletedUserId"))
                        object.deletedUserId = options.bytes === String ? $util.base64.encode(message.deletedUserId, 0, message.deletedUserId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deletedUserId) : message.deletedUserId;
                    return object;
                };

                /**
                 * Converts this DeleteMemberAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteMemberAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteMemberAction;
            })();

            Actions.ModifyMemberRoleAction = (function() {

                /**
                 * Properties of a ModifyMemberRoleAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyMemberRoleAction
                 * @property {Uint8Array|null} [userId] ModifyMemberRoleAction userId
                 * @property {signalservice.Member.Role|null} [role] ModifyMemberRoleAction role
                 */

                /**
                 * Constructs a new ModifyMemberRoleAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyMemberRoleAction.
                 * @implements IModifyMemberRoleAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyMemberRoleAction=} [properties] Properties to set
                 */
                function ModifyMemberRoleAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyMemberRoleAction userId.
                 * @member {Uint8Array} userId
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @instance
                 */
                ModifyMemberRoleAction.prototype.userId = $util.newBuffer([]);

                /**
                 * ModifyMemberRoleAction role.
                 * @member {signalservice.Member.Role} role
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @instance
                 */
                ModifyMemberRoleAction.prototype.role = 0;

                /**
                 * Encodes the specified ModifyMemberRoleAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMemberRoleAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMemberRoleAction} message ModifyMemberRoleAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMemberRoleAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userId);
                    if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyMemberRoleAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMemberRoleAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMemberRoleAction} message ModifyMemberRoleAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMemberRoleAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyMemberRoleAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberRoleAction} ModifyMemberRoleAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMemberRoleAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.userId = reader.bytes();
                            break;
                        case 2:
                            message.role = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyMemberRoleAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberRoleAction} ModifyMemberRoleAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMemberRoleAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyMemberRoleAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberRoleAction} ModifyMemberRoleAction
                 */
                ModifyMemberRoleAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyMemberRoleAction();
                    if (object.userId != null)
                        if (typeof object.userId === "string")
                            $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                        else if (object.userId.length)
                            message.userId = object.userId;
                    switch (object.role) {
                    case "UNKNOWN":
                    case 0:
                        message.role = 0;
                        break;
                    case "DEFAULT":
                    case 1:
                        message.role = 1;
                        break;
                    case "ADMINISTRATOR":
                    case 2:
                        message.role = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyMemberRoleAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyMemberRoleAction} message ModifyMemberRoleAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyMemberRoleAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.userId = "";
                        else {
                            object.userId = [];
                            if (options.bytes !== Array)
                                object.userId = $util.newBuffer(object.userId);
                        }
                        object.role = options.enums === String ? "UNKNOWN" : 0;
                    }
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = options.enums === String ? $root.signalservice.Member.Role[message.role] : message.role;
                    return object;
                };

                /**
                 * Converts this ModifyMemberRoleAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberRoleAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyMemberRoleAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyMemberRoleAction;
            })();

            Actions.ModifyMemberProfileKeyAction = (function() {

                /**
                 * Properties of a ModifyMemberProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyMemberProfileKeyAction
                 * @property {Uint8Array|null} [presentation] ModifyMemberProfileKeyAction presentation
                 * @property {Uint8Array|null} [userId] ModifyMemberProfileKeyAction userId
                 * @property {Uint8Array|null} [profileKey] ModifyMemberProfileKeyAction profileKey
                 */

                /**
                 * Constructs a new ModifyMemberProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyMemberProfileKeyAction.
                 * @implements IModifyMemberProfileKeyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyMemberProfileKeyAction=} [properties] Properties to set
                 */
                function ModifyMemberProfileKeyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyMemberProfileKeyAction presentation.
                 * @member {Uint8Array} presentation
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @instance
                 */
                ModifyMemberProfileKeyAction.prototype.presentation = $util.newBuffer([]);

                /**
                 * ModifyMemberProfileKeyAction userId.
                 * @member {Uint8Array} userId
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @instance
                 */
                ModifyMemberProfileKeyAction.prototype.userId = $util.newBuffer([]);

                /**
                 * ModifyMemberProfileKeyAction profileKey.
                 * @member {Uint8Array} profileKey
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @instance
                 */
                ModifyMemberProfileKeyAction.prototype.profileKey = $util.newBuffer([]);

                /**
                 * Encodes the specified ModifyMemberProfileKeyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMemberProfileKeyAction} message ModifyMemberProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMemberProfileKeyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.presentation);
                    if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userId);
                    if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.profileKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyMemberProfileKeyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMemberProfileKeyAction} message ModifyMemberProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMemberProfileKeyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyMemberProfileKeyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction} ModifyMemberProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMemberProfileKeyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.presentation = reader.bytes();
                            break;
                        case 2:
                            message.userId = reader.bytes();
                            break;
                        case 3:
                            message.profileKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyMemberProfileKeyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction} ModifyMemberProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMemberProfileKeyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyMemberProfileKeyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction} ModifyMemberProfileKeyAction
                 */
                ModifyMemberProfileKeyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction();
                    if (object.presentation != null)
                        if (typeof object.presentation === "string")
                            $util.base64.decode(object.presentation, message.presentation = $util.newBuffer($util.base64.length(object.presentation)), 0);
                        else if (object.presentation.length)
                            message.presentation = object.presentation;
                    if (object.userId != null)
                        if (typeof object.userId === "string")
                            $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                        else if (object.userId.length)
                            message.userId = object.userId;
                    if (object.profileKey != null)
                        if (typeof object.profileKey === "string")
                            $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                        else if (object.profileKey.length)
                            message.profileKey = object.profileKey;
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyMemberProfileKeyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction} message ModifyMemberProfileKeyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyMemberProfileKeyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.presentation = "";
                        else {
                            object.presentation = [];
                            if (options.bytes !== Array)
                                object.presentation = $util.newBuffer(object.presentation);
                        }
                        if (options.bytes === String)
                            object.userId = "";
                        else {
                            object.userId = [];
                            if (options.bytes !== Array)
                                object.userId = $util.newBuffer(object.userId);
                        }
                        if (options.bytes === String)
                            object.profileKey = "";
                        else {
                            object.profileKey = [];
                            if (options.bytes !== Array)
                                object.profileKey = $util.newBuffer(object.profileKey);
                        }
                    }
                    if (message.presentation != null && message.hasOwnProperty("presentation"))
                        object.presentation = options.bytes === String ? $util.base64.encode(message.presentation, 0, message.presentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.presentation) : message.presentation;
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
                    if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                        object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
                    return object;
                };

                /**
                 * Converts this ModifyMemberProfileKeyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyMemberProfileKeyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyMemberProfileKeyAction;
            })();

            Actions.AddMemberPendingProfileKeyAction = (function() {

                /**
                 * Properties of an AddMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IAddMemberPendingProfileKeyAction
                 * @property {signalservice.IMemberPendingProfileKey|null} [added] AddMemberPendingProfileKeyAction added
                 */

                /**
                 * Constructs a new AddMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents an AddMemberPendingProfileKeyAction.
                 * @implements IAddMemberPendingProfileKeyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingProfileKeyAction=} [properties] Properties to set
                 */
                function AddMemberPendingProfileKeyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddMemberPendingProfileKeyAction added.
                 * @member {signalservice.IMemberPendingProfileKey|null|undefined} added
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @instance
                 */
                AddMemberPendingProfileKeyAction.prototype.added = null;

                /**
                 * Encodes the specified AddMemberPendingProfileKeyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingProfileKeyAction} message AddMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberPendingProfileKeyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.added != null && Object.hasOwnProperty.call(message, "added"))
                        $root.signalservice.MemberPendingProfileKey.encode(message.added, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified AddMemberPendingProfileKeyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingProfileKeyAction} message AddMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberPendingProfileKeyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddMemberPendingProfileKeyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction} AddMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberPendingProfileKeyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.added = $root.signalservice.MemberPendingProfileKey.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddMemberPendingProfileKeyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction} AddMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberPendingProfileKeyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an AddMemberPendingProfileKeyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction} AddMemberPendingProfileKeyAction
                 */
                AddMemberPendingProfileKeyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction();
                    if (object.added != null) {
                        if (typeof object.added !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction.added: object expected");
                        message.added = $root.signalservice.MemberPendingProfileKey.fromObject(object.added);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AddMemberPendingProfileKeyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction} message AddMemberPendingProfileKeyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddMemberPendingProfileKeyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.added = null;
                    if (message.added != null && message.hasOwnProperty("added"))
                        object.added = $root.signalservice.MemberPendingProfileKey.toObject(message.added, options);
                    return object;
                };

                /**
                 * Converts this AddMemberPendingProfileKeyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingProfileKeyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddMemberPendingProfileKeyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AddMemberPendingProfileKeyAction;
            })();

            Actions.DeleteMemberPendingProfileKeyAction = (function() {

                /**
                 * Properties of a DeleteMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IDeleteMemberPendingProfileKeyAction
                 * @property {Uint8Array|null} [deletedUserId] DeleteMemberPendingProfileKeyAction deletedUserId
                 */

                /**
                 * Constructs a new DeleteMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a DeleteMemberPendingProfileKeyAction.
                 * @implements IDeleteMemberPendingProfileKeyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingProfileKeyAction=} [properties] Properties to set
                 */
                function DeleteMemberPendingProfileKeyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteMemberPendingProfileKeyAction deletedUserId.
                 * @member {Uint8Array} deletedUserId
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @instance
                 */
                DeleteMemberPendingProfileKeyAction.prototype.deletedUserId = $util.newBuffer([]);

                /**
                 * Encodes the specified DeleteMemberPendingProfileKeyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingProfileKeyAction} message DeleteMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberPendingProfileKeyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.deletedUserId != null && Object.hasOwnProperty.call(message, "deletedUserId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deletedUserId);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified DeleteMemberPendingProfileKeyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingProfileKeyAction} message DeleteMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberPendingProfileKeyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteMemberPendingProfileKeyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction} DeleteMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberPendingProfileKeyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deletedUserId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteMemberPendingProfileKeyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction} DeleteMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberPendingProfileKeyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a DeleteMemberPendingProfileKeyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction} DeleteMemberPendingProfileKeyAction
                 */
                DeleteMemberPendingProfileKeyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction();
                    if (object.deletedUserId != null)
                        if (typeof object.deletedUserId === "string")
                            $util.base64.decode(object.deletedUserId, message.deletedUserId = $util.newBuffer($util.base64.length(object.deletedUserId)), 0);
                        else if (object.deletedUserId.length)
                            message.deletedUserId = object.deletedUserId;
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteMemberPendingProfileKeyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction} message DeleteMemberPendingProfileKeyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteMemberPendingProfileKeyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.deletedUserId = "";
                        else {
                            object.deletedUserId = [];
                            if (options.bytes !== Array)
                                object.deletedUserId = $util.newBuffer(object.deletedUserId);
                        }
                    if (message.deletedUserId != null && message.hasOwnProperty("deletedUserId"))
                        object.deletedUserId = options.bytes === String ? $util.base64.encode(message.deletedUserId, 0, message.deletedUserId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deletedUserId) : message.deletedUserId;
                    return object;
                };

                /**
                 * Converts this DeleteMemberPendingProfileKeyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingProfileKeyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteMemberPendingProfileKeyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteMemberPendingProfileKeyAction;
            })();

            Actions.PromoteMemberPendingProfileKeyAction = (function() {

                /**
                 * Properties of a PromoteMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IPromoteMemberPendingProfileKeyAction
                 * @property {Uint8Array|null} [presentation] PromoteMemberPendingProfileKeyAction presentation
                 * @property {Uint8Array|null} [userId] PromoteMemberPendingProfileKeyAction userId
                 * @property {Uint8Array|null} [profileKey] PromoteMemberPendingProfileKeyAction profileKey
                 */

                /**
                 * Constructs a new PromoteMemberPendingProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a PromoteMemberPendingProfileKeyAction.
                 * @implements IPromoteMemberPendingProfileKeyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingProfileKeyAction=} [properties] Properties to set
                 */
                function PromoteMemberPendingProfileKeyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PromoteMemberPendingProfileKeyAction presentation.
                 * @member {Uint8Array} presentation
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingProfileKeyAction.prototype.presentation = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingProfileKeyAction userId.
                 * @member {Uint8Array} userId
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingProfileKeyAction.prototype.userId = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingProfileKeyAction profileKey.
                 * @member {Uint8Array} profileKey
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingProfileKeyAction.prototype.profileKey = $util.newBuffer([]);

                /**
                 * Encodes the specified PromoteMemberPendingProfileKeyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingProfileKeyAction} message PromoteMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingProfileKeyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.presentation);
                    if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userId);
                    if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.profileKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified PromoteMemberPendingProfileKeyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingProfileKeyAction} message PromoteMemberPendingProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingProfileKeyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PromoteMemberPendingProfileKeyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction} PromoteMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingProfileKeyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.presentation = reader.bytes();
                            break;
                        case 2:
                            message.userId = reader.bytes();
                            break;
                        case 3:
                            message.profileKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PromoteMemberPendingProfileKeyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction} PromoteMemberPendingProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingProfileKeyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a PromoteMemberPendingProfileKeyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction} PromoteMemberPendingProfileKeyAction
                 */
                PromoteMemberPendingProfileKeyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction();
                    if (object.presentation != null)
                        if (typeof object.presentation === "string")
                            $util.base64.decode(object.presentation, message.presentation = $util.newBuffer($util.base64.length(object.presentation)), 0);
                        else if (object.presentation.length)
                            message.presentation = object.presentation;
                    if (object.userId != null)
                        if (typeof object.userId === "string")
                            $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                        else if (object.userId.length)
                            message.userId = object.userId;
                    if (object.profileKey != null)
                        if (typeof object.profileKey === "string")
                            $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                        else if (object.profileKey.length)
                            message.profileKey = object.profileKey;
                    return message;
                };

                /**
                 * Creates a plain object from a PromoteMemberPendingProfileKeyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction} message PromoteMemberPendingProfileKeyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PromoteMemberPendingProfileKeyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.presentation = "";
                        else {
                            object.presentation = [];
                            if (options.bytes !== Array)
                                object.presentation = $util.newBuffer(object.presentation);
                        }
                        if (options.bytes === String)
                            object.userId = "";
                        else {
                            object.userId = [];
                            if (options.bytes !== Array)
                                object.userId = $util.newBuffer(object.userId);
                        }
                        if (options.bytes === String)
                            object.profileKey = "";
                        else {
                            object.profileKey = [];
                            if (options.bytes !== Array)
                                object.profileKey = $util.newBuffer(object.profileKey);
                        }
                    }
                    if (message.presentation != null && message.hasOwnProperty("presentation"))
                        object.presentation = options.bytes === String ? $util.base64.encode(message.presentation, 0, message.presentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.presentation) : message.presentation;
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
                    if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                        object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
                    return object;
                };

                /**
                 * Converts this PromoteMemberPendingProfileKeyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingProfileKeyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PromoteMemberPendingProfileKeyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PromoteMemberPendingProfileKeyAction;
            })();

            Actions.PromoteMemberPendingPniAciProfileKeyAction = (function() {

                /**
                 * Properties of a PromoteMemberPendingPniAciProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IPromoteMemberPendingPniAciProfileKeyAction
                 * @property {Uint8Array|null} [presentation] PromoteMemberPendingPniAciProfileKeyAction presentation
                 * @property {Uint8Array|null} [userId] PromoteMemberPendingPniAciProfileKeyAction userId
                 * @property {Uint8Array|null} [pni] PromoteMemberPendingPniAciProfileKeyAction pni
                 * @property {Uint8Array|null} [profileKey] PromoteMemberPendingPniAciProfileKeyAction profileKey
                 */

                /**
                 * Constructs a new PromoteMemberPendingPniAciProfileKeyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a PromoteMemberPendingPniAciProfileKeyAction.
                 * @implements IPromoteMemberPendingPniAciProfileKeyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingPniAciProfileKeyAction=} [properties] Properties to set
                 */
                function PromoteMemberPendingPniAciProfileKeyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PromoteMemberPendingPniAciProfileKeyAction presentation.
                 * @member {Uint8Array} presentation
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingPniAciProfileKeyAction.prototype.presentation = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingPniAciProfileKeyAction userId.
                 * @member {Uint8Array} userId
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingPniAciProfileKeyAction.prototype.userId = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingPniAciProfileKeyAction pni.
                 * @member {Uint8Array} pni
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingPniAciProfileKeyAction.prototype.pni = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingPniAciProfileKeyAction profileKey.
                 * @member {Uint8Array} profileKey
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @instance
                 */
                PromoteMemberPendingPniAciProfileKeyAction.prototype.profileKey = $util.newBuffer([]);

                /**
                 * Encodes the specified PromoteMemberPendingPniAciProfileKeyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingPniAciProfileKeyAction} message PromoteMemberPendingPniAciProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingPniAciProfileKeyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.presentation);
                    if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userId);
                    if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pni);
                    if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.profileKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified PromoteMemberPendingPniAciProfileKeyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingPniAciProfileKeyAction} message PromoteMemberPendingPniAciProfileKeyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingPniAciProfileKeyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PromoteMemberPendingPniAciProfileKeyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction} PromoteMemberPendingPniAciProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingPniAciProfileKeyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.presentation = reader.bytes();
                            break;
                        case 2:
                            message.userId = reader.bytes();
                            break;
                        case 3:
                            message.pni = reader.bytes();
                            break;
                        case 4:
                            message.profileKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PromoteMemberPendingPniAciProfileKeyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction} PromoteMemberPendingPniAciProfileKeyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingPniAciProfileKeyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a PromoteMemberPendingPniAciProfileKeyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction} PromoteMemberPendingPniAciProfileKeyAction
                 */
                PromoteMemberPendingPniAciProfileKeyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction();
                    if (object.presentation != null)
                        if (typeof object.presentation === "string")
                            $util.base64.decode(object.presentation, message.presentation = $util.newBuffer($util.base64.length(object.presentation)), 0);
                        else if (object.presentation.length)
                            message.presentation = object.presentation;
                    if (object.userId != null)
                        if (typeof object.userId === "string")
                            $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                        else if (object.userId.length)
                            message.userId = object.userId;
                    if (object.pni != null)
                        if (typeof object.pni === "string")
                            $util.base64.decode(object.pni, message.pni = $util.newBuffer($util.base64.length(object.pni)), 0);
                        else if (object.pni.length)
                            message.pni = object.pni;
                    if (object.profileKey != null)
                        if (typeof object.profileKey === "string")
                            $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                        else if (object.profileKey.length)
                            message.profileKey = object.profileKey;
                    return message;
                };

                /**
                 * Creates a plain object from a PromoteMemberPendingPniAciProfileKeyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction} message PromoteMemberPendingPniAciProfileKeyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PromoteMemberPendingPniAciProfileKeyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.presentation = "";
                        else {
                            object.presentation = [];
                            if (options.bytes !== Array)
                                object.presentation = $util.newBuffer(object.presentation);
                        }
                        if (options.bytes === String)
                            object.userId = "";
                        else {
                            object.userId = [];
                            if (options.bytes !== Array)
                                object.userId = $util.newBuffer(object.userId);
                        }
                        if (options.bytes === String)
                            object.pni = "";
                        else {
                            object.pni = [];
                            if (options.bytes !== Array)
                                object.pni = $util.newBuffer(object.pni);
                        }
                        if (options.bytes === String)
                            object.profileKey = "";
                        else {
                            object.profileKey = [];
                            if (options.bytes !== Array)
                                object.profileKey = $util.newBuffer(object.profileKey);
                        }
                    }
                    if (message.presentation != null && message.hasOwnProperty("presentation"))
                        object.presentation = options.bytes === String ? $util.base64.encode(message.presentation, 0, message.presentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.presentation) : message.presentation;
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
                    if (message.pni != null && message.hasOwnProperty("pni"))
                        object.pni = options.bytes === String ? $util.base64.encode(message.pni, 0, message.pni.length) : options.bytes === Array ? Array.prototype.slice.call(message.pni) : message.pni;
                    if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                        object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
                    return object;
                };

                /**
                 * Converts this PromoteMemberPendingPniAciProfileKeyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingPniAciProfileKeyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PromoteMemberPendingPniAciProfileKeyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PromoteMemberPendingPniAciProfileKeyAction;
            })();

            Actions.AddMemberPendingAdminApprovalAction = (function() {

                /**
                 * Properties of an AddMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IAddMemberPendingAdminApprovalAction
                 * @property {signalservice.IMemberPendingAdminApproval|null} [added] AddMemberPendingAdminApprovalAction added
                 */

                /**
                 * Constructs a new AddMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents an AddMemberPendingAdminApprovalAction.
                 * @implements IAddMemberPendingAdminApprovalAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingAdminApprovalAction=} [properties] Properties to set
                 */
                function AddMemberPendingAdminApprovalAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddMemberPendingAdminApprovalAction added.
                 * @member {signalservice.IMemberPendingAdminApproval|null|undefined} added
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @instance
                 */
                AddMemberPendingAdminApprovalAction.prototype.added = null;

                /**
                 * Encodes the specified AddMemberPendingAdminApprovalAction message. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingAdminApprovalAction} message AddMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberPendingAdminApprovalAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.added != null && Object.hasOwnProperty.call(message, "added"))
                        $root.signalservice.MemberPendingAdminApproval.encode(message.added, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified AddMemberPendingAdminApprovalAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberPendingAdminApprovalAction} message AddMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberPendingAdminApprovalAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddMemberPendingAdminApprovalAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction} AddMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberPendingAdminApprovalAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.added = $root.signalservice.MemberPendingAdminApproval.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddMemberPendingAdminApprovalAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction} AddMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberPendingAdminApprovalAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an AddMemberPendingAdminApprovalAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction} AddMemberPendingAdminApprovalAction
                 */
                AddMemberPendingAdminApprovalAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction();
                    if (object.added != null) {
                        if (typeof object.added !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction.added: object expected");
                        message.added = $root.signalservice.MemberPendingAdminApproval.fromObject(object.added);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AddMemberPendingAdminApprovalAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction} message AddMemberPendingAdminApprovalAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddMemberPendingAdminApprovalAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.added = null;
                    if (message.added != null && message.hasOwnProperty("added"))
                        object.added = $root.signalservice.MemberPendingAdminApproval.toObject(message.added, options);
                    return object;
                };

                /**
                 * Converts this AddMemberPendingAdminApprovalAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.AddMemberPendingAdminApprovalAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddMemberPendingAdminApprovalAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AddMemberPendingAdminApprovalAction;
            })();

            Actions.DeleteMemberPendingAdminApprovalAction = (function() {

                /**
                 * Properties of a DeleteMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IDeleteMemberPendingAdminApprovalAction
                 * @property {Uint8Array|null} [deletedUserId] DeleteMemberPendingAdminApprovalAction deletedUserId
                 */

                /**
                 * Constructs a new DeleteMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a DeleteMemberPendingAdminApprovalAction.
                 * @implements IDeleteMemberPendingAdminApprovalAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingAdminApprovalAction=} [properties] Properties to set
                 */
                function DeleteMemberPendingAdminApprovalAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteMemberPendingAdminApprovalAction deletedUserId.
                 * @member {Uint8Array} deletedUserId
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @instance
                 */
                DeleteMemberPendingAdminApprovalAction.prototype.deletedUserId = $util.newBuffer([]);

                /**
                 * Encodes the specified DeleteMemberPendingAdminApprovalAction message. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingAdminApprovalAction} message DeleteMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberPendingAdminApprovalAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.deletedUserId != null && Object.hasOwnProperty.call(message, "deletedUserId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deletedUserId);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified DeleteMemberPendingAdminApprovalAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberPendingAdminApprovalAction} message DeleteMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberPendingAdminApprovalAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteMemberPendingAdminApprovalAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction} DeleteMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberPendingAdminApprovalAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deletedUserId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteMemberPendingAdminApprovalAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction} DeleteMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberPendingAdminApprovalAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a DeleteMemberPendingAdminApprovalAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction} DeleteMemberPendingAdminApprovalAction
                 */
                DeleteMemberPendingAdminApprovalAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction();
                    if (object.deletedUserId != null)
                        if (typeof object.deletedUserId === "string")
                            $util.base64.decode(object.deletedUserId, message.deletedUserId = $util.newBuffer($util.base64.length(object.deletedUserId)), 0);
                        else if (object.deletedUserId.length)
                            message.deletedUserId = object.deletedUserId;
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteMemberPendingAdminApprovalAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction} message DeleteMemberPendingAdminApprovalAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteMemberPendingAdminApprovalAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.deletedUserId = "";
                        else {
                            object.deletedUserId = [];
                            if (options.bytes !== Array)
                                object.deletedUserId = $util.newBuffer(object.deletedUserId);
                        }
                    if (message.deletedUserId != null && message.hasOwnProperty("deletedUserId"))
                        object.deletedUserId = options.bytes === String ? $util.base64.encode(message.deletedUserId, 0, message.deletedUserId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deletedUserId) : message.deletedUserId;
                    return object;
                };

                /**
                 * Converts this DeleteMemberPendingAdminApprovalAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberPendingAdminApprovalAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteMemberPendingAdminApprovalAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteMemberPendingAdminApprovalAction;
            })();

            Actions.PromoteMemberPendingAdminApprovalAction = (function() {

                /**
                 * Properties of a PromoteMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IPromoteMemberPendingAdminApprovalAction
                 * @property {Uint8Array|null} [userId] PromoteMemberPendingAdminApprovalAction userId
                 * @property {signalservice.Member.Role|null} [role] PromoteMemberPendingAdminApprovalAction role
                 */

                /**
                 * Constructs a new PromoteMemberPendingAdminApprovalAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a PromoteMemberPendingAdminApprovalAction.
                 * @implements IPromoteMemberPendingAdminApprovalAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingAdminApprovalAction=} [properties] Properties to set
                 */
                function PromoteMemberPendingAdminApprovalAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PromoteMemberPendingAdminApprovalAction userId.
                 * @member {Uint8Array} userId
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @instance
                 */
                PromoteMemberPendingAdminApprovalAction.prototype.userId = $util.newBuffer([]);

                /**
                 * PromoteMemberPendingAdminApprovalAction role.
                 * @member {signalservice.Member.Role} role
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @instance
                 */
                PromoteMemberPendingAdminApprovalAction.prototype.role = 0;

                /**
                 * Encodes the specified PromoteMemberPendingAdminApprovalAction message. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingAdminApprovalAction} message PromoteMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingAdminApprovalAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userId);
                    if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified PromoteMemberPendingAdminApprovalAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IPromoteMemberPendingAdminApprovalAction} message PromoteMemberPendingAdminApprovalAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PromoteMemberPendingAdminApprovalAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PromoteMemberPendingAdminApprovalAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction} PromoteMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingAdminApprovalAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.userId = reader.bytes();
                            break;
                        case 2:
                            message.role = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PromoteMemberPendingAdminApprovalAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction} PromoteMemberPendingAdminApprovalAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PromoteMemberPendingAdminApprovalAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a PromoteMemberPendingAdminApprovalAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction} PromoteMemberPendingAdminApprovalAction
                 */
                PromoteMemberPendingAdminApprovalAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction();
                    if (object.userId != null)
                        if (typeof object.userId === "string")
                            $util.base64.decode(object.userId, message.userId = $util.newBuffer($util.base64.length(object.userId)), 0);
                        else if (object.userId.length)
                            message.userId = object.userId;
                    switch (object.role) {
                    case "UNKNOWN":
                    case 0:
                        message.role = 0;
                        break;
                    case "DEFAULT":
                    case 1:
                        message.role = 1;
                        break;
                    case "ADMINISTRATOR":
                    case 2:
                        message.role = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PromoteMemberPendingAdminApprovalAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction} message PromoteMemberPendingAdminApprovalAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PromoteMemberPendingAdminApprovalAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.userId = "";
                        else {
                            object.userId = [];
                            if (options.bytes !== Array)
                                object.userId = $util.newBuffer(object.userId);
                        }
                        object.role = options.enums === String ? "UNKNOWN" : 0;
                    }
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = options.bytes === String ? $util.base64.encode(message.userId, 0, message.userId.length) : options.bytes === Array ? Array.prototype.slice.call(message.userId) : message.userId;
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = options.enums === String ? $root.signalservice.Member.Role[message.role] : message.role;
                    return object;
                };

                /**
                 * Converts this PromoteMemberPendingAdminApprovalAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.PromoteMemberPendingAdminApprovalAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PromoteMemberPendingAdminApprovalAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PromoteMemberPendingAdminApprovalAction;
            })();

            Actions.AddMemberBannedAction = (function() {

                /**
                 * Properties of an AddMemberBannedAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IAddMemberBannedAction
                 * @property {signalservice.IMemberBanned|null} [added] AddMemberBannedAction added
                 */

                /**
                 * Constructs a new AddMemberBannedAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents an AddMemberBannedAction.
                 * @implements IAddMemberBannedAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IAddMemberBannedAction=} [properties] Properties to set
                 */
                function AddMemberBannedAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddMemberBannedAction added.
                 * @member {signalservice.IMemberBanned|null|undefined} added
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @instance
                 */
                AddMemberBannedAction.prototype.added = null;

                /**
                 * Encodes the specified AddMemberBannedAction message. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberBannedAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberBannedAction} message AddMemberBannedAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberBannedAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.AddMemberBannedAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.added != null && Object.hasOwnProperty.call(message, "added"))
                        $root.signalservice.MemberBanned.encode(message.added, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified AddMemberBannedAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.AddMemberBannedAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IAddMemberBannedAction} message AddMemberBannedAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddMemberBannedAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddMemberBannedAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.AddMemberBannedAction} AddMemberBannedAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberBannedAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.AddMemberBannedAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.added = $root.signalservice.MemberBanned.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddMemberBannedAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.AddMemberBannedAction} AddMemberBannedAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddMemberBannedAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an AddMemberBannedAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.AddMemberBannedAction} AddMemberBannedAction
                 */
                AddMemberBannedAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.AddMemberBannedAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.AddMemberBannedAction();
                    if (object.added != null) {
                        if (typeof object.added !== "object")
                            throw TypeError(".signalservice.GroupChange.Actions.AddMemberBannedAction.added: object expected");
                        message.added = $root.signalservice.MemberBanned.fromObject(object.added);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AddMemberBannedAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.AddMemberBannedAction} message AddMemberBannedAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddMemberBannedAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.added = null;
                    if (message.added != null && message.hasOwnProperty("added"))
                        object.added = $root.signalservice.MemberBanned.toObject(message.added, options);
                    return object;
                };

                /**
                 * Converts this AddMemberBannedAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.AddMemberBannedAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddMemberBannedAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AddMemberBannedAction;
            })();

            Actions.DeleteMemberBannedAction = (function() {

                /**
                 * Properties of a DeleteMemberBannedAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IDeleteMemberBannedAction
                 * @property {Uint8Array|null} [deletedUserId] DeleteMemberBannedAction deletedUserId
                 */

                /**
                 * Constructs a new DeleteMemberBannedAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a DeleteMemberBannedAction.
                 * @implements IDeleteMemberBannedAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberBannedAction=} [properties] Properties to set
                 */
                function DeleteMemberBannedAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteMemberBannedAction deletedUserId.
                 * @member {Uint8Array} deletedUserId
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @instance
                 */
                DeleteMemberBannedAction.prototype.deletedUserId = $util.newBuffer([]);

                /**
                 * Encodes the specified DeleteMemberBannedAction message. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberBannedAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberBannedAction} message DeleteMemberBannedAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberBannedAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.deletedUserId != null && Object.hasOwnProperty.call(message, "deletedUserId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deletedUserId);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified DeleteMemberBannedAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.DeleteMemberBannedAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IDeleteMemberBannedAction} message DeleteMemberBannedAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteMemberBannedAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteMemberBannedAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberBannedAction} DeleteMemberBannedAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberBannedAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deletedUserId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteMemberBannedAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberBannedAction} DeleteMemberBannedAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteMemberBannedAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a DeleteMemberBannedAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.DeleteMemberBannedAction} DeleteMemberBannedAction
                 */
                DeleteMemberBannedAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.DeleteMemberBannedAction();
                    if (object.deletedUserId != null)
                        if (typeof object.deletedUserId === "string")
                            $util.base64.decode(object.deletedUserId, message.deletedUserId = $util.newBuffer($util.base64.length(object.deletedUserId)), 0);
                        else if (object.deletedUserId.length)
                            message.deletedUserId = object.deletedUserId;
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteMemberBannedAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.DeleteMemberBannedAction} message DeleteMemberBannedAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteMemberBannedAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.deletedUserId = "";
                        else {
                            object.deletedUserId = [];
                            if (options.bytes !== Array)
                                object.deletedUserId = $util.newBuffer(object.deletedUserId);
                        }
                    if (message.deletedUserId != null && message.hasOwnProperty("deletedUserId"))
                        object.deletedUserId = options.bytes === String ? $util.base64.encode(message.deletedUserId, 0, message.deletedUserId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deletedUserId) : message.deletedUserId;
                    return object;
                };

                /**
                 * Converts this DeleteMemberBannedAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.DeleteMemberBannedAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteMemberBannedAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteMemberBannedAction;
            })();

            Actions.ModifyTitleAction = (function() {

                /**
                 * Properties of a ModifyTitleAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyTitleAction
                 * @property {Uint8Array|null} [title] ModifyTitleAction title
                 */

                /**
                 * Constructs a new ModifyTitleAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyTitleAction.
                 * @implements IModifyTitleAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyTitleAction=} [properties] Properties to set
                 */
                function ModifyTitleAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyTitleAction title.
                 * @member {Uint8Array} title
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @instance
                 */
                ModifyTitleAction.prototype.title = $util.newBuffer([]);

                /**
                 * Encodes the specified ModifyTitleAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyTitleAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyTitleAction} message ModifyTitleAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyTitleAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyTitleAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.title);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyTitleAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyTitleAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyTitleAction} message ModifyTitleAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyTitleAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyTitleAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyTitleAction} ModifyTitleAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyTitleAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyTitleAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyTitleAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyTitleAction} ModifyTitleAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyTitleAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyTitleAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyTitleAction} ModifyTitleAction
                 */
                ModifyTitleAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyTitleAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyTitleAction();
                    if (object.title != null)
                        if (typeof object.title === "string")
                            $util.base64.decode(object.title, message.title = $util.newBuffer($util.base64.length(object.title)), 0);
                        else if (object.title.length)
                            message.title = object.title;
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyTitleAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyTitleAction} message ModifyTitleAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyTitleAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.title = "";
                        else {
                            object.title = [];
                            if (options.bytes !== Array)
                                object.title = $util.newBuffer(object.title);
                        }
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = options.bytes === String ? $util.base64.encode(message.title, 0, message.title.length) : options.bytes === Array ? Array.prototype.slice.call(message.title) : message.title;
                    return object;
                };

                /**
                 * Converts this ModifyTitleAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyTitleAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyTitleAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyTitleAction;
            })();

            Actions.ModifyAvatarAction = (function() {

                /**
                 * Properties of a ModifyAvatarAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyAvatarAction
                 * @property {string|null} [avatar] ModifyAvatarAction avatar
                 */

                /**
                 * Constructs a new ModifyAvatarAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyAvatarAction.
                 * @implements IModifyAvatarAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAction=} [properties] Properties to set
                 */
                function ModifyAvatarAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyAvatarAction avatar.
                 * @member {string} avatar
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @instance
                 */
                ModifyAvatarAction.prototype.avatar = "";

                /**
                 * Encodes the specified ModifyAvatarAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAvatarAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAction} message ModifyAvatarAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAvatarAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyAvatarAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.avatar);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyAvatarAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAvatarAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAction} message ModifyAvatarAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAvatarAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyAvatarAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAction} ModifyAvatarAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAvatarAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyAvatarAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.avatar = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyAvatarAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAction} ModifyAvatarAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAvatarAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyAvatarAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAction} ModifyAvatarAction
                 */
                ModifyAvatarAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyAvatarAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyAvatarAction();
                    if (object.avatar != null)
                        message.avatar = String(object.avatar);
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyAvatarAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyAvatarAction} message ModifyAvatarAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyAvatarAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.avatar = "";
                    if (message.avatar != null && message.hasOwnProperty("avatar"))
                        object.avatar = message.avatar;
                    return object;
                };

                /**
                 * Converts this ModifyAvatarAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyAvatarAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyAvatarAction;
            })();

            Actions.ModifyDisappearingMessagesTimerAction = (function() {

                /**
                 * Properties of a ModifyDisappearingMessagesTimerAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyDisappearingMessagesTimerAction
                 * @property {Uint8Array|null} [timer] ModifyDisappearingMessagesTimerAction timer
                 */

                /**
                 * Constructs a new ModifyDisappearingMessagesTimerAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyDisappearingMessagesTimerAction.
                 * @implements IModifyDisappearingMessagesTimerAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyDisappearingMessagesTimerAction=} [properties] Properties to set
                 */
                function ModifyDisappearingMessagesTimerAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyDisappearingMessagesTimerAction timer.
                 * @member {Uint8Array} timer
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @instance
                 */
                ModifyDisappearingMessagesTimerAction.prototype.timer = $util.newBuffer([]);

                /**
                 * Encodes the specified ModifyDisappearingMessagesTimerAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyDisappearingMessagesTimerAction} message ModifyDisappearingMessagesTimerAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyDisappearingMessagesTimerAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.timer);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyDisappearingMessagesTimerAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyDisappearingMessagesTimerAction} message ModifyDisappearingMessagesTimerAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyDisappearingMessagesTimerAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyDisappearingMessagesTimerAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction} ModifyDisappearingMessagesTimerAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyDisappearingMessagesTimerAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timer = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyDisappearingMessagesTimerAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction} ModifyDisappearingMessagesTimerAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyDisappearingMessagesTimerAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyDisappearingMessagesTimerAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction} ModifyDisappearingMessagesTimerAction
                 */
                ModifyDisappearingMessagesTimerAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction();
                    if (object.timer != null)
                        if (typeof object.timer === "string")
                            $util.base64.decode(object.timer, message.timer = $util.newBuffer($util.base64.length(object.timer)), 0);
                        else if (object.timer.length)
                            message.timer = object.timer;
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyDisappearingMessagesTimerAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction} message ModifyDisappearingMessagesTimerAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyDisappearingMessagesTimerAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.timer = "";
                        else {
                            object.timer = [];
                            if (options.bytes !== Array)
                                object.timer = $util.newBuffer(object.timer);
                        }
                    if (message.timer != null && message.hasOwnProperty("timer"))
                        object.timer = options.bytes === String ? $util.base64.encode(message.timer, 0, message.timer.length) : options.bytes === Array ? Array.prototype.slice.call(message.timer) : message.timer;
                    return object;
                };

                /**
                 * Converts this ModifyDisappearingMessagesTimerAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyDisappearingMessagesTimerAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyDisappearingMessagesTimerAction;
            })();

            Actions.ModifyAttributesAccessControlAction = (function() {

                /**
                 * Properties of a ModifyAttributesAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyAttributesAccessControlAction
                 * @property {signalservice.AccessControl.AccessRequired|null} [attributesAccess] ModifyAttributesAccessControlAction attributesAccess
                 */

                /**
                 * Constructs a new ModifyAttributesAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyAttributesAccessControlAction.
                 * @implements IModifyAttributesAccessControlAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyAttributesAccessControlAction=} [properties] Properties to set
                 */
                function ModifyAttributesAccessControlAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyAttributesAccessControlAction attributesAccess.
                 * @member {signalservice.AccessControl.AccessRequired} attributesAccess
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @instance
                 */
                ModifyAttributesAccessControlAction.prototype.attributesAccess = 0;

                /**
                 * Encodes the specified ModifyAttributesAccessControlAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAttributesAccessControlAction} message ModifyAttributesAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAttributesAccessControlAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.attributesAccess != null && Object.hasOwnProperty.call(message, "attributesAccess"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attributesAccess);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyAttributesAccessControlAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAttributesAccessControlAction} message ModifyAttributesAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAttributesAccessControlAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyAttributesAccessControlAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction} ModifyAttributesAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAttributesAccessControlAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.attributesAccess = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyAttributesAccessControlAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction} ModifyAttributesAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAttributesAccessControlAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyAttributesAccessControlAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction} ModifyAttributesAccessControlAction
                 */
                ModifyAttributesAccessControlAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction();
                    switch (object.attributesAccess) {
                    case "UNKNOWN":
                    case 0:
                        message.attributesAccess = 0;
                        break;
                    case "ANY":
                    case 1:
                        message.attributesAccess = 1;
                        break;
                    case "MEMBER":
                    case 2:
                        message.attributesAccess = 2;
                        break;
                    case "ADMINISTRATOR":
                    case 3:
                        message.attributesAccess = 3;
                        break;
                    case "UNSATISFIABLE":
                    case 4:
                        message.attributesAccess = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyAttributesAccessControlAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction} message ModifyAttributesAccessControlAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyAttributesAccessControlAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.attributesAccess = options.enums === String ? "UNKNOWN" : 0;
                    if (message.attributesAccess != null && message.hasOwnProperty("attributesAccess"))
                        object.attributesAccess = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.attributesAccess] : message.attributesAccess;
                    return object;
                };

                /**
                 * Converts this ModifyAttributesAccessControlAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyAttributesAccessControlAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyAttributesAccessControlAction;
            })();

            Actions.ModifyAvatarAccessControlAction = (function() {

                /**
                 * Properties of a ModifyAvatarAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyAvatarAccessControlAction
                 * @property {signalservice.AccessControl.AccessRequired|null} [avatarAccess] ModifyAvatarAccessControlAction avatarAccess
                 */

                /**
                 * Constructs a new ModifyAvatarAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyAvatarAccessControlAction.
                 * @implements IModifyAvatarAccessControlAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAccessControlAction=} [properties] Properties to set
                 */
                function ModifyAvatarAccessControlAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyAvatarAccessControlAction avatarAccess.
                 * @member {signalservice.AccessControl.AccessRequired} avatarAccess
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @instance
                 */
                ModifyAvatarAccessControlAction.prototype.avatarAccess = 0;

                /**
                 * Encodes the specified ModifyAvatarAccessControlAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAccessControlAction} message ModifyAvatarAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAvatarAccessControlAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.avatarAccess != null && Object.hasOwnProperty.call(message, "avatarAccess"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.avatarAccess);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyAvatarAccessControlAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAvatarAccessControlAction} message ModifyAvatarAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAvatarAccessControlAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyAvatarAccessControlAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction} ModifyAvatarAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAvatarAccessControlAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.avatarAccess = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyAvatarAccessControlAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction} ModifyAvatarAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAvatarAccessControlAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyAvatarAccessControlAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction} ModifyAvatarAccessControlAction
                 */
                ModifyAvatarAccessControlAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction();
                    switch (object.avatarAccess) {
                    case "UNKNOWN":
                    case 0:
                        message.avatarAccess = 0;
                        break;
                    case "ANY":
                    case 1:
                        message.avatarAccess = 1;
                        break;
                    case "MEMBER":
                    case 2:
                        message.avatarAccess = 2;
                        break;
                    case "ADMINISTRATOR":
                    case 3:
                        message.avatarAccess = 3;
                        break;
                    case "UNSATISFIABLE":
                    case 4:
                        message.avatarAccess = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyAvatarAccessControlAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction} message ModifyAvatarAccessControlAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyAvatarAccessControlAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.avatarAccess = options.enums === String ? "UNKNOWN" : 0;
                    if (message.avatarAccess != null && message.hasOwnProperty("avatarAccess"))
                        object.avatarAccess = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.avatarAccess] : message.avatarAccess;
                    return object;
                };

                /**
                 * Converts this ModifyAvatarAccessControlAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyAvatarAccessControlAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyAvatarAccessControlAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyAvatarAccessControlAction;
            })();

            Actions.ModifyMembersAccessControlAction = (function() {

                /**
                 * Properties of a ModifyMembersAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyMembersAccessControlAction
                 * @property {signalservice.AccessControl.AccessRequired|null} [membersAccess] ModifyMembersAccessControlAction membersAccess
                 */

                /**
                 * Constructs a new ModifyMembersAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyMembersAccessControlAction.
                 * @implements IModifyMembersAccessControlAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyMembersAccessControlAction=} [properties] Properties to set
                 */
                function ModifyMembersAccessControlAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyMembersAccessControlAction membersAccess.
                 * @member {signalservice.AccessControl.AccessRequired} membersAccess
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @instance
                 */
                ModifyMembersAccessControlAction.prototype.membersAccess = 0;

                /**
                 * Encodes the specified ModifyMembersAccessControlAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMembersAccessControlAction} message ModifyMembersAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMembersAccessControlAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.membersAccess != null && Object.hasOwnProperty.call(message, "membersAccess"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.membersAccess);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyMembersAccessControlAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyMembersAccessControlAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyMembersAccessControlAction} message ModifyMembersAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyMembersAccessControlAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyMembersAccessControlAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyMembersAccessControlAction} ModifyMembersAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMembersAccessControlAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.membersAccess = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyMembersAccessControlAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyMembersAccessControlAction} ModifyMembersAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyMembersAccessControlAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyMembersAccessControlAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyMembersAccessControlAction} ModifyMembersAccessControlAction
                 */
                ModifyMembersAccessControlAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyMembersAccessControlAction();
                    switch (object.membersAccess) {
                    case "UNKNOWN":
                    case 0:
                        message.membersAccess = 0;
                        break;
                    case "ANY":
                    case 1:
                        message.membersAccess = 1;
                        break;
                    case "MEMBER":
                    case 2:
                        message.membersAccess = 2;
                        break;
                    case "ADMINISTRATOR":
                    case 3:
                        message.membersAccess = 3;
                        break;
                    case "UNSATISFIABLE":
                    case 4:
                        message.membersAccess = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyMembersAccessControlAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyMembersAccessControlAction} message ModifyMembersAccessControlAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyMembersAccessControlAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.membersAccess = options.enums === String ? "UNKNOWN" : 0;
                    if (message.membersAccess != null && message.hasOwnProperty("membersAccess"))
                        object.membersAccess = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.membersAccess] : message.membersAccess;
                    return object;
                };

                /**
                 * Converts this ModifyMembersAccessControlAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyMembersAccessControlAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyMembersAccessControlAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyMembersAccessControlAction;
            })();

            Actions.ModifyAddFromInviteLinkAccessControlAction = (function() {

                /**
                 * Properties of a ModifyAddFromInviteLinkAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyAddFromInviteLinkAccessControlAction
                 * @property {signalservice.AccessControl.AccessRequired|null} [addFromInviteLinkAccess] ModifyAddFromInviteLinkAccessControlAction addFromInviteLinkAccess
                 */

                /**
                 * Constructs a new ModifyAddFromInviteLinkAccessControlAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyAddFromInviteLinkAccessControlAction.
                 * @implements IModifyAddFromInviteLinkAccessControlAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyAddFromInviteLinkAccessControlAction=} [properties] Properties to set
                 */
                function ModifyAddFromInviteLinkAccessControlAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyAddFromInviteLinkAccessControlAction addFromInviteLinkAccess.
                 * @member {signalservice.AccessControl.AccessRequired} addFromInviteLinkAccess
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @instance
                 */
                ModifyAddFromInviteLinkAccessControlAction.prototype.addFromInviteLinkAccess = 0;

                /**
                 * Encodes the specified ModifyAddFromInviteLinkAccessControlAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAddFromInviteLinkAccessControlAction} message ModifyAddFromInviteLinkAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAddFromInviteLinkAccessControlAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.addFromInviteLinkAccess != null && Object.hasOwnProperty.call(message, "addFromInviteLinkAccess"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.addFromInviteLinkAccess);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyAddFromInviteLinkAccessControlAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAddFromInviteLinkAccessControlAction} message ModifyAddFromInviteLinkAccessControlAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAddFromInviteLinkAccessControlAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyAddFromInviteLinkAccessControlAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction} ModifyAddFromInviteLinkAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAddFromInviteLinkAccessControlAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.addFromInviteLinkAccess = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyAddFromInviteLinkAccessControlAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction} ModifyAddFromInviteLinkAccessControlAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAddFromInviteLinkAccessControlAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyAddFromInviteLinkAccessControlAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction} ModifyAddFromInviteLinkAccessControlAction
                 */
                ModifyAddFromInviteLinkAccessControlAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction();
                    switch (object.addFromInviteLinkAccess) {
                    case "UNKNOWN":
                    case 0:
                        message.addFromInviteLinkAccess = 0;
                        break;
                    case "ANY":
                    case 1:
                        message.addFromInviteLinkAccess = 1;
                        break;
                    case "MEMBER":
                    case 2:
                        message.addFromInviteLinkAccess = 2;
                        break;
                    case "ADMINISTRATOR":
                    case 3:
                        message.addFromInviteLinkAccess = 3;
                        break;
                    case "UNSATISFIABLE":
                    case 4:
                        message.addFromInviteLinkAccess = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyAddFromInviteLinkAccessControlAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction} message ModifyAddFromInviteLinkAccessControlAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyAddFromInviteLinkAccessControlAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.addFromInviteLinkAccess = options.enums === String ? "UNKNOWN" : 0;
                    if (message.addFromInviteLinkAccess != null && message.hasOwnProperty("addFromInviteLinkAccess"))
                        object.addFromInviteLinkAccess = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.addFromInviteLinkAccess] : message.addFromInviteLinkAccess;
                    return object;
                };

                /**
                 * Converts this ModifyAddFromInviteLinkAccessControlAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyAddFromInviteLinkAccessControlAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyAddFromInviteLinkAccessControlAction;
            })();

            Actions.ModifyInviteLinkPasswordAction = (function() {

                /**
                 * Properties of a ModifyInviteLinkPasswordAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyInviteLinkPasswordAction
                 * @property {Uint8Array|null} [inviteLinkPassword] ModifyInviteLinkPasswordAction inviteLinkPassword
                 */

                /**
                 * Constructs a new ModifyInviteLinkPasswordAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyInviteLinkPasswordAction.
                 * @implements IModifyInviteLinkPasswordAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyInviteLinkPasswordAction=} [properties] Properties to set
                 */
                function ModifyInviteLinkPasswordAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyInviteLinkPasswordAction inviteLinkPassword.
                 * @member {Uint8Array} inviteLinkPassword
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @instance
                 */
                ModifyInviteLinkPasswordAction.prototype.inviteLinkPassword = $util.newBuffer([]);

                /**
                 * Encodes the specified ModifyInviteLinkPasswordAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyInviteLinkPasswordAction} message ModifyInviteLinkPasswordAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyInviteLinkPasswordAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.inviteLinkPassword != null && Object.hasOwnProperty.call(message, "inviteLinkPassword"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.inviteLinkPassword);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyInviteLinkPasswordAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyInviteLinkPasswordAction} message ModifyInviteLinkPasswordAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyInviteLinkPasswordAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyInviteLinkPasswordAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction} ModifyInviteLinkPasswordAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyInviteLinkPasswordAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inviteLinkPassword = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyInviteLinkPasswordAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction} ModifyInviteLinkPasswordAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyInviteLinkPasswordAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyInviteLinkPasswordAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction} ModifyInviteLinkPasswordAction
                 */
                ModifyInviteLinkPasswordAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction();
                    if (object.inviteLinkPassword != null)
                        if (typeof object.inviteLinkPassword === "string")
                            $util.base64.decode(object.inviteLinkPassword, message.inviteLinkPassword = $util.newBuffer($util.base64.length(object.inviteLinkPassword)), 0);
                        else if (object.inviteLinkPassword.length)
                            message.inviteLinkPassword = object.inviteLinkPassword;
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyInviteLinkPasswordAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction} message ModifyInviteLinkPasswordAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyInviteLinkPasswordAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.inviteLinkPassword = "";
                        else {
                            object.inviteLinkPassword = [];
                            if (options.bytes !== Array)
                                object.inviteLinkPassword = $util.newBuffer(object.inviteLinkPassword);
                        }
                    if (message.inviteLinkPassword != null && message.hasOwnProperty("inviteLinkPassword"))
                        object.inviteLinkPassword = options.bytes === String ? $util.base64.encode(message.inviteLinkPassword, 0, message.inviteLinkPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.inviteLinkPassword) : message.inviteLinkPassword;
                    return object;
                };

                /**
                 * Converts this ModifyInviteLinkPasswordAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyInviteLinkPasswordAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyInviteLinkPasswordAction;
            })();

            Actions.ModifyDescriptionAction = (function() {

                /**
                 * Properties of a ModifyDescriptionAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyDescriptionAction
                 * @property {Uint8Array|null} [descriptionBytes] ModifyDescriptionAction descriptionBytes
                 */

                /**
                 * Constructs a new ModifyDescriptionAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyDescriptionAction.
                 * @implements IModifyDescriptionAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyDescriptionAction=} [properties] Properties to set
                 */
                function ModifyDescriptionAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyDescriptionAction descriptionBytes.
                 * @member {Uint8Array} descriptionBytes
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @instance
                 */
                ModifyDescriptionAction.prototype.descriptionBytes = $util.newBuffer([]);

                /**
                 * Encodes the specified ModifyDescriptionAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyDescriptionAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyDescriptionAction} message ModifyDescriptionAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyDescriptionAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyDescriptionAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.descriptionBytes != null && Object.hasOwnProperty.call(message, "descriptionBytes"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.descriptionBytes);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyDescriptionAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyDescriptionAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyDescriptionAction} message ModifyDescriptionAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyDescriptionAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyDescriptionAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyDescriptionAction} ModifyDescriptionAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyDescriptionAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyDescriptionAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.descriptionBytes = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyDescriptionAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyDescriptionAction} ModifyDescriptionAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyDescriptionAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyDescriptionAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyDescriptionAction} ModifyDescriptionAction
                 */
                ModifyDescriptionAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyDescriptionAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyDescriptionAction();
                    if (object.descriptionBytes != null)
                        if (typeof object.descriptionBytes === "string")
                            $util.base64.decode(object.descriptionBytes, message.descriptionBytes = $util.newBuffer($util.base64.length(object.descriptionBytes)), 0);
                        else if (object.descriptionBytes.length)
                            message.descriptionBytes = object.descriptionBytes;
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyDescriptionAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyDescriptionAction} message ModifyDescriptionAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyDescriptionAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.descriptionBytes = "";
                        else {
                            object.descriptionBytes = [];
                            if (options.bytes !== Array)
                                object.descriptionBytes = $util.newBuffer(object.descriptionBytes);
                        }
                    if (message.descriptionBytes != null && message.hasOwnProperty("descriptionBytes"))
                        object.descriptionBytes = options.bytes === String ? $util.base64.encode(message.descriptionBytes, 0, message.descriptionBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionBytes) : message.descriptionBytes;
                    return object;
                };

                /**
                 * Converts this ModifyDescriptionAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyDescriptionAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyDescriptionAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyDescriptionAction;
            })();

            Actions.ModifyAnnouncementsOnlyAction = (function() {

                /**
                 * Properties of a ModifyAnnouncementsOnlyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @interface IModifyAnnouncementsOnlyAction
                 * @property {boolean|null} [announcementsOnly] ModifyAnnouncementsOnlyAction announcementsOnly
                 */

                /**
                 * Constructs a new ModifyAnnouncementsOnlyAction.
                 * @memberof signalservice.GroupChange.Actions
                 * @classdesc Represents a ModifyAnnouncementsOnlyAction.
                 * @implements IModifyAnnouncementsOnlyAction
                 * @constructor
                 * @param {signalservice.GroupChange.Actions.IModifyAnnouncementsOnlyAction=} [properties] Properties to set
                 */
                function ModifyAnnouncementsOnlyAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ModifyAnnouncementsOnlyAction announcementsOnly.
                 * @member {boolean} announcementsOnly
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @instance
                 */
                ModifyAnnouncementsOnlyAction.prototype.announcementsOnly = false;

                /**
                 * Encodes the specified ModifyAnnouncementsOnlyAction message. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAnnouncementsOnlyAction} message ModifyAnnouncementsOnlyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAnnouncementsOnlyAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.announcementsOnly != null && Object.hasOwnProperty.call(message, "announcementsOnly"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.announcementsOnly);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ModifyAnnouncementsOnlyAction message, length delimited. Does not implicitly {@link signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.IModifyAnnouncementsOnlyAction} message ModifyAnnouncementsOnlyAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModifyAnnouncementsOnlyAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ModifyAnnouncementsOnlyAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction} ModifyAnnouncementsOnlyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAnnouncementsOnlyAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.announcementsOnly = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ModifyAnnouncementsOnlyAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction} ModifyAnnouncementsOnlyAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModifyAnnouncementsOnlyAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a ModifyAnnouncementsOnlyAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction} ModifyAnnouncementsOnlyAction
                 */
                ModifyAnnouncementsOnlyAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction)
                        return object;
                    var message = new $root.signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction();
                    if (object.announcementsOnly != null)
                        message.announcementsOnly = Boolean(object.announcementsOnly);
                    return message;
                };

                /**
                 * Creates a plain object from a ModifyAnnouncementsOnlyAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @static
                 * @param {signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction} message ModifyAnnouncementsOnlyAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModifyAnnouncementsOnlyAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.announcementsOnly = false;
                    if (message.announcementsOnly != null && message.hasOwnProperty("announcementsOnly"))
                        object.announcementsOnly = message.announcementsOnly;
                    return object;
                };

                /**
                 * Converts this ModifyAnnouncementsOnlyAction to JSON.
                 * @function toJSON
                 * @memberof signalservice.GroupChange.Actions.ModifyAnnouncementsOnlyAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModifyAnnouncementsOnlyAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ModifyAnnouncementsOnlyAction;
            })();

            return Actions;
        })();

        return GroupChange;
    })();

    signalservice.GroupChanges = (function() {

        /**
         * Properties of a GroupChanges.
         * @memberof signalservice
         * @interface IGroupChanges
         * @property {Array.<signalservice.GroupChanges.IGroupChangeState>|null} [groupChanges] GroupChanges groupChanges
         */

        /**
         * Constructs a new GroupChanges.
         * @memberof signalservice
         * @classdesc Represents a GroupChanges.
         * @implements IGroupChanges
         * @constructor
         * @param {signalservice.IGroupChanges=} [properties] Properties to set
         */
        function GroupChanges(properties) {
            this.groupChanges = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChanges groupChanges.
         * @member {Array.<signalservice.GroupChanges.IGroupChangeState>} groupChanges
         * @memberof signalservice.GroupChanges
         * @instance
         */
        GroupChanges.prototype.groupChanges = $util.emptyArray;

        /**
         * Encodes the specified GroupChanges message. Does not implicitly {@link signalservice.GroupChanges.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupChanges
         * @static
         * @param {signalservice.IGroupChanges} message GroupChanges message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChanges.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupChanges.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.groupChanges != null && message.groupChanges.length)
                for (var i = 0; i < message.groupChanges.length; ++i)
                    $root.signalservice.GroupChanges.GroupChangeState.encode(message.groupChanges[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupChanges message, length delimited. Does not implicitly {@link signalservice.GroupChanges.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupChanges
         * @static
         * @param {signalservice.IGroupChanges} message GroupChanges message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChanges.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChanges message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupChanges
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupChanges} GroupChanges
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChanges.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChanges();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.groupChanges && message.groupChanges.length))
                        message.groupChanges = [];
                    message.groupChanges.push($root.signalservice.GroupChanges.GroupChangeState.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChanges message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupChanges
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupChanges} GroupChanges
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChanges.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupChanges message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupChanges
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupChanges} GroupChanges
         */
        GroupChanges.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupChanges)
                return object;
            var message = new $root.signalservice.GroupChanges();
            if (object.groupChanges) {
                if (!Array.isArray(object.groupChanges))
                    throw TypeError(".signalservice.GroupChanges.groupChanges: array expected");
                message.groupChanges = [];
                for (var i = 0; i < object.groupChanges.length; ++i) {
                    if (typeof object.groupChanges[i] !== "object")
                        throw TypeError(".signalservice.GroupChanges.groupChanges: object expected");
                    message.groupChanges[i] = $root.signalservice.GroupChanges.GroupChangeState.fromObject(object.groupChanges[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupChanges message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupChanges
         * @static
         * @param {signalservice.GroupChanges} message GroupChanges
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChanges.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groupChanges = [];
            if (message.groupChanges && message.groupChanges.length) {
                object.groupChanges = [];
                for (var j = 0; j < message.groupChanges.length; ++j)
                    object.groupChanges[j] = $root.signalservice.GroupChanges.GroupChangeState.toObject(message.groupChanges[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupChanges to JSON.
         * @function toJSON
         * @memberof signalservice.GroupChanges
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChanges.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GroupChanges.GroupChangeState = (function() {

            /**
             * Properties of a GroupChangeState.
             * @memberof signalservice.GroupChanges
             * @interface IGroupChangeState
             * @property {signalservice.IGroupChange|null} [groupChange] GroupChangeState groupChange
             * @property {signalservice.IGroup|null} [groupState] GroupChangeState groupState
             */

            /**
             * Constructs a new GroupChangeState.
             * @memberof signalservice.GroupChanges
             * @classdesc Represents a GroupChangeState.
             * @implements IGroupChangeState
             * @constructor
             * @param {signalservice.GroupChanges.IGroupChangeState=} [properties] Properties to set
             */
            function GroupChangeState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupChangeState groupChange.
             * @member {signalservice.IGroupChange|null|undefined} groupChange
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @instance
             */
            GroupChangeState.prototype.groupChange = null;

            /**
             * GroupChangeState groupState.
             * @member {signalservice.IGroup|null|undefined} groupState
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @instance
             */
            GroupChangeState.prototype.groupState = null;

            /**
             * Encodes the specified GroupChangeState message. Does not implicitly {@link signalservice.GroupChanges.GroupChangeState.verify|verify} messages.
             * @function encode
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {signalservice.GroupChanges.IGroupChangeState} message GroupChangeState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupChangeState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.GroupChanges.GroupChangeState.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.groupChange != null && Object.hasOwnProperty.call(message, "groupChange"))
                    $root.signalservice.GroupChange.encode(message.groupChange, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.groupState != null && Object.hasOwnProperty.call(message, "groupState"))
                    $root.signalservice.Group.encode(message.groupState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified GroupChangeState message, length delimited. Does not implicitly {@link signalservice.GroupChanges.GroupChangeState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {signalservice.GroupChanges.IGroupChangeState} message GroupChangeState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupChangeState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupChangeState message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.GroupChanges.GroupChangeState} GroupChangeState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupChangeState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupChanges.GroupChangeState();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.groupChange = $root.signalservice.GroupChange.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.groupState = $root.signalservice.Group.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupChangeState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.GroupChanges.GroupChangeState} GroupChangeState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupChangeState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a GroupChangeState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.GroupChanges.GroupChangeState} GroupChangeState
             */
            GroupChangeState.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.GroupChanges.GroupChangeState)
                    return object;
                var message = new $root.signalservice.GroupChanges.GroupChangeState();
                if (object.groupChange != null) {
                    if (typeof object.groupChange !== "object")
                        throw TypeError(".signalservice.GroupChanges.GroupChangeState.groupChange: object expected");
                    message.groupChange = $root.signalservice.GroupChange.fromObject(object.groupChange);
                }
                if (object.groupState != null) {
                    if (typeof object.groupState !== "object")
                        throw TypeError(".signalservice.GroupChanges.GroupChangeState.groupState: object expected");
                    message.groupState = $root.signalservice.Group.fromObject(object.groupState);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupChangeState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @static
             * @param {signalservice.GroupChanges.GroupChangeState} message GroupChangeState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupChangeState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.groupChange = null;
                    object.groupState = null;
                }
                if (message.groupChange != null && message.hasOwnProperty("groupChange"))
                    object.groupChange = $root.signalservice.GroupChange.toObject(message.groupChange, options);
                if (message.groupState != null && message.hasOwnProperty("groupState"))
                    object.groupState = $root.signalservice.Group.toObject(message.groupState, options);
                return object;
            };

            /**
             * Converts this GroupChangeState to JSON.
             * @function toJSON
             * @memberof signalservice.GroupChanges.GroupChangeState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupChangeState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupChangeState;
        })();

        return GroupChanges;
    })();

    signalservice.GroupAttributeBlob = (function() {

        /**
         * Properties of a GroupAttributeBlob.
         * @memberof signalservice
         * @interface IGroupAttributeBlob
         * @property {string|null} [title] GroupAttributeBlob title
         * @property {Uint8Array|null} [avatar] GroupAttributeBlob avatar
         * @property {number|null} [disappearingMessagesDuration] GroupAttributeBlob disappearingMessagesDuration
         * @property {string|null} [descriptionText] GroupAttributeBlob descriptionText
         */

        /**
         * Constructs a new GroupAttributeBlob.
         * @memberof signalservice
         * @classdesc Represents a GroupAttributeBlob.
         * @implements IGroupAttributeBlob
         * @constructor
         * @param {signalservice.IGroupAttributeBlob=} [properties] Properties to set
         */
        function GroupAttributeBlob(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupAttributeBlob title.
         * @member {string|null|undefined} title
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         */
        GroupAttributeBlob.prototype.title = null;

        /**
         * GroupAttributeBlob avatar.
         * @member {Uint8Array|null|undefined} avatar
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         */
        GroupAttributeBlob.prototype.avatar = null;

        /**
         * GroupAttributeBlob disappearingMessagesDuration.
         * @member {number|null|undefined} disappearingMessagesDuration
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         */
        GroupAttributeBlob.prototype.disappearingMessagesDuration = null;

        /**
         * GroupAttributeBlob descriptionText.
         * @member {string|null|undefined} descriptionText
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         */
        GroupAttributeBlob.prototype.descriptionText = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GroupAttributeBlob content.
         * @member {"title"|"avatar"|"disappearingMessagesDuration"|"descriptionText"|undefined} content
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         */
        Object.defineProperty(GroupAttributeBlob.prototype, "content", {
            get: $util.oneOfGetter($oneOfFields = ["title", "avatar", "disappearingMessagesDuration", "descriptionText"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified GroupAttributeBlob message. Does not implicitly {@link signalservice.GroupAttributeBlob.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {signalservice.IGroupAttributeBlob} message GroupAttributeBlob message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupAttributeBlob.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupAttributeBlob.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.avatar);
            if (message.disappearingMessagesDuration != null && Object.hasOwnProperty.call(message, "disappearingMessagesDuration"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.disappearingMessagesDuration);
            if (message.descriptionText != null && Object.hasOwnProperty.call(message, "descriptionText"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.descriptionText);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupAttributeBlob message, length delimited. Does not implicitly {@link signalservice.GroupAttributeBlob.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {signalservice.IGroupAttributeBlob} message GroupAttributeBlob message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupAttributeBlob.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupAttributeBlob message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupAttributeBlob} GroupAttributeBlob
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupAttributeBlob.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupAttributeBlob();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.avatar = reader.bytes();
                    break;
                case 3:
                    message.disappearingMessagesDuration = reader.uint32();
                    break;
                case 4:
                    message.descriptionText = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupAttributeBlob message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupAttributeBlob} GroupAttributeBlob
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupAttributeBlob.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupAttributeBlob message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupAttributeBlob} GroupAttributeBlob
         */
        GroupAttributeBlob.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupAttributeBlob)
                return object;
            var message = new $root.signalservice.GroupAttributeBlob();
            if (object.title != null)
                message.title = String(object.title);
            if (object.avatar != null)
                if (typeof object.avatar === "string")
                    $util.base64.decode(object.avatar, message.avatar = $util.newBuffer($util.base64.length(object.avatar)), 0);
                else if (object.avatar.length)
                    message.avatar = object.avatar;
            if (object.disappearingMessagesDuration != null)
                message.disappearingMessagesDuration = object.disappearingMessagesDuration >>> 0;
            if (object.descriptionText != null)
                message.descriptionText = String(object.descriptionText);
            return message;
        };

        /**
         * Creates a plain object from a GroupAttributeBlob message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupAttributeBlob
         * @static
         * @param {signalservice.GroupAttributeBlob} message GroupAttributeBlob
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupAttributeBlob.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.title != null && message.hasOwnProperty("title")) {
                object.title = message.title;
                if (options.oneofs)
                    object.content = "title";
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                object.avatar = options.bytes === String ? $util.base64.encode(message.avatar, 0, message.avatar.length) : options.bytes === Array ? Array.prototype.slice.call(message.avatar) : message.avatar;
                if (options.oneofs)
                    object.content = "avatar";
            }
            if (message.disappearingMessagesDuration != null && message.hasOwnProperty("disappearingMessagesDuration")) {
                object.disappearingMessagesDuration = message.disappearingMessagesDuration;
                if (options.oneofs)
                    object.content = "disappearingMessagesDuration";
            }
            if (message.descriptionText != null && message.hasOwnProperty("descriptionText")) {
                object.descriptionText = message.descriptionText;
                if (options.oneofs)
                    object.content = "descriptionText";
            }
            return object;
        };

        /**
         * Converts this GroupAttributeBlob to JSON.
         * @function toJSON
         * @memberof signalservice.GroupAttributeBlob
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupAttributeBlob.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupAttributeBlob;
    })();

    signalservice.GroupExternalCredential = (function() {

        /**
         * Properties of a GroupExternalCredential.
         * @memberof signalservice
         * @interface IGroupExternalCredential
         * @property {string|null} [token] GroupExternalCredential token
         */

        /**
         * Constructs a new GroupExternalCredential.
         * @memberof signalservice
         * @classdesc Represents a GroupExternalCredential.
         * @implements IGroupExternalCredential
         * @constructor
         * @param {signalservice.IGroupExternalCredential=} [properties] Properties to set
         */
        function GroupExternalCredential(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupExternalCredential token.
         * @member {string} token
         * @memberof signalservice.GroupExternalCredential
         * @instance
         */
        GroupExternalCredential.prototype.token = "";

        /**
         * Encodes the specified GroupExternalCredential message. Does not implicitly {@link signalservice.GroupExternalCredential.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {signalservice.IGroupExternalCredential} message GroupExternalCredential message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupExternalCredential.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupExternalCredential.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupExternalCredential message, length delimited. Does not implicitly {@link signalservice.GroupExternalCredential.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {signalservice.IGroupExternalCredential} message GroupExternalCredential message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupExternalCredential.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupExternalCredential message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupExternalCredential} GroupExternalCredential
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupExternalCredential.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupExternalCredential();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupExternalCredential message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupExternalCredential} GroupExternalCredential
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupExternalCredential.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupExternalCredential message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupExternalCredential} GroupExternalCredential
         */
        GroupExternalCredential.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupExternalCredential)
                return object;
            var message = new $root.signalservice.GroupExternalCredential();
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };

        /**
         * Creates a plain object from a GroupExternalCredential message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupExternalCredential
         * @static
         * @param {signalservice.GroupExternalCredential} message GroupExternalCredential
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupExternalCredential.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.token = "";
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };

        /**
         * Converts this GroupExternalCredential to JSON.
         * @function toJSON
         * @memberof signalservice.GroupExternalCredential
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupExternalCredential.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupExternalCredential;
    })();

    signalservice.GroupInviteLink = (function() {

        /**
         * Properties of a GroupInviteLink.
         * @memberof signalservice
         * @interface IGroupInviteLink
         * @property {signalservice.GroupInviteLink.IGroupInviteLinkContentsV1|null} [v1Contents] GroupInviteLink v1Contents
         */

        /**
         * Constructs a new GroupInviteLink.
         * @memberof signalservice
         * @classdesc Represents a GroupInviteLink.
         * @implements IGroupInviteLink
         * @constructor
         * @param {signalservice.IGroupInviteLink=} [properties] Properties to set
         */
        function GroupInviteLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInviteLink v1Contents.
         * @member {signalservice.GroupInviteLink.IGroupInviteLinkContentsV1|null|undefined} v1Contents
         * @memberof signalservice.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.v1Contents = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GroupInviteLink contents.
         * @member {"v1Contents"|undefined} contents
         * @memberof signalservice.GroupInviteLink
         * @instance
         */
        Object.defineProperty(GroupInviteLink.prototype, "contents", {
            get: $util.oneOfGetter($oneOfFields = ["v1Contents"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified GroupInviteLink message. Does not implicitly {@link signalservice.GroupInviteLink.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {signalservice.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupInviteLink.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.v1Contents != null && Object.hasOwnProperty.call(message, "v1Contents"))
                $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1.encode(message.v1Contents, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupInviteLink message, length delimited. Does not implicitly {@link signalservice.GroupInviteLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {signalservice.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupInviteLink();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.v1Contents = $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupInviteLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupInviteLink} GroupInviteLink
         */
        GroupInviteLink.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupInviteLink)
                return object;
            var message = new $root.signalservice.GroupInviteLink();
            if (object.v1Contents != null) {
                if (typeof object.v1Contents !== "object")
                    throw TypeError(".signalservice.GroupInviteLink.v1Contents: object expected");
                message.v1Contents = $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1.fromObject(object.v1Contents);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInviteLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupInviteLink
         * @static
         * @param {signalservice.GroupInviteLink} message GroupInviteLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInviteLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.v1Contents != null && message.hasOwnProperty("v1Contents")) {
                object.v1Contents = $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1.toObject(message.v1Contents, options);
                if (options.oneofs)
                    object.contents = "v1Contents";
            }
            return object;
        };

        /**
         * Converts this GroupInviteLink to JSON.
         * @function toJSON
         * @memberof signalservice.GroupInviteLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInviteLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GroupInviteLink.GroupInviteLinkContentsV1 = (function() {

            /**
             * Properties of a GroupInviteLinkContentsV1.
             * @memberof signalservice.GroupInviteLink
             * @interface IGroupInviteLinkContentsV1
             * @property {Uint8Array|null} [groupMasterKey] GroupInviteLinkContentsV1 groupMasterKey
             * @property {Uint8Array|null} [inviteLinkPassword] GroupInviteLinkContentsV1 inviteLinkPassword
             */

            /**
             * Constructs a new GroupInviteLinkContentsV1.
             * @memberof signalservice.GroupInviteLink
             * @classdesc Represents a GroupInviteLinkContentsV1.
             * @implements IGroupInviteLinkContentsV1
             * @constructor
             * @param {signalservice.GroupInviteLink.IGroupInviteLinkContentsV1=} [properties] Properties to set
             */
            function GroupInviteLinkContentsV1(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInviteLinkContentsV1 groupMasterKey.
             * @member {Uint8Array} groupMasterKey
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @instance
             */
            GroupInviteLinkContentsV1.prototype.groupMasterKey = $util.newBuffer([]);

            /**
             * GroupInviteLinkContentsV1 inviteLinkPassword.
             * @member {Uint8Array} inviteLinkPassword
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @instance
             */
            GroupInviteLinkContentsV1.prototype.inviteLinkPassword = $util.newBuffer([]);

            /**
             * Encodes the specified GroupInviteLinkContentsV1 message. Does not implicitly {@link signalservice.GroupInviteLink.GroupInviteLinkContentsV1.verify|verify} messages.
             * @function encode
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {signalservice.GroupInviteLink.IGroupInviteLinkContentsV1} message GroupInviteLinkContentsV1 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInviteLinkContentsV1.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.groupMasterKey != null && Object.hasOwnProperty.call(message, "groupMasterKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.groupMasterKey);
                if (message.inviteLinkPassword != null && Object.hasOwnProperty.call(message, "inviteLinkPassword"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.inviteLinkPassword);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified GroupInviteLinkContentsV1 message, length delimited. Does not implicitly {@link signalservice.GroupInviteLink.GroupInviteLinkContentsV1.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {signalservice.GroupInviteLink.IGroupInviteLinkContentsV1} message GroupInviteLinkContentsV1 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInviteLinkContentsV1.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInviteLinkContentsV1 message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.GroupInviteLink.GroupInviteLinkContentsV1} GroupInviteLinkContentsV1
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInviteLinkContentsV1.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.groupMasterKey = reader.bytes();
                        break;
                    case 2:
                        message.inviteLinkPassword = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInviteLinkContentsV1 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.GroupInviteLink.GroupInviteLinkContentsV1} GroupInviteLinkContentsV1
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInviteLinkContentsV1.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a GroupInviteLinkContentsV1 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.GroupInviteLink.GroupInviteLinkContentsV1} GroupInviteLinkContentsV1
             */
            GroupInviteLinkContentsV1.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1)
                    return object;
                var message = new $root.signalservice.GroupInviteLink.GroupInviteLinkContentsV1();
                if (object.groupMasterKey != null)
                    if (typeof object.groupMasterKey === "string")
                        $util.base64.decode(object.groupMasterKey, message.groupMasterKey = $util.newBuffer($util.base64.length(object.groupMasterKey)), 0);
                    else if (object.groupMasterKey.length)
                        message.groupMasterKey = object.groupMasterKey;
                if (object.inviteLinkPassword != null)
                    if (typeof object.inviteLinkPassword === "string")
                        $util.base64.decode(object.inviteLinkPassword, message.inviteLinkPassword = $util.newBuffer($util.base64.length(object.inviteLinkPassword)), 0);
                    else if (object.inviteLinkPassword.length)
                        message.inviteLinkPassword = object.inviteLinkPassword;
                return message;
            };

            /**
             * Creates a plain object from a GroupInviteLinkContentsV1 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @static
             * @param {signalservice.GroupInviteLink.GroupInviteLinkContentsV1} message GroupInviteLinkContentsV1
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInviteLinkContentsV1.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.groupMasterKey = "";
                    else {
                        object.groupMasterKey = [];
                        if (options.bytes !== Array)
                            object.groupMasterKey = $util.newBuffer(object.groupMasterKey);
                    }
                    if (options.bytes === String)
                        object.inviteLinkPassword = "";
                    else {
                        object.inviteLinkPassword = [];
                        if (options.bytes !== Array)
                            object.inviteLinkPassword = $util.newBuffer(object.inviteLinkPassword);
                    }
                }
                if (message.groupMasterKey != null && message.hasOwnProperty("groupMasterKey"))
                    object.groupMasterKey = options.bytes === String ? $util.base64.encode(message.groupMasterKey, 0, message.groupMasterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupMasterKey) : message.groupMasterKey;
                if (message.inviteLinkPassword != null && message.hasOwnProperty("inviteLinkPassword"))
                    object.inviteLinkPassword = options.bytes === String ? $util.base64.encode(message.inviteLinkPassword, 0, message.inviteLinkPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.inviteLinkPassword) : message.inviteLinkPassword;
                return object;
            };

            /**
             * Converts this GroupInviteLinkContentsV1 to JSON.
             * @function toJSON
             * @memberof signalservice.GroupInviteLink.GroupInviteLinkContentsV1
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInviteLinkContentsV1.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupInviteLinkContentsV1;
        })();

        return GroupInviteLink;
    })();

    signalservice.GroupJoinInfo = (function() {

        /**
         * Properties of a GroupJoinInfo.
         * @memberof signalservice
         * @interface IGroupJoinInfo
         * @property {Uint8Array|null} [publicKey] GroupJoinInfo publicKey
         * @property {Uint8Array|null} [title] GroupJoinInfo title
         * @property {string|null} [avatar] GroupJoinInfo avatar
         * @property {number|null} [memberCount] GroupJoinInfo memberCount
         * @property {signalservice.AccessControl.AccessRequired|null} [addFromInviteLink] GroupJoinInfo addFromInviteLink
         * @property {number|null} [version] GroupJoinInfo version
         * @property {boolean|null} [pendingAdminApproval] GroupJoinInfo pendingAdminApproval
         * @property {Uint8Array|null} [descriptionBytes] GroupJoinInfo descriptionBytes
         */

        /**
         * Constructs a new GroupJoinInfo.
         * @memberof signalservice
         * @classdesc Represents a GroupJoinInfo.
         * @implements IGroupJoinInfo
         * @constructor
         * @param {signalservice.IGroupJoinInfo=} [properties] Properties to set
         */
        function GroupJoinInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupJoinInfo publicKey.
         * @member {Uint8Array} publicKey
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.publicKey = $util.newBuffer([]);

        /**
         * GroupJoinInfo title.
         * @member {Uint8Array} title
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.title = $util.newBuffer([]);

        /**
         * GroupJoinInfo avatar.
         * @member {string} avatar
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.avatar = "";

        /**
         * GroupJoinInfo memberCount.
         * @member {number} memberCount
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.memberCount = 0;

        /**
         * GroupJoinInfo addFromInviteLink.
         * @member {signalservice.AccessControl.AccessRequired} addFromInviteLink
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.addFromInviteLink = 0;

        /**
         * GroupJoinInfo version.
         * @member {number} version
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.version = 0;

        /**
         * GroupJoinInfo pendingAdminApproval.
         * @member {boolean} pendingAdminApproval
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.pendingAdminApproval = false;

        /**
         * GroupJoinInfo descriptionBytes.
         * @member {Uint8Array} descriptionBytes
         * @memberof signalservice.GroupJoinInfo
         * @instance
         */
        GroupJoinInfo.prototype.descriptionBytes = $util.newBuffer([]);

        /**
         * Encodes the specified GroupJoinInfo message. Does not implicitly {@link signalservice.GroupJoinInfo.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {signalservice.IGroupJoinInfo} message GroupJoinInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupJoinInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupJoinInfo.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.title);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar);
            if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.memberCount);
            if (message.addFromInviteLink != null && Object.hasOwnProperty.call(message, "addFromInviteLink"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.addFromInviteLink);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.version);
            if (message.pendingAdminApproval != null && Object.hasOwnProperty.call(message, "pendingAdminApproval"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.pendingAdminApproval);
            if (message.descriptionBytes != null && Object.hasOwnProperty.call(message, "descriptionBytes"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.descriptionBytes);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupJoinInfo message, length delimited. Does not implicitly {@link signalservice.GroupJoinInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {signalservice.IGroupJoinInfo} message GroupJoinInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupJoinInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupJoinInfo message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupJoinInfo} GroupJoinInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupJoinInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupJoinInfo();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.title = reader.bytes();
                    break;
                case 3:
                    message.avatar = reader.string();
                    break;
                case 4:
                    message.memberCount = reader.uint32();
                    break;
                case 5:
                    message.addFromInviteLink = reader.int32();
                    break;
                case 6:
                    message.version = reader.uint32();
                    break;
                case 7:
                    message.pendingAdminApproval = reader.bool();
                    break;
                case 8:
                    message.descriptionBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupJoinInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupJoinInfo} GroupJoinInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupJoinInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupJoinInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupJoinInfo} GroupJoinInfo
         */
        GroupJoinInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupJoinInfo)
                return object;
            var message = new $root.signalservice.GroupJoinInfo();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.title != null)
                if (typeof object.title === "string")
                    $util.base64.decode(object.title, message.title = $util.newBuffer($util.base64.length(object.title)), 0);
                else if (object.title.length)
                    message.title = object.title;
            if (object.avatar != null)
                message.avatar = String(object.avatar);
            if (object.memberCount != null)
                message.memberCount = object.memberCount >>> 0;
            switch (object.addFromInviteLink) {
            case "UNKNOWN":
            case 0:
                message.addFromInviteLink = 0;
                break;
            case "ANY":
            case 1:
                message.addFromInviteLink = 1;
                break;
            case "MEMBER":
            case 2:
                message.addFromInviteLink = 2;
                break;
            case "ADMINISTRATOR":
            case 3:
                message.addFromInviteLink = 3;
                break;
            case "UNSATISFIABLE":
            case 4:
                message.addFromInviteLink = 4;
                break;
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.pendingAdminApproval != null)
                message.pendingAdminApproval = Boolean(object.pendingAdminApproval);
            if (object.descriptionBytes != null)
                if (typeof object.descriptionBytes === "string")
                    $util.base64.decode(object.descriptionBytes, message.descriptionBytes = $util.newBuffer($util.base64.length(object.descriptionBytes)), 0);
                else if (object.descriptionBytes.length)
                    message.descriptionBytes = object.descriptionBytes;
            return message;
        };

        /**
         * Creates a plain object from a GroupJoinInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupJoinInfo
         * @static
         * @param {signalservice.GroupJoinInfo} message GroupJoinInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupJoinInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.title = "";
                else {
                    object.title = [];
                    if (options.bytes !== Array)
                        object.title = $util.newBuffer(object.title);
                }
                object.avatar = "";
                object.memberCount = 0;
                object.addFromInviteLink = options.enums === String ? "UNKNOWN" : 0;
                object.version = 0;
                object.pendingAdminApproval = false;
                if (options.bytes === String)
                    object.descriptionBytes = "";
                else {
                    object.descriptionBytes = [];
                    if (options.bytes !== Array)
                        object.descriptionBytes = $util.newBuffer(object.descriptionBytes);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = options.bytes === String ? $util.base64.encode(message.title, 0, message.title.length) : options.bytes === Array ? Array.prototype.slice.call(message.title) : message.title;
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = message.avatar;
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                object.memberCount = message.memberCount;
            if (message.addFromInviteLink != null && message.hasOwnProperty("addFromInviteLink"))
                object.addFromInviteLink = options.enums === String ? $root.signalservice.AccessControl.AccessRequired[message.addFromInviteLink] : message.addFromInviteLink;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.pendingAdminApproval != null && message.hasOwnProperty("pendingAdminApproval"))
                object.pendingAdminApproval = message.pendingAdminApproval;
            if (message.descriptionBytes != null && message.hasOwnProperty("descriptionBytes"))
                object.descriptionBytes = options.bytes === String ? $util.base64.encode(message.descriptionBytes, 0, message.descriptionBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionBytes) : message.descriptionBytes;
            return object;
        };

        /**
         * Converts this GroupJoinInfo to JSON.
         * @function toJSON
         * @memberof signalservice.GroupJoinInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupJoinInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupJoinInfo;
    })();

    signalservice.Envelope = (function() {

        /**
         * Properties of an Envelope.
         * @memberof signalservice
         * @interface IEnvelope
         * @property {signalservice.Envelope.Type|null} [type] Envelope type
         * @property {string|null} [sourceUuid] Envelope sourceUuid
         * @property {number|null} [sourceDevice] Envelope sourceDevice
         * @property {string|null} [destinationUuid] Envelope destinationUuid
         * @property {Long|null} [timestamp] Envelope timestamp
         * @property {Uint8Array|null} [content] Envelope content
         * @property {string|null} [serverGuid] Envelope serverGuid
         * @property {Long|null} [serverTimestamp] Envelope serverTimestamp
         * @property {boolean|null} [ephemeral] Envelope ephemeral
         * @property {boolean|null} [urgent] Envelope urgent
         * @property {string|null} [updatedPni] Envelope updatedPni
         */

        /**
         * Constructs a new Envelope.
         * @memberof signalservice
         * @classdesc Represents an Envelope.
         * @implements IEnvelope
         * @constructor
         * @param {signalservice.IEnvelope=} [properties] Properties to set
         */
        function Envelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Envelope type.
         * @member {signalservice.Envelope.Type} type
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.type = 0;

        /**
         * Envelope sourceUuid.
         * @member {string} sourceUuid
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.sourceUuid = "";

        /**
         * Envelope sourceDevice.
         * @member {number} sourceDevice
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.sourceDevice = 0;

        /**
         * Envelope destinationUuid.
         * @member {string} destinationUuid
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.destinationUuid = "";

        /**
         * Envelope timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Envelope content.
         * @member {Uint8Array} content
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.content = $util.newBuffer([]);

        /**
         * Envelope serverGuid.
         * @member {string} serverGuid
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.serverGuid = "";

        /**
         * Envelope serverTimestamp.
         * @member {Long} serverTimestamp
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.serverTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Envelope ephemeral.
         * @member {boolean} ephemeral
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.ephemeral = false;

        /**
         * Envelope urgent.
         * @member {boolean} urgent
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.urgent = true;

        /**
         * Envelope updatedPni.
         * @member {string} updatedPni
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.updatedPni = "";

        /**
         * Encodes the specified Envelope message. Does not implicitly {@link signalservice.Envelope.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.Envelope.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timestamp);
            if (message.sourceDevice != null && Object.hasOwnProperty.call(message, "sourceDevice"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.sourceDevice);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.content);
            if (message.serverGuid != null && Object.hasOwnProperty.call(message, "serverGuid"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.serverGuid);
            if (message.serverTimestamp != null && Object.hasOwnProperty.call(message, "serverTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.serverTimestamp);
            if (message.sourceUuid != null && Object.hasOwnProperty.call(message, "sourceUuid"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.sourceUuid);
            if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.ephemeral);
            if (message.destinationUuid != null && Object.hasOwnProperty.call(message, "destinationUuid"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.destinationUuid);
            if (message.urgent != null && Object.hasOwnProperty.call(message, "urgent"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.urgent);
            if (message.updatedPni != null && Object.hasOwnProperty.call(message, "updatedPni"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.updatedPni);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified Envelope message, length delimited. Does not implicitly {@link signalservice.Envelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Envelope();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 11:
                    message.sourceUuid = reader.string();
                    break;
                case 7:
                    message.sourceDevice = reader.uint32();
                    break;
                case 13:
                    message.destinationUuid = reader.string();
                    break;
                case 5:
                    message.timestamp = reader.uint64();
                    break;
                case 8:
                    message.content = reader.bytes();
                    break;
                case 9:
                    message.serverGuid = reader.string();
                    break;
                case 10:
                    message.serverTimestamp = reader.uint64();
                    break;
                case 12:
                    message.ephemeral = reader.bool();
                    break;
                case 14:
                    message.urgent = reader.bool();
                    break;
                case 15:
                    message.updatedPni = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Envelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Envelope} Envelope
         */
        Envelope.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Envelope)
                return object;
            var message = new $root.signalservice.Envelope();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "CIPHERTEXT":
            case 1:
                message.type = 1;
                break;
            case "KEY_EXCHANGE":
            case 2:
                message.type = 2;
                break;
            case "PREKEY_BUNDLE":
            case 3:
                message.type = 3;
                break;
            case "RECEIPT":
            case 5:
                message.type = 5;
                break;
            case "UNIDENTIFIED_SENDER":
            case 6:
                message.type = 6;
                break;
            case "PLAINTEXT_CONTENT":
            case 8:
                message.type = 8;
                break;
            }
            if (object.sourceUuid != null)
                message.sourceUuid = String(object.sourceUuid);
            if (object.sourceDevice != null)
                message.sourceDevice = object.sourceDevice >>> 0;
            if (object.destinationUuid != null)
                message.destinationUuid = String(object.destinationUuid);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            if (object.serverGuid != null)
                message.serverGuid = String(object.serverGuid);
            if (object.serverTimestamp != null)
                if ($util.Long)
                    (message.serverTimestamp = $util.Long.fromValue(object.serverTimestamp)).unsigned = true;
                else if (typeof object.serverTimestamp === "string")
                    message.serverTimestamp = parseInt(object.serverTimestamp, 10);
                else if (typeof object.serverTimestamp === "number")
                    message.serverTimestamp = object.serverTimestamp;
                else if (typeof object.serverTimestamp === "object")
                    message.serverTimestamp = new $util.LongBits(object.serverTimestamp.low >>> 0, object.serverTimestamp.high >>> 0).toNumber(true);
            if (object.ephemeral != null)
                message.ephemeral = Boolean(object.ephemeral);
            if (object.urgent != null)
                message.urgent = Boolean(object.urgent);
            if (object.updatedPni != null)
                message.updatedPni = String(object.updatedPni);
            return message;
        };

        /**
         * Creates a plain object from an Envelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.Envelope} message Envelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Envelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.sourceDevice = 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
                object.serverGuid = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.serverTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestamp = options.longs === String ? "0" : 0;
                object.sourceUuid = "";
                object.ephemeral = false;
                object.destinationUuid = "";
                object.urgent = true;
                object.updatedPni = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.Envelope.Type[message.type] : message.type;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.sourceDevice != null && message.hasOwnProperty("sourceDevice"))
                object.sourceDevice = message.sourceDevice;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            if (message.serverGuid != null && message.hasOwnProperty("serverGuid"))
                object.serverGuid = message.serverGuid;
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (typeof message.serverTimestamp === "number")
                    object.serverTimestamp = options.longs === String ? String(message.serverTimestamp) : message.serverTimestamp;
                else
                    object.serverTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestamp) : options.longs === Number ? new $util.LongBits(message.serverTimestamp.low >>> 0, message.serverTimestamp.high >>> 0).toNumber(true) : message.serverTimestamp;
            if (message.sourceUuid != null && message.hasOwnProperty("sourceUuid"))
                object.sourceUuid = message.sourceUuid;
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                object.ephemeral = message.ephemeral;
            if (message.destinationUuid != null && message.hasOwnProperty("destinationUuid"))
                object.destinationUuid = message.destinationUuid;
            if (message.urgent != null && message.hasOwnProperty("urgent"))
                object.urgent = message.urgent;
            if (message.updatedPni != null && message.hasOwnProperty("updatedPni"))
                object.updatedPni = message.updatedPni;
            return object;
        };

        /**
         * Converts this Envelope to JSON.
         * @function toJSON
         * @memberof signalservice.Envelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Envelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name signalservice.Envelope.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CIPHERTEXT=1 CIPHERTEXT value
         * @property {number} KEY_EXCHANGE=2 KEY_EXCHANGE value
         * @property {number} PREKEY_BUNDLE=3 PREKEY_BUNDLE value
         * @property {number} RECEIPT=5 RECEIPT value
         * @property {number} UNIDENTIFIED_SENDER=6 UNIDENTIFIED_SENDER value
         * @property {number} PLAINTEXT_CONTENT=8 PLAINTEXT_CONTENT value
         */
        Envelope.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CIPHERTEXT"] = 1;
            values[valuesById[2] = "KEY_EXCHANGE"] = 2;
            values[valuesById[3] = "PREKEY_BUNDLE"] = 3;
            values[valuesById[5] = "RECEIPT"] = 5;
            values[valuesById[6] = "UNIDENTIFIED_SENDER"] = 6;
            values[valuesById[8] = "PLAINTEXT_CONTENT"] = 8;
            return values;
        })();

        return Envelope;
    })();

    signalservice.Content = (function() {

        /**
         * Properties of a Content.
         * @memberof signalservice
         * @interface IContent
         * @property {signalservice.IDataMessage|null} [dataMessage] Content dataMessage
         * @property {signalservice.ISyncMessage|null} [syncMessage] Content syncMessage
         * @property {signalservice.ICallingMessage|null} [callingMessage] Content callingMessage
         * @property {signalservice.INullMessage|null} [nullMessage] Content nullMessage
         * @property {signalservice.IReceiptMessage|null} [receiptMessage] Content receiptMessage
         * @property {signalservice.ITypingMessage|null} [typingMessage] Content typingMessage
         * @property {Uint8Array|null} [senderKeyDistributionMessage] Content senderKeyDistributionMessage
         * @property {Uint8Array|null} [decryptionErrorMessage] Content decryptionErrorMessage
         * @property {signalservice.IStoryMessage|null} [storyMessage] Content storyMessage
         * @property {signalservice.IPniSignatureMessage|null} [pniSignatureMessage] Content pniSignatureMessage
         */

        /**
         * Constructs a new Content.
         * @memberof signalservice
         * @classdesc Represents a Content.
         * @implements IContent
         * @constructor
         * @param {signalservice.IContent=} [properties] Properties to set
         */
        function Content(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Content dataMessage.
         * @member {signalservice.IDataMessage|null|undefined} dataMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.dataMessage = null;

        /**
         * Content syncMessage.
         * @member {signalservice.ISyncMessage|null|undefined} syncMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.syncMessage = null;

        /**
         * Content callingMessage.
         * @member {signalservice.ICallingMessage|null|undefined} callingMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.callingMessage = null;

        /**
         * Content nullMessage.
         * @member {signalservice.INullMessage|null|undefined} nullMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.nullMessage = null;

        /**
         * Content receiptMessage.
         * @member {signalservice.IReceiptMessage|null|undefined} receiptMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.receiptMessage = null;

        /**
         * Content typingMessage.
         * @member {signalservice.ITypingMessage|null|undefined} typingMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.typingMessage = null;

        /**
         * Content senderKeyDistributionMessage.
         * @member {Uint8Array} senderKeyDistributionMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.senderKeyDistributionMessage = $util.newBuffer([]);

        /**
         * Content decryptionErrorMessage.
         * @member {Uint8Array} decryptionErrorMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.decryptionErrorMessage = $util.newBuffer([]);

        /**
         * Content storyMessage.
         * @member {signalservice.IStoryMessage|null|undefined} storyMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.storyMessage = null;

        /**
         * Content pniSignatureMessage.
         * @member {signalservice.IPniSignatureMessage|null|undefined} pniSignatureMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.pniSignatureMessage = null;

        /**
         * Encodes the specified Content message. Does not implicitly {@link signalservice.Content.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.Content.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.dataMessage != null && Object.hasOwnProperty.call(message, "dataMessage"))
                $root.signalservice.DataMessage.encode(message.dataMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.syncMessage != null && Object.hasOwnProperty.call(message, "syncMessage"))
                $root.signalservice.SyncMessage.encode(message.syncMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callingMessage != null && Object.hasOwnProperty.call(message, "callingMessage"))
                $root.signalservice.CallingMessage.encode(message.callingMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.nullMessage != null && Object.hasOwnProperty.call(message, "nullMessage"))
                $root.signalservice.NullMessage.encode(message.nullMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.receiptMessage != null && Object.hasOwnProperty.call(message, "receiptMessage"))
                $root.signalservice.ReceiptMessage.encode(message.receiptMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.typingMessage != null && Object.hasOwnProperty.call(message, "typingMessage"))
                $root.signalservice.TypingMessage.encode(message.typingMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "senderKeyDistributionMessage"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.senderKeyDistributionMessage);
            if (message.decryptionErrorMessage != null && Object.hasOwnProperty.call(message, "decryptionErrorMessage"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.decryptionErrorMessage);
            if (message.storyMessage != null && Object.hasOwnProperty.call(message, "storyMessage"))
                $root.signalservice.StoryMessage.encode(message.storyMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.pniSignatureMessage != null && Object.hasOwnProperty.call(message, "pniSignatureMessage"))
                $root.signalservice.PniSignatureMessage.encode(message.pniSignatureMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified Content message, length delimited. Does not implicitly {@link signalservice.Content.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Content message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Content();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dataMessage = $root.signalservice.DataMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.syncMessage = $root.signalservice.SyncMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callingMessage = $root.signalservice.CallingMessage.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.nullMessage = $root.signalservice.NullMessage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.receiptMessage = $root.signalservice.ReceiptMessage.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.typingMessage = $root.signalservice.TypingMessage.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.senderKeyDistributionMessage = reader.bytes();
                    break;
                case 8:
                    message.decryptionErrorMessage = reader.bytes();
                    break;
                case 9:
                    message.storyMessage = $root.signalservice.StoryMessage.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.pniSignatureMessage = $root.signalservice.PniSignatureMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Content message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a Content message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Content
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Content} Content
         */
        Content.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Content)
                return object;
            var message = new $root.signalservice.Content();
            if (object.dataMessage != null) {
                if (typeof object.dataMessage !== "object")
                    throw TypeError(".signalservice.Content.dataMessage: object expected");
                message.dataMessage = $root.signalservice.DataMessage.fromObject(object.dataMessage);
            }
            if (object.syncMessage != null) {
                if (typeof object.syncMessage !== "object")
                    throw TypeError(".signalservice.Content.syncMessage: object expected");
                message.syncMessage = $root.signalservice.SyncMessage.fromObject(object.syncMessage);
            }
            if (object.callingMessage != null) {
                if (typeof object.callingMessage !== "object")
                    throw TypeError(".signalservice.Content.callingMessage: object expected");
                message.callingMessage = $root.signalservice.CallingMessage.fromObject(object.callingMessage);
            }
            if (object.nullMessage != null) {
                if (typeof object.nullMessage !== "object")
                    throw TypeError(".signalservice.Content.nullMessage: object expected");
                message.nullMessage = $root.signalservice.NullMessage.fromObject(object.nullMessage);
            }
            if (object.receiptMessage != null) {
                if (typeof object.receiptMessage !== "object")
                    throw TypeError(".signalservice.Content.receiptMessage: object expected");
                message.receiptMessage = $root.signalservice.ReceiptMessage.fromObject(object.receiptMessage);
            }
            if (object.typingMessage != null) {
                if (typeof object.typingMessage !== "object")
                    throw TypeError(".signalservice.Content.typingMessage: object expected");
                message.typingMessage = $root.signalservice.TypingMessage.fromObject(object.typingMessage);
            }
            if (object.senderKeyDistributionMessage != null)
                if (typeof object.senderKeyDistributionMessage === "string")
                    $util.base64.decode(object.senderKeyDistributionMessage, message.senderKeyDistributionMessage = $util.newBuffer($util.base64.length(object.senderKeyDistributionMessage)), 0);
                else if (object.senderKeyDistributionMessage.length)
                    message.senderKeyDistributionMessage = object.senderKeyDistributionMessage;
            if (object.decryptionErrorMessage != null)
                if (typeof object.decryptionErrorMessage === "string")
                    $util.base64.decode(object.decryptionErrorMessage, message.decryptionErrorMessage = $util.newBuffer($util.base64.length(object.decryptionErrorMessage)), 0);
                else if (object.decryptionErrorMessage.length)
                    message.decryptionErrorMessage = object.decryptionErrorMessage;
            if (object.storyMessage != null) {
                if (typeof object.storyMessage !== "object")
                    throw TypeError(".signalservice.Content.storyMessage: object expected");
                message.storyMessage = $root.signalservice.StoryMessage.fromObject(object.storyMessage);
            }
            if (object.pniSignatureMessage != null) {
                if (typeof object.pniSignatureMessage !== "object")
                    throw TypeError(".signalservice.Content.pniSignatureMessage: object expected");
                message.pniSignatureMessage = $root.signalservice.PniSignatureMessage.fromObject(object.pniSignatureMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a Content message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.Content} message Content
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Content.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dataMessage = null;
                object.syncMessage = null;
                object.callingMessage = null;
                object.nullMessage = null;
                object.receiptMessage = null;
                object.typingMessage = null;
                if (options.bytes === String)
                    object.senderKeyDistributionMessage = "";
                else {
                    object.senderKeyDistributionMessage = [];
                    if (options.bytes !== Array)
                        object.senderKeyDistributionMessage = $util.newBuffer(object.senderKeyDistributionMessage);
                }
                if (options.bytes === String)
                    object.decryptionErrorMessage = "";
                else {
                    object.decryptionErrorMessage = [];
                    if (options.bytes !== Array)
                        object.decryptionErrorMessage = $util.newBuffer(object.decryptionErrorMessage);
                }
                object.storyMessage = null;
                object.pniSignatureMessage = null;
            }
            if (message.dataMessage != null && message.hasOwnProperty("dataMessage"))
                object.dataMessage = $root.signalservice.DataMessage.toObject(message.dataMessage, options);
            if (message.syncMessage != null && message.hasOwnProperty("syncMessage"))
                object.syncMessage = $root.signalservice.SyncMessage.toObject(message.syncMessage, options);
            if (message.callingMessage != null && message.hasOwnProperty("callingMessage"))
                object.callingMessage = $root.signalservice.CallingMessage.toObject(message.callingMessage, options);
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage"))
                object.nullMessage = $root.signalservice.NullMessage.toObject(message.nullMessage, options);
            if (message.receiptMessage != null && message.hasOwnProperty("receiptMessage"))
                object.receiptMessage = $root.signalservice.ReceiptMessage.toObject(message.receiptMessage, options);
            if (message.typingMessage != null && message.hasOwnProperty("typingMessage"))
                object.typingMessage = $root.signalservice.TypingMessage.toObject(message.typingMessage, options);
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage"))
                object.senderKeyDistributionMessage = options.bytes === String ? $util.base64.encode(message.senderKeyDistributionMessage, 0, message.senderKeyDistributionMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderKeyDistributionMessage) : message.senderKeyDistributionMessage;
            if (message.decryptionErrorMessage != null && message.hasOwnProperty("decryptionErrorMessage"))
                object.decryptionErrorMessage = options.bytes === String ? $util.base64.encode(message.decryptionErrorMessage, 0, message.decryptionErrorMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.decryptionErrorMessage) : message.decryptionErrorMessage;
            if (message.storyMessage != null && message.hasOwnProperty("storyMessage"))
                object.storyMessage = $root.signalservice.StoryMessage.toObject(message.storyMessage, options);
            if (message.pniSignatureMessage != null && message.hasOwnProperty("pniSignatureMessage"))
                object.pniSignatureMessage = $root.signalservice.PniSignatureMessage.toObject(message.pniSignatureMessage, options);
            return object;
        };

        /**
         * Converts this Content to JSON.
         * @function toJSON
         * @memberof signalservice.Content
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Content.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Content;
    })();

    signalservice.CallingMessage = (function() {

        /**
         * Properties of a CallingMessage.
         * @memberof signalservice
         * @interface ICallingMessage
         * @property {signalservice.CallingMessage.IOffer|null} [offer] CallingMessage offer
         * @property {signalservice.CallingMessage.IAnswer|null} [answer] CallingMessage answer
         * @property {Array.<signalservice.CallingMessage.IIceCandidate>|null} [iceCandidates] CallingMessage iceCandidates
         * @property {signalservice.CallingMessage.IHangup|null} [legacyHangup] CallingMessage legacyHangup
         * @property {signalservice.CallingMessage.IBusy|null} [busy] CallingMessage busy
         * @property {signalservice.CallingMessage.IHangup|null} [hangup] CallingMessage hangup
         * @property {boolean|null} [supportsMultiRing] CallingMessage supportsMultiRing
         * @property {number|null} [destinationDeviceId] CallingMessage destinationDeviceId
         * @property {signalservice.CallingMessage.IOpaque|null} [opaque] CallingMessage opaque
         */

        /**
         * Constructs a new CallingMessage.
         * @memberof signalservice
         * @classdesc Represents a CallingMessage.
         * @implements ICallingMessage
         * @constructor
         * @param {signalservice.ICallingMessage=} [properties] Properties to set
         */
        function CallingMessage(properties) {
            this.iceCandidates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallingMessage offer.
         * @member {signalservice.CallingMessage.IOffer|null|undefined} offer
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.offer = null;

        /**
         * CallingMessage answer.
         * @member {signalservice.CallingMessage.IAnswer|null|undefined} answer
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.answer = null;

        /**
         * CallingMessage iceCandidates.
         * @member {Array.<signalservice.CallingMessage.IIceCandidate>} iceCandidates
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.iceCandidates = $util.emptyArray;

        /**
         * CallingMessage legacyHangup.
         * @member {signalservice.CallingMessage.IHangup|null|undefined} legacyHangup
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.legacyHangup = null;

        /**
         * CallingMessage busy.
         * @member {signalservice.CallingMessage.IBusy|null|undefined} busy
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.busy = null;

        /**
         * CallingMessage hangup.
         * @member {signalservice.CallingMessage.IHangup|null|undefined} hangup
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.hangup = null;

        /**
         * CallingMessage supportsMultiRing.
         * @member {boolean} supportsMultiRing
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.supportsMultiRing = false;

        /**
         * CallingMessage destinationDeviceId.
         * @member {number} destinationDeviceId
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.destinationDeviceId = 0;

        /**
         * CallingMessage opaque.
         * @member {signalservice.CallingMessage.IOpaque|null|undefined} opaque
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.opaque = null;

        /**
         * Encodes the specified CallingMessage message. Does not implicitly {@link signalservice.CallingMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.ICallingMessage} message CallingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.CallingMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
                $root.signalservice.CallingMessage.Offer.encode(message.offer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
                $root.signalservice.CallingMessage.Answer.encode(message.answer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.iceCandidates != null && message.iceCandidates.length)
                for (var i = 0; i < message.iceCandidates.length; ++i)
                    $root.signalservice.CallingMessage.IceCandidate.encode(message.iceCandidates[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.legacyHangup != null && Object.hasOwnProperty.call(message, "legacyHangup"))
                $root.signalservice.CallingMessage.Hangup.encode(message.legacyHangup, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.busy != null && Object.hasOwnProperty.call(message, "busy"))
                $root.signalservice.CallingMessage.Busy.encode(message.busy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.hangup != null && Object.hasOwnProperty.call(message, "hangup"))
                $root.signalservice.CallingMessage.Hangup.encode(message.hangup, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.supportsMultiRing != null && Object.hasOwnProperty.call(message, "supportsMultiRing"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.supportsMultiRing);
            if (message.destinationDeviceId != null && Object.hasOwnProperty.call(message, "destinationDeviceId"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.destinationDeviceId);
            if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                $root.signalservice.CallingMessage.Opaque.encode(message.opaque, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified CallingMessage message, length delimited. Does not implicitly {@link signalservice.CallingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.ICallingMessage} message CallingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CallingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CallingMessage} CallingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.offer = $root.signalservice.CallingMessage.Offer.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.answer = $root.signalservice.CallingMessage.Answer.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.iceCandidates && message.iceCandidates.length))
                        message.iceCandidates = [];
                    message.iceCandidates.push($root.signalservice.CallingMessage.IceCandidate.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.legacyHangup = $root.signalservice.CallingMessage.Hangup.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.busy = $root.signalservice.CallingMessage.Busy.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.hangup = $root.signalservice.CallingMessage.Hangup.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.supportsMultiRing = reader.bool();
                    break;
                case 9:
                    message.destinationDeviceId = reader.uint32();
                    break;
                case 10:
                    message.opaque = $root.signalservice.CallingMessage.Opaque.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CallingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CallingMessage} CallingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a CallingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CallingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CallingMessage} CallingMessage
         */
        CallingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CallingMessage)
                return object;
            var message = new $root.signalservice.CallingMessage();
            if (object.offer != null) {
                if (typeof object.offer !== "object")
                    throw TypeError(".signalservice.CallingMessage.offer: object expected");
                message.offer = $root.signalservice.CallingMessage.Offer.fromObject(object.offer);
            }
            if (object.answer != null) {
                if (typeof object.answer !== "object")
                    throw TypeError(".signalservice.CallingMessage.answer: object expected");
                message.answer = $root.signalservice.CallingMessage.Answer.fromObject(object.answer);
            }
            if (object.iceCandidates) {
                if (!Array.isArray(object.iceCandidates))
                    throw TypeError(".signalservice.CallingMessage.iceCandidates: array expected");
                message.iceCandidates = [];
                for (var i = 0; i < object.iceCandidates.length; ++i) {
                    if (typeof object.iceCandidates[i] !== "object")
                        throw TypeError(".signalservice.CallingMessage.iceCandidates: object expected");
                    message.iceCandidates[i] = $root.signalservice.CallingMessage.IceCandidate.fromObject(object.iceCandidates[i]);
                }
            }
            if (object.legacyHangup != null) {
                if (typeof object.legacyHangup !== "object")
                    throw TypeError(".signalservice.CallingMessage.legacyHangup: object expected");
                message.legacyHangup = $root.signalservice.CallingMessage.Hangup.fromObject(object.legacyHangup);
            }
            if (object.busy != null) {
                if (typeof object.busy !== "object")
                    throw TypeError(".signalservice.CallingMessage.busy: object expected");
                message.busy = $root.signalservice.CallingMessage.Busy.fromObject(object.busy);
            }
            if (object.hangup != null) {
                if (typeof object.hangup !== "object")
                    throw TypeError(".signalservice.CallingMessage.hangup: object expected");
                message.hangup = $root.signalservice.CallingMessage.Hangup.fromObject(object.hangup);
            }
            if (object.supportsMultiRing != null)
                message.supportsMultiRing = Boolean(object.supportsMultiRing);
            if (object.destinationDeviceId != null)
                message.destinationDeviceId = object.destinationDeviceId >>> 0;
            if (object.opaque != null) {
                if (typeof object.opaque !== "object")
                    throw TypeError(".signalservice.CallingMessage.opaque: object expected");
                message.opaque = $root.signalservice.CallingMessage.Opaque.fromObject(object.opaque);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.CallingMessage} message CallingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.iceCandidates = [];
            if (options.defaults) {
                object.offer = null;
                object.answer = null;
                object.legacyHangup = null;
                object.busy = null;
                object.hangup = null;
                object.supportsMultiRing = false;
                object.destinationDeviceId = 0;
                object.opaque = null;
            }
            if (message.offer != null && message.hasOwnProperty("offer"))
                object.offer = $root.signalservice.CallingMessage.Offer.toObject(message.offer, options);
            if (message.answer != null && message.hasOwnProperty("answer"))
                object.answer = $root.signalservice.CallingMessage.Answer.toObject(message.answer, options);
            if (message.iceCandidates && message.iceCandidates.length) {
                object.iceCandidates = [];
                for (var j = 0; j < message.iceCandidates.length; ++j)
                    object.iceCandidates[j] = $root.signalservice.CallingMessage.IceCandidate.toObject(message.iceCandidates[j], options);
            }
            if (message.legacyHangup != null && message.hasOwnProperty("legacyHangup"))
                object.legacyHangup = $root.signalservice.CallingMessage.Hangup.toObject(message.legacyHangup, options);
            if (message.busy != null && message.hasOwnProperty("busy"))
                object.busy = $root.signalservice.CallingMessage.Busy.toObject(message.busy, options);
            if (message.hangup != null && message.hasOwnProperty("hangup"))
                object.hangup = $root.signalservice.CallingMessage.Hangup.toObject(message.hangup, options);
            if (message.supportsMultiRing != null && message.hasOwnProperty("supportsMultiRing"))
                object.supportsMultiRing = message.supportsMultiRing;
            if (message.destinationDeviceId != null && message.hasOwnProperty("destinationDeviceId"))
                object.destinationDeviceId = message.destinationDeviceId;
            if (message.opaque != null && message.hasOwnProperty("opaque"))
                object.opaque = $root.signalservice.CallingMessage.Opaque.toObject(message.opaque, options);
            return object;
        };

        /**
         * Converts this CallingMessage to JSON.
         * @function toJSON
         * @memberof signalservice.CallingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CallingMessage.Offer = (function() {

            /**
             * Properties of an Offer.
             * @memberof signalservice.CallingMessage
             * @interface IOffer
             * @property {Long|null} [callId] Offer callId
             * @property {string|null} [sdp] Offer sdp
             * @property {signalservice.CallingMessage.Offer.Type|null} [type] Offer type
             * @property {Uint8Array|null} [opaque] Offer opaque
             */

            /**
             * Constructs a new Offer.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Offer.
             * @implements IOffer
             * @constructor
             * @param {signalservice.CallingMessage.IOffer=} [properties] Properties to set
             */
            function Offer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Offer callId.
             * @member {Long} callId
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Offer sdp.
             * @member {string} sdp
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.sdp = "";

            /**
             * Offer type.
             * @member {signalservice.CallingMessage.Offer.Type} type
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.type = 0;

            /**
             * Offer opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.opaque = $util.newBuffer([]);

            /**
             * Encodes the specified Offer message. Does not implicitly {@link signalservice.CallingMessage.Offer.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.IOffer} message Offer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Offer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.Offer.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.sdp != null && Object.hasOwnProperty.call(message, "sdp"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdp);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.opaque);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Offer message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Offer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.IOffer} message Offer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Offer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Offer message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Offer} Offer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Offer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Offer();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callId = reader.uint64();
                        break;
                    case 2:
                        message.sdp = reader.string();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.opaque = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Offer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Offer} Offer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Offer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Offer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Offer} Offer
             */
            Offer.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Offer)
                    return object;
                var message = new $root.signalservice.CallingMessage.Offer();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.sdp != null)
                    message.sdp = String(object.sdp);
                switch (object.type) {
                case "OFFER_AUDIO_CALL":
                case 0:
                    message.type = 0;
                    break;
                case "OFFER_VIDEO_CALL":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an Offer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.Offer} message Offer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Offer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.sdp = "";
                    object.type = options.enums === String ? "OFFER_AUDIO_CALL" : 0;
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.sdp != null && message.hasOwnProperty("sdp"))
                    object.sdp = message.sdp;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.CallingMessage.Offer.Type[message.type] : message.type;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this Offer to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Offer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.CallingMessage.Offer.Type
             * @enum {number}
             * @property {number} OFFER_AUDIO_CALL=0 OFFER_AUDIO_CALL value
             * @property {number} OFFER_VIDEO_CALL=1 OFFER_VIDEO_CALL value
             */
            Offer.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OFFER_AUDIO_CALL"] = 0;
                values[valuesById[1] = "OFFER_VIDEO_CALL"] = 1;
                return values;
            })();

            return Offer;
        })();

        CallingMessage.Answer = (function() {

            /**
             * Properties of an Answer.
             * @memberof signalservice.CallingMessage
             * @interface IAnswer
             * @property {Long|null} [callId] Answer callId
             * @property {string|null} [sdp] Answer sdp
             * @property {Uint8Array|null} [opaque] Answer opaque
             */

            /**
             * Constructs a new Answer.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Answer.
             * @implements IAnswer
             * @constructor
             * @param {signalservice.CallingMessage.IAnswer=} [properties] Properties to set
             */
            function Answer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Answer callId.
             * @member {Long} callId
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             */
            Answer.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Answer sdp.
             * @member {string} sdp
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             */
            Answer.prototype.sdp = "";

            /**
             * Answer opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             */
            Answer.prototype.opaque = $util.newBuffer([]);

            /**
             * Encodes the specified Answer message. Does not implicitly {@link signalservice.CallingMessage.Answer.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.IAnswer} message Answer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Answer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.Answer.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.sdp != null && Object.hasOwnProperty.call(message, "sdp"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdp);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.opaque);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Answer message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Answer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.IAnswer} message Answer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Answer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Answer message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Answer} Answer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Answer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Answer();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callId = reader.uint64();
                        break;
                    case 2:
                        message.sdp = reader.string();
                        break;
                    case 3:
                        message.opaque = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Answer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Answer} Answer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Answer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Answer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Answer} Answer
             */
            Answer.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Answer)
                    return object;
                var message = new $root.signalservice.CallingMessage.Answer();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.sdp != null)
                    message.sdp = String(object.sdp);
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an Answer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.Answer} message Answer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Answer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.sdp = "";
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.sdp != null && message.hasOwnProperty("sdp"))
                    object.sdp = message.sdp;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this Answer to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Answer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Answer;
        })();

        CallingMessage.IceCandidate = (function() {

            /**
             * Properties of an IceCandidate.
             * @memberof signalservice.CallingMessage
             * @interface IIceCandidate
             * @property {Long|null} [callId] IceCandidate callId
             * @property {string|null} [mid] IceCandidate mid
             * @property {number|null} [line] IceCandidate line
             * @property {string|null} [sdp] IceCandidate sdp
             * @property {Uint8Array|null} [opaque] IceCandidate opaque
             */

            /**
             * Constructs a new IceCandidate.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an IceCandidate.
             * @implements IIceCandidate
             * @constructor
             * @param {signalservice.CallingMessage.IIceCandidate=} [properties] Properties to set
             */
            function IceCandidate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IceCandidate callId.
             * @member {Long} callId
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * IceCandidate mid.
             * @member {string} mid
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.mid = "";

            /**
             * IceCandidate line.
             * @member {number} line
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.line = 0;

            /**
             * IceCandidate sdp.
             * @member {string} sdp
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.sdp = "";

            /**
             * IceCandidate opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.opaque = $util.newBuffer([]);

            /**
             * Encodes the specified IceCandidate message. Does not implicitly {@link signalservice.CallingMessage.IceCandidate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IIceCandidate} message IceCandidate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IceCandidate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.IceCandidate.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.mid != null && Object.hasOwnProperty.call(message, "mid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mid);
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.line);
                if (message.sdp != null && Object.hasOwnProperty.call(message, "sdp"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sdp);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.opaque);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link signalservice.CallingMessage.IceCandidate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IIceCandidate} message IceCandidate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IceCandidate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IceCandidate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.IceCandidate();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callId = reader.uint64();
                        break;
                    case 2:
                        message.mid = reader.string();
                        break;
                    case 3:
                        message.line = reader.uint32();
                        break;
                    case 4:
                        message.sdp = reader.string();
                        break;
                    case 5:
                        message.opaque = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IceCandidate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             */
            IceCandidate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.IceCandidate)
                    return object;
                var message = new $root.signalservice.CallingMessage.IceCandidate();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.mid != null)
                    message.mid = String(object.mid);
                if (object.line != null)
                    message.line = object.line >>> 0;
                if (object.sdp != null)
                    message.sdp = String(object.sdp);
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IceCandidate} message IceCandidate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IceCandidate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.mid = "";
                    object.line = 0;
                    object.sdp = "";
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.mid != null && message.hasOwnProperty("mid"))
                    object.mid = message.mid;
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.sdp != null && message.hasOwnProperty("sdp"))
                    object.sdp = message.sdp;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this IceCandidate to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IceCandidate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IceCandidate;
        })();

        CallingMessage.Busy = (function() {

            /**
             * Properties of a Busy.
             * @memberof signalservice.CallingMessage
             * @interface IBusy
             * @property {Long|null} [callId] Busy callId
             */

            /**
             * Constructs a new Busy.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents a Busy.
             * @implements IBusy
             * @constructor
             * @param {signalservice.CallingMessage.IBusy=} [properties] Properties to set
             */
            function Busy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Busy callId.
             * @member {Long} callId
             * @memberof signalservice.CallingMessage.Busy
             * @instance
             */
            Busy.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Busy message. Does not implicitly {@link signalservice.CallingMessage.Busy.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.IBusy} message Busy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Busy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.Busy.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Busy message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Busy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.IBusy} message Busy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Busy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Busy message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Busy} Busy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Busy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Busy();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Busy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Busy} Busy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Busy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Busy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Busy} Busy
             */
            Busy.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Busy)
                    return object;
                var message = new $root.signalservice.CallingMessage.Busy();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Busy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.Busy} message Busy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Busy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                return object;
            };

            /**
             * Converts this Busy to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Busy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Busy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Busy;
        })();

        CallingMessage.Hangup = (function() {

            /**
             * Properties of a Hangup.
             * @memberof signalservice.CallingMessage
             * @interface IHangup
             * @property {Long|null} [callId] Hangup callId
             * @property {signalservice.CallingMessage.Hangup.Type|null} [type] Hangup type
             * @property {number|null} [deviceId] Hangup deviceId
             */

            /**
             * Constructs a new Hangup.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents a Hangup.
             * @implements IHangup
             * @constructor
             * @param {signalservice.CallingMessage.IHangup=} [properties] Properties to set
             */
            function Hangup(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Hangup callId.
             * @member {Long} callId
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Hangup type.
             * @member {signalservice.CallingMessage.Hangup.Type} type
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.type = 0;

            /**
             * Hangup deviceId.
             * @member {number} deviceId
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.deviceId = 0;

            /**
             * Encodes the specified Hangup message. Does not implicitly {@link signalservice.CallingMessage.Hangup.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.IHangup} message Hangup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hangup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.Hangup.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.deviceId);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Hangup message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Hangup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.IHangup} message Hangup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hangup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Hangup message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hangup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Hangup();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callId = reader.uint64();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.deviceId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Hangup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hangup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Hangup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             */
            Hangup.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Hangup)
                    return object;
                var message = new $root.signalservice.CallingMessage.Hangup();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                switch (object.type) {
                case "HANGUP_NORMAL":
                case 0:
                    message.type = 0;
                    break;
                case "HANGUP_ACCEPTED":
                case 1:
                    message.type = 1;
                    break;
                case "HANGUP_DECLINED":
                case 2:
                    message.type = 2;
                    break;
                case "HANGUP_BUSY":
                case 3:
                    message.type = 3;
                    break;
                case "HANGUP_NEED_PERMISSION":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.deviceId != null)
                    message.deviceId = object.deviceId >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Hangup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.Hangup} message Hangup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Hangup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "HANGUP_NORMAL" : 0;
                    object.deviceId = 0;
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.CallingMessage.Hangup.Type[message.type] : message.type;
                if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                    object.deviceId = message.deviceId;
                return object;
            };

            /**
             * Converts this Hangup to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Hangup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.CallingMessage.Hangup.Type
             * @enum {number}
             * @property {number} HANGUP_NORMAL=0 HANGUP_NORMAL value
             * @property {number} HANGUP_ACCEPTED=1 HANGUP_ACCEPTED value
             * @property {number} HANGUP_DECLINED=2 HANGUP_DECLINED value
             * @property {number} HANGUP_BUSY=3 HANGUP_BUSY value
             * @property {number} HANGUP_NEED_PERMISSION=4 HANGUP_NEED_PERMISSION value
             */
            Hangup.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "HANGUP_NORMAL"] = 0;
                values[valuesById[1] = "HANGUP_ACCEPTED"] = 1;
                values[valuesById[2] = "HANGUP_DECLINED"] = 2;
                values[valuesById[3] = "HANGUP_BUSY"] = 3;
                values[valuesById[4] = "HANGUP_NEED_PERMISSION"] = 4;
                return values;
            })();

            return Hangup;
        })();

        CallingMessage.Opaque = (function() {

            /**
             * Properties of an Opaque.
             * @memberof signalservice.CallingMessage
             * @interface IOpaque
             * @property {Uint8Array|null} [data] Opaque data
             * @property {signalservice.CallingMessage.Opaque.Urgency|null} [urgency] Opaque urgency
             */

            /**
             * Constructs a new Opaque.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Opaque.
             * @implements IOpaque
             * @constructor
             * @param {signalservice.CallingMessage.IOpaque=} [properties] Properties to set
             */
            function Opaque(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Opaque data.
             * @member {Uint8Array} data
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             */
            Opaque.prototype.data = $util.newBuffer([]);

            /**
             * Opaque urgency.
             * @member {signalservice.CallingMessage.Opaque.Urgency} urgency
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             */
            Opaque.prototype.urgency = 0;

            /**
             * Encodes the specified Opaque message. Does not implicitly {@link signalservice.CallingMessage.Opaque.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.IOpaque} message Opaque message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Opaque.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.CallingMessage.Opaque.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                if (message.urgency != null && Object.hasOwnProperty.call(message, "urgency"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.urgency);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Opaque message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Opaque.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.IOpaque} message Opaque message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Opaque.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Opaque message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Opaque.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Opaque();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.bytes();
                        break;
                    case 2:
                        message.urgency = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Opaque message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Opaque.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Opaque message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             */
            Opaque.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Opaque)
                    return object;
                var message = new $root.signalservice.CallingMessage.Opaque();
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                switch (object.urgency) {
                case "DROPPABLE":
                case 0:
                    message.urgency = 0;
                    break;
                case "HANDLE_IMMEDIATELY":
                case 1:
                    message.urgency = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an Opaque message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.Opaque} message Opaque
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Opaque.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    object.urgency = options.enums === String ? "DROPPABLE" : 0;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.urgency != null && message.hasOwnProperty("urgency"))
                    object.urgency = options.enums === String ? $root.signalservice.CallingMessage.Opaque.Urgency[message.urgency] : message.urgency;
                return object;
            };

            /**
             * Converts this Opaque to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Opaque.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Urgency enum.
             * @name signalservice.CallingMessage.Opaque.Urgency
             * @enum {number}
             * @property {number} DROPPABLE=0 DROPPABLE value
             * @property {number} HANDLE_IMMEDIATELY=1 HANDLE_IMMEDIATELY value
             */
            Opaque.Urgency = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DROPPABLE"] = 0;
                values[valuesById[1] = "HANDLE_IMMEDIATELY"] = 1;
                return values;
            })();

            return Opaque;
        })();

        return CallingMessage;
    })();

    signalservice.DataMessage = (function() {

        /**
         * Properties of a DataMessage.
         * @memberof signalservice
         * @interface IDataMessage
         * @property {string|null} [body] DataMessage body
         * @property {Array.<signalservice.IAttachmentPointer>|null} [attachments] DataMessage attachments
         * @property {signalservice.IGroupContext|null} [group] DataMessage group
         * @property {signalservice.IGroupContextV2|null} [groupV2] DataMessage groupV2
         * @property {number|null} [flags] DataMessage flags
         * @property {number|null} [expireTimer] DataMessage expireTimer
         * @property {Uint8Array|null} [profileKey] DataMessage profileKey
         * @property {Long|null} [timestamp] DataMessage timestamp
         * @property {signalservice.DataMessage.IQuote|null} [quote] DataMessage quote
         * @property {Array.<signalservice.DataMessage.IContact>|null} [contact] DataMessage contact
         * @property {Array.<signalservice.DataMessage.IPreview>|null} [preview] DataMessage preview
         * @property {signalservice.DataMessage.ISticker|null} [sticker] DataMessage sticker
         * @property {number|null} [requiredProtocolVersion] DataMessage requiredProtocolVersion
         * @property {boolean|null} [isViewOnce] DataMessage isViewOnce
         * @property {signalservice.DataMessage.IReaction|null} [reaction] DataMessage reaction
         * @property {signalservice.DataMessage.IDelete|null} ["delete"] DataMessage delete
         * @property {Array.<signalservice.DataMessage.IBodyRange>|null} [bodyRanges] DataMessage bodyRanges
         * @property {signalservice.DataMessage.IGroupCallUpdate|null} [groupCallUpdate] DataMessage groupCallUpdate
         * @property {signalservice.DataMessage.IStoryContext|null} [storyContext] DataMessage storyContext
         * @property {signalservice.DataMessage.IGiftBadge|null} [giftBadge] DataMessage giftBadge
         */

        /**
         * Constructs a new DataMessage.
         * @memberof signalservice
         * @classdesc Represents a DataMessage.
         * @implements IDataMessage
         * @constructor
         * @param {signalservice.IDataMessage=} [properties] Properties to set
         */
        function DataMessage(properties) {
            this.attachments = [];
            this.contact = [];
            this.preview = [];
            this.bodyRanges = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataMessage body.
         * @member {string} body
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.body = "";

        /**
         * DataMessage attachments.
         * @member {Array.<signalservice.IAttachmentPointer>} attachments
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.attachments = $util.emptyArray;

        /**
         * DataMessage group.
         * @member {signalservice.IGroupContext|null|undefined} group
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.group = null;

        /**
         * DataMessage groupV2.
         * @member {signalservice.IGroupContextV2|null|undefined} groupV2
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.groupV2 = null;

        /**
         * DataMessage flags.
         * @member {number} flags
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.flags = 0;

        /**
         * DataMessage expireTimer.
         * @member {number} expireTimer
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.expireTimer = 0;

        /**
         * DataMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * DataMessage timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DataMessage quote.
         * @member {signalservice.DataMessage.IQuote|null|undefined} quote
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.quote = null;

        /**
         * DataMessage contact.
         * @member {Array.<signalservice.DataMessage.IContact>} contact
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.contact = $util.emptyArray;

        /**
         * DataMessage preview.
         * @member {Array.<signalservice.DataMessage.IPreview>} preview
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.preview = $util.emptyArray;

        /**
         * DataMessage sticker.
         * @member {signalservice.DataMessage.ISticker|null|undefined} sticker
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.sticker = null;

        /**
         * DataMessage requiredProtocolVersion.
         * @member {number} requiredProtocolVersion
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.requiredProtocolVersion = 0;

        /**
         * DataMessage isViewOnce.
         * @member {boolean} isViewOnce
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.isViewOnce = false;

        /**
         * DataMessage reaction.
         * @member {signalservice.DataMessage.IReaction|null|undefined} reaction
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.reaction = null;

        /**
         * DataMessage delete.
         * @member {signalservice.DataMessage.IDelete|null|undefined} delete
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype["delete"] = null;

        /**
         * DataMessage bodyRanges.
         * @member {Array.<signalservice.DataMessage.IBodyRange>} bodyRanges
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.bodyRanges = $util.emptyArray;

        /**
         * DataMessage groupCallUpdate.
         * @member {signalservice.DataMessage.IGroupCallUpdate|null|undefined} groupCallUpdate
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.groupCallUpdate = null;

        /**
         * DataMessage storyContext.
         * @member {signalservice.DataMessage.IStoryContext|null|undefined} storyContext
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.storyContext = null;

        /**
         * DataMessage giftBadge.
         * @member {signalservice.DataMessage.IGiftBadge|null|undefined} giftBadge
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.giftBadge = null;

        /**
         * Encodes the specified DataMessage message. Does not implicitly {@link signalservice.DataMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.IDataMessage} message DataMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.DataMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.body);
            if (message.attachments != null && message.attachments.length)
                for (var i = 0; i < message.attachments.length; ++i)
                    $root.signalservice.AttachmentPointer.encode(message.attachments[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                $root.signalservice.GroupContext.encode(message.group, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags);
            if (message.expireTimer != null && Object.hasOwnProperty.call(message, "expireTimer"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expireTimer);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.profileKey);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.timestamp);
            if (message.quote != null && Object.hasOwnProperty.call(message, "quote"))
                $root.signalservice.DataMessage.Quote.encode(message.quote, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.contact != null && message.contact.length)
                for (var i = 0; i < message.contact.length; ++i)
                    $root.signalservice.DataMessage.Contact.encode(message.contact[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.preview != null && message.preview.length)
                for (var i = 0; i < message.preview.length; ++i)
                    $root.signalservice.DataMessage.Preview.encode(message.preview[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.sticker != null && Object.hasOwnProperty.call(message, "sticker"))
                $root.signalservice.DataMessage.Sticker.encode(message.sticker, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.requiredProtocolVersion != null && Object.hasOwnProperty.call(message, "requiredProtocolVersion"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.requiredProtocolVersion);
            if (message.isViewOnce != null && Object.hasOwnProperty.call(message, "isViewOnce"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isViewOnce);
            if (message.groupV2 != null && Object.hasOwnProperty.call(message, "groupV2"))
                $root.signalservice.GroupContextV2.encode(message.groupV2, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.reaction != null && Object.hasOwnProperty.call(message, "reaction"))
                $root.signalservice.DataMessage.Reaction.encode(message.reaction, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                $root.signalservice.DataMessage.Delete.encode(message["delete"], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.bodyRanges != null && message.bodyRanges.length)
                for (var i = 0; i < message.bodyRanges.length; ++i)
                    $root.signalservice.DataMessage.BodyRange.encode(message.bodyRanges[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.groupCallUpdate != null && Object.hasOwnProperty.call(message, "groupCallUpdate"))
                $root.signalservice.DataMessage.GroupCallUpdate.encode(message.groupCallUpdate, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.storyContext != null && Object.hasOwnProperty.call(message, "storyContext"))
                $root.signalservice.DataMessage.StoryContext.encode(message.storyContext, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.giftBadge != null && Object.hasOwnProperty.call(message, "giftBadge"))
                $root.signalservice.DataMessage.GiftBadge.encode(message.giftBadge, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified DataMessage message, length delimited. Does not implicitly {@link signalservice.DataMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.IDataMessage} message DataMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.DataMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.DataMessage} DataMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                case 2:
                    if (!(message.attachments && message.attachments.length))
                        message.attachments = [];
                    message.attachments.push($root.signalservice.AttachmentPointer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.group = $root.signalservice.GroupContext.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.groupV2 = $root.signalservice.GroupContextV2.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.flags = reader.uint32();
                    break;
                case 5:
                    message.expireTimer = reader.uint32();
                    break;
                case 6:
                    message.profileKey = reader.bytes();
                    break;
                case 7:
                    message.timestamp = reader.uint64();
                    break;
                case 8:
                    message.quote = $root.signalservice.DataMessage.Quote.decode(reader, reader.uint32());
                    break;
                case 9:
                    if (!(message.contact && message.contact.length))
                        message.contact = [];
                    message.contact.push($root.signalservice.DataMessage.Contact.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.preview && message.preview.length))
                        message.preview = [];
                    message.preview.push($root.signalservice.DataMessage.Preview.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.sticker = $root.signalservice.DataMessage.Sticker.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.requiredProtocolVersion = reader.uint32();
                    break;
                case 14:
                    message.isViewOnce = reader.bool();
                    break;
                case 16:
                    message.reaction = $root.signalservice.DataMessage.Reaction.decode(reader, reader.uint32());
                    break;
                case 17:
                    message["delete"] = $root.signalservice.DataMessage.Delete.decode(reader, reader.uint32());
                    break;
                case 18:
                    if (!(message.bodyRanges && message.bodyRanges.length))
                        message.bodyRanges = [];
                    message.bodyRanges.push($root.signalservice.DataMessage.BodyRange.decode(reader, reader.uint32()));
                    break;
                case 19:
                    message.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.storyContext = $root.signalservice.DataMessage.StoryContext.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.giftBadge = $root.signalservice.DataMessage.GiftBadge.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.DataMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.DataMessage} DataMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a DataMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.DataMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.DataMessage} DataMessage
         */
        DataMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.DataMessage)
                return object;
            var message = new $root.signalservice.DataMessage();
            if (object.body != null)
                message.body = String(object.body);
            if (object.attachments) {
                if (!Array.isArray(object.attachments))
                    throw TypeError(".signalservice.DataMessage.attachments: array expected");
                message.attachments = [];
                for (var i = 0; i < object.attachments.length; ++i) {
                    if (typeof object.attachments[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.attachments: object expected");
                    message.attachments[i] = $root.signalservice.AttachmentPointer.fromObject(object.attachments[i]);
                }
            }
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".signalservice.DataMessage.group: object expected");
                message.group = $root.signalservice.GroupContext.fromObject(object.group);
            }
            if (object.groupV2 != null) {
                if (typeof object.groupV2 !== "object")
                    throw TypeError(".signalservice.DataMessage.groupV2: object expected");
                message.groupV2 = $root.signalservice.GroupContextV2.fromObject(object.groupV2);
            }
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.expireTimer != null)
                message.expireTimer = object.expireTimer >>> 0;
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.quote != null) {
                if (typeof object.quote !== "object")
                    throw TypeError(".signalservice.DataMessage.quote: object expected");
                message.quote = $root.signalservice.DataMessage.Quote.fromObject(object.quote);
            }
            if (object.contact) {
                if (!Array.isArray(object.contact))
                    throw TypeError(".signalservice.DataMessage.contact: array expected");
                message.contact = [];
                for (var i = 0; i < object.contact.length; ++i) {
                    if (typeof object.contact[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.contact: object expected");
                    message.contact[i] = $root.signalservice.DataMessage.Contact.fromObject(object.contact[i]);
                }
            }
            if (object.preview) {
                if (!Array.isArray(object.preview))
                    throw TypeError(".signalservice.DataMessage.preview: array expected");
                message.preview = [];
                for (var i = 0; i < object.preview.length; ++i) {
                    if (typeof object.preview[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.preview: object expected");
                    message.preview[i] = $root.signalservice.DataMessage.Preview.fromObject(object.preview[i]);
                }
            }
            if (object.sticker != null) {
                if (typeof object.sticker !== "object")
                    throw TypeError(".signalservice.DataMessage.sticker: object expected");
                message.sticker = $root.signalservice.DataMessage.Sticker.fromObject(object.sticker);
            }
            if (object.requiredProtocolVersion != null)
                message.requiredProtocolVersion = object.requiredProtocolVersion >>> 0;
            if (object.isViewOnce != null)
                message.isViewOnce = Boolean(object.isViewOnce);
            if (object.reaction != null) {
                if (typeof object.reaction !== "object")
                    throw TypeError(".signalservice.DataMessage.reaction: object expected");
                message.reaction = $root.signalservice.DataMessage.Reaction.fromObject(object.reaction);
            }
            if (object["delete"] != null) {
                if (typeof object["delete"] !== "object")
                    throw TypeError(".signalservice.DataMessage.delete: object expected");
                message["delete"] = $root.signalservice.DataMessage.Delete.fromObject(object["delete"]);
            }
            if (object.bodyRanges) {
                if (!Array.isArray(object.bodyRanges))
                    throw TypeError(".signalservice.DataMessage.bodyRanges: array expected");
                message.bodyRanges = [];
                for (var i = 0; i < object.bodyRanges.length; ++i) {
                    if (typeof object.bodyRanges[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.bodyRanges: object expected");
                    message.bodyRanges[i] = $root.signalservice.DataMessage.BodyRange.fromObject(object.bodyRanges[i]);
                }
            }
            if (object.groupCallUpdate != null) {
                if (typeof object.groupCallUpdate !== "object")
                    throw TypeError(".signalservice.DataMessage.groupCallUpdate: object expected");
                message.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.fromObject(object.groupCallUpdate);
            }
            if (object.storyContext != null) {
                if (typeof object.storyContext !== "object")
                    throw TypeError(".signalservice.DataMessage.storyContext: object expected");
                message.storyContext = $root.signalservice.DataMessage.StoryContext.fromObject(object.storyContext);
            }
            if (object.giftBadge != null) {
                if (typeof object.giftBadge !== "object")
                    throw TypeError(".signalservice.DataMessage.giftBadge: object expected");
                message.giftBadge = $root.signalservice.DataMessage.GiftBadge.fromObject(object.giftBadge);
            }
            return message;
        };

        /**
         * Creates a plain object from a DataMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.DataMessage} message DataMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.attachments = [];
                object.contact = [];
                object.preview = [];
                object.bodyRanges = [];
            }
            if (options.defaults) {
                object.body = "";
                object.group = null;
                object.flags = 0;
                object.expireTimer = 0;
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.quote = null;
                object.sticker = null;
                object.requiredProtocolVersion = 0;
                object.isViewOnce = false;
                object.groupV2 = null;
                object.reaction = null;
                object["delete"] = null;
                object.groupCallUpdate = null;
                object.storyContext = null;
                object.giftBadge = null;
            }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.attachments && message.attachments.length) {
                object.attachments = [];
                for (var j = 0; j < message.attachments.length; ++j)
                    object.attachments[j] = $root.signalservice.AttachmentPointer.toObject(message.attachments[j], options);
            }
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.signalservice.GroupContext.toObject(message.group, options);
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                object.expireTimer = message.expireTimer;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.quote != null && message.hasOwnProperty("quote"))
                object.quote = $root.signalservice.DataMessage.Quote.toObject(message.quote, options);
            if (message.contact && message.contact.length) {
                object.contact = [];
                for (var j = 0; j < message.contact.length; ++j)
                    object.contact[j] = $root.signalservice.DataMessage.Contact.toObject(message.contact[j], options);
            }
            if (message.preview && message.preview.length) {
                object.preview = [];
                for (var j = 0; j < message.preview.length; ++j)
                    object.preview[j] = $root.signalservice.DataMessage.Preview.toObject(message.preview[j], options);
            }
            if (message.sticker != null && message.hasOwnProperty("sticker"))
                object.sticker = $root.signalservice.DataMessage.Sticker.toObject(message.sticker, options);
            if (message.requiredProtocolVersion != null && message.hasOwnProperty("requiredProtocolVersion"))
                object.requiredProtocolVersion = message.requiredProtocolVersion;
            if (message.isViewOnce != null && message.hasOwnProperty("isViewOnce"))
                object.isViewOnce = message.isViewOnce;
            if (message.groupV2 != null && message.hasOwnProperty("groupV2"))
                object.groupV2 = $root.signalservice.GroupContextV2.toObject(message.groupV2, options);
            if (message.reaction != null && message.hasOwnProperty("reaction"))
                object.reaction = $root.signalservice.DataMessage.Reaction.toObject(message.reaction, options);
            if (message["delete"] != null && message.hasOwnProperty("delete"))
                object["delete"] = $root.signalservice.DataMessage.Delete.toObject(message["delete"], options);
            if (message.bodyRanges && message.bodyRanges.length) {
                object.bodyRanges = [];
                for (var j = 0; j < message.bodyRanges.length; ++j)
                    object.bodyRanges[j] = $root.signalservice.DataMessage.BodyRange.toObject(message.bodyRanges[j], options);
            }
            if (message.groupCallUpdate != null && message.hasOwnProperty("groupCallUpdate"))
                object.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.toObject(message.groupCallUpdate, options);
            if (message.storyContext != null && message.hasOwnProperty("storyContext"))
                object.storyContext = $root.signalservice.DataMessage.StoryContext.toObject(message.storyContext, options);
            if (message.giftBadge != null && message.hasOwnProperty("giftBadge"))
                object.giftBadge = $root.signalservice.DataMessage.GiftBadge.toObject(message.giftBadge, options);
            return object;
        };

        /**
         * Converts this DataMessage to JSON.
         * @function toJSON
         * @memberof signalservice.DataMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Flags enum.
         * @name signalservice.DataMessage.Flags
         * @enum {number}
         * @property {number} END_SESSION=1 END_SESSION value
         * @property {number} EXPIRATION_TIMER_UPDATE=2 EXPIRATION_TIMER_UPDATE value
         * @property {number} PROFILE_KEY_UPDATE=4 PROFILE_KEY_UPDATE value
         */
        DataMessage.Flags = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "END_SESSION"] = 1;
            values[valuesById[2] = "EXPIRATION_TIMER_UPDATE"] = 2;
            values[valuesById[4] = "PROFILE_KEY_UPDATE"] = 4;
            return values;
        })();

        DataMessage.Quote = (function() {

            /**
             * Properties of a Quote.
             * @memberof signalservice.DataMessage
             * @interface IQuote
             * @property {Long|null} [id] Quote id
             * @property {string|null} [authorUuid] Quote authorUuid
             * @property {string|null} [text] Quote text
             * @property {Array.<signalservice.DataMessage.Quote.IQuotedAttachment>|null} [attachments] Quote attachments
             * @property {Array.<signalservice.DataMessage.IBodyRange>|null} [bodyRanges] Quote bodyRanges
             * @property {signalservice.DataMessage.Quote.Type|null} [type] Quote type
             */

            /**
             * Constructs a new Quote.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Quote.
             * @implements IQuote
             * @constructor
             * @param {signalservice.DataMessage.IQuote=} [properties] Properties to set
             */
            function Quote(properties) {
                this.attachments = [];
                this.bodyRanges = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Quote id.
             * @member {Long} id
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Quote authorUuid.
             * @member {string} authorUuid
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.authorUuid = "";

            /**
             * Quote text.
             * @member {string} text
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.text = "";

            /**
             * Quote attachments.
             * @member {Array.<signalservice.DataMessage.Quote.IQuotedAttachment>} attachments
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.attachments = $util.emptyArray;

            /**
             * Quote bodyRanges.
             * @member {Array.<signalservice.DataMessage.IBodyRange>} bodyRanges
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.bodyRanges = $util.emptyArray;

            /**
             * Quote type.
             * @member {signalservice.DataMessage.Quote.Type} type
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.type = 0;

            /**
             * Encodes the specified Quote message. Does not implicitly {@link signalservice.DataMessage.Quote.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.IQuote} message Quote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quote.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Quote.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
                if (message.attachments != null && message.attachments.length)
                    for (var i = 0; i < message.attachments.length; ++i)
                        $root.signalservice.DataMessage.Quote.QuotedAttachment.encode(message.attachments[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.authorUuid != null && Object.hasOwnProperty.call(message, "authorUuid"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.authorUuid);
                if (message.bodyRanges != null && message.bodyRanges.length)
                    for (var i = 0; i < message.bodyRanges.length; ++i)
                        $root.signalservice.DataMessage.BodyRange.encode(message.bodyRanges[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Quote message, length delimited. Does not implicitly {@link signalservice.DataMessage.Quote.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.IQuote} message Quote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quote.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Quote message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Quote} Quote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quote.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Quote();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 5:
                        message.authorUuid = reader.string();
                        break;
                    case 3:
                        message.text = reader.string();
                        break;
                    case 4:
                        if (!(message.attachments && message.attachments.length))
                            message.attachments = [];
                        message.attachments.push($root.signalservice.DataMessage.Quote.QuotedAttachment.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.bodyRanges && message.bodyRanges.length))
                            message.bodyRanges = [];
                        message.bodyRanges.push($root.signalservice.DataMessage.BodyRange.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Quote message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Quote} Quote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quote.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Quote message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Quote} Quote
             */
            Quote.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Quote)
                    return object;
                var message = new $root.signalservice.DataMessage.Quote();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.authorUuid != null)
                    message.authorUuid = String(object.authorUuid);
                if (object.text != null)
                    message.text = String(object.text);
                if (object.attachments) {
                    if (!Array.isArray(object.attachments))
                        throw TypeError(".signalservice.DataMessage.Quote.attachments: array expected");
                    message.attachments = [];
                    for (var i = 0; i < object.attachments.length; ++i) {
                        if (typeof object.attachments[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.attachments: object expected");
                        message.attachments[i] = $root.signalservice.DataMessage.Quote.QuotedAttachment.fromObject(object.attachments[i]);
                    }
                }
                if (object.bodyRanges) {
                    if (!Array.isArray(object.bodyRanges))
                        throw TypeError(".signalservice.DataMessage.Quote.bodyRanges: array expected");
                    message.bodyRanges = [];
                    for (var i = 0; i < object.bodyRanges.length; ++i) {
                        if (typeof object.bodyRanges[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.bodyRanges: object expected");
                        message.bodyRanges[i] = $root.signalservice.DataMessage.BodyRange.fromObject(object.bodyRanges[i]);
                    }
                }
                switch (object.type) {
                case "NORMAL":
                case 0:
                    message.type = 0;
                    break;
                case "GIFT_BADGE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Quote message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.Quote} message Quote
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Quote.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.attachments = [];
                    object.bodyRanges = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    object.text = "";
                    object.authorUuid = "";
                    object.type = options.enums === String ? "NORMAL" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.attachments && message.attachments.length) {
                    object.attachments = [];
                    for (var j = 0; j < message.attachments.length; ++j)
                        object.attachments[j] = $root.signalservice.DataMessage.Quote.QuotedAttachment.toObject(message.attachments[j], options);
                }
                if (message.authorUuid != null && message.hasOwnProperty("authorUuid"))
                    object.authorUuid = message.authorUuid;
                if (message.bodyRanges && message.bodyRanges.length) {
                    object.bodyRanges = [];
                    for (var j = 0; j < message.bodyRanges.length; ++j)
                        object.bodyRanges[j] = $root.signalservice.DataMessage.BodyRange.toObject(message.bodyRanges[j], options);
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.DataMessage.Quote.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Quote to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Quote
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Quote.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.DataMessage.Quote.Type
             * @enum {number}
             * @property {number} NORMAL=0 NORMAL value
             * @property {number} GIFT_BADGE=1 GIFT_BADGE value
             */
            Quote.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NORMAL"] = 0;
                values[valuesById[1] = "GIFT_BADGE"] = 1;
                return values;
            })();

            Quote.QuotedAttachment = (function() {

                /**
                 * Properties of a QuotedAttachment.
                 * @memberof signalservice.DataMessage.Quote
                 * @interface IQuotedAttachment
                 * @property {string|null} [contentType] QuotedAttachment contentType
                 * @property {string|null} [fileName] QuotedAttachment fileName
                 * @property {signalservice.IAttachmentPointer|null} [thumbnail] QuotedAttachment thumbnail
                 */

                /**
                 * Constructs a new QuotedAttachment.
                 * @memberof signalservice.DataMessage.Quote
                 * @classdesc Represents a QuotedAttachment.
                 * @implements IQuotedAttachment
                 * @constructor
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment=} [properties] Properties to set
                 */
                function QuotedAttachment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QuotedAttachment contentType.
                 * @member {string} contentType
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.contentType = "";

                /**
                 * QuotedAttachment fileName.
                 * @member {string} fileName
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.fileName = "";

                /**
                 * QuotedAttachment thumbnail.
                 * @member {signalservice.IAttachmentPointer|null|undefined} thumbnail
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.thumbnail = null;

                /**
                 * Encodes the specified QuotedAttachment message. Does not implicitly {@link signalservice.DataMessage.Quote.QuotedAttachment.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment} message QuotedAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuotedAttachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Quote.QuotedAttachment.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                    if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                    if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                        $root.signalservice.AttachmentPointer.encode(message.thumbnail, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified QuotedAttachment message, length delimited. Does not implicitly {@link signalservice.DataMessage.Quote.QuotedAttachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment} message QuotedAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuotedAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QuotedAttachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuotedAttachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Quote.QuotedAttachment();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contentType = reader.string();
                            break;
                        case 2:
                            message.fileName = reader.string();
                            break;
                        case 3:
                            message.thumbnail = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QuotedAttachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuotedAttachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a QuotedAttachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 */
                QuotedAttachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Quote.QuotedAttachment)
                        return object;
                    var message = new $root.signalservice.DataMessage.Quote.QuotedAttachment();
                    if (object.contentType != null)
                        message.contentType = String(object.contentType);
                    if (object.fileName != null)
                        message.fileName = String(object.fileName);
                    if (object.thumbnail != null) {
                        if (typeof object.thumbnail !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.QuotedAttachment.thumbnail: object expected");
                        message.thumbnail = $root.signalservice.AttachmentPointer.fromObject(object.thumbnail);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QuotedAttachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.QuotedAttachment} message QuotedAttachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuotedAttachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.contentType = "";
                        object.fileName = "";
                        object.thumbnail = null;
                    }
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        object.contentType = message.contentType;
                    if (message.fileName != null && message.hasOwnProperty("fileName"))
                        object.fileName = message.fileName;
                    if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                        object.thumbnail = $root.signalservice.AttachmentPointer.toObject(message.thumbnail, options);
                    return object;
                };

                /**
                 * Converts this QuotedAttachment to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuotedAttachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QuotedAttachment;
            })();

            return Quote;
        })();

        DataMessage.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof signalservice.DataMessage
             * @interface IContact
             * @property {signalservice.DataMessage.Contact.IName|null} [name] Contact name
             * @property {Array.<signalservice.DataMessage.Contact.IPhone>|null} [number] Contact number
             * @property {Array.<signalservice.DataMessage.Contact.IEmail>|null} [email] Contact email
             * @property {Array.<signalservice.DataMessage.Contact.IPostalAddress>|null} [address] Contact address
             * @property {signalservice.DataMessage.Contact.IAvatar|null} [avatar] Contact avatar
             * @property {string|null} [organization] Contact organization
             */

            /**
             * Constructs a new Contact.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {signalservice.DataMessage.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                this.number = [];
                this.email = [];
                this.address = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact name.
             * @member {signalservice.DataMessage.Contact.IName|null|undefined} name
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.name = null;

            /**
             * Contact number.
             * @member {Array.<signalservice.DataMessage.Contact.IPhone>} number
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.number = $util.emptyArray;

            /**
             * Contact email.
             * @member {Array.<signalservice.DataMessage.Contact.IEmail>} email
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.email = $util.emptyArray;

            /**
             * Contact address.
             * @member {Array.<signalservice.DataMessage.Contact.IPostalAddress>} address
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.address = $util.emptyArray;

            /**
             * Contact avatar.
             * @member {signalservice.DataMessage.Contact.IAvatar|null|undefined} avatar
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.avatar = null;

            /**
             * Contact organization.
             * @member {string} organization
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.organization = "";

            /**
             * Encodes the specified Contact message. Does not implicitly {@link signalservice.DataMessage.Contact.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Contact.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    $root.signalservice.DataMessage.Contact.Name.encode(message.name, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.number != null && message.number.length)
                    for (var i = 0; i < message.number.length; ++i)
                        $root.signalservice.DataMessage.Contact.Phone.encode(message.number[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.email != null && message.email.length)
                    for (var i = 0; i < message.email.length; ++i)
                        $root.signalservice.DataMessage.Contact.Email.encode(message.email[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.address != null && message.address.length)
                    for (var i = 0; i < message.address.length; ++i)
                        $root.signalservice.DataMessage.Contact.PostalAddress.encode(message.address[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    $root.signalservice.DataMessage.Contact.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.organization != null && Object.hasOwnProperty.call(message, "organization"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.organization);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = $root.signalservice.DataMessage.Contact.Name.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.number && message.number.length))
                            message.number = [];
                        message.number.push($root.signalservice.DataMessage.Contact.Phone.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.email && message.email.length))
                            message.email = [];
                        message.email.push($root.signalservice.DataMessage.Contact.Email.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.address && message.address.length))
                            message.address = [];
                        message.address.push($root.signalservice.DataMessage.Contact.PostalAddress.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.avatar = $root.signalservice.DataMessage.Contact.Avatar.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.organization = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Contact)
                    return object;
                var message = new $root.signalservice.DataMessage.Contact();
                if (object.name != null) {
                    if (typeof object.name !== "object")
                        throw TypeError(".signalservice.DataMessage.Contact.name: object expected");
                    message.name = $root.signalservice.DataMessage.Contact.Name.fromObject(object.name);
                }
                if (object.number) {
                    if (!Array.isArray(object.number))
                        throw TypeError(".signalservice.DataMessage.Contact.number: array expected");
                    message.number = [];
                    for (var i = 0; i < object.number.length; ++i) {
                        if (typeof object.number[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.number: object expected");
                        message.number[i] = $root.signalservice.DataMessage.Contact.Phone.fromObject(object.number[i]);
                    }
                }
                if (object.email) {
                    if (!Array.isArray(object.email))
                        throw TypeError(".signalservice.DataMessage.Contact.email: array expected");
                    message.email = [];
                    for (var i = 0; i < object.email.length; ++i) {
                        if (typeof object.email[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.email: object expected");
                        message.email[i] = $root.signalservice.DataMessage.Contact.Email.fromObject(object.email[i]);
                    }
                }
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".signalservice.DataMessage.Contact.address: array expected");
                    message.address = [];
                    for (var i = 0; i < object.address.length; ++i) {
                        if (typeof object.address[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.address: object expected");
                        message.address[i] = $root.signalservice.DataMessage.Contact.PostalAddress.fromObject(object.address[i]);
                    }
                }
                if (object.avatar != null) {
                    if (typeof object.avatar !== "object")
                        throw TypeError(".signalservice.DataMessage.Contact.avatar: object expected");
                    message.avatar = $root.signalservice.DataMessage.Contact.Avatar.fromObject(object.avatar);
                }
                if (object.organization != null)
                    message.organization = String(object.organization);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.number = [];
                    object.email = [];
                    object.address = [];
                }
                if (options.defaults) {
                    object.name = null;
                    object.avatar = null;
                    object.organization = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = $root.signalservice.DataMessage.Contact.Name.toObject(message.name, options);
                if (message.number && message.number.length) {
                    object.number = [];
                    for (var j = 0; j < message.number.length; ++j)
                        object.number[j] = $root.signalservice.DataMessage.Contact.Phone.toObject(message.number[j], options);
                }
                if (message.email && message.email.length) {
                    object.email = [];
                    for (var j = 0; j < message.email.length; ++j)
                        object.email[j] = $root.signalservice.DataMessage.Contact.Email.toObject(message.email[j], options);
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (var j = 0; j < message.address.length; ++j)
                        object.address[j] = $root.signalservice.DataMessage.Contact.PostalAddress.toObject(message.address[j], options);
                }
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = $root.signalservice.DataMessage.Contact.Avatar.toObject(message.avatar, options);
                if (message.organization != null && message.hasOwnProperty("organization"))
                    object.organization = message.organization;
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Contact.Name = (function() {

                /**
                 * Properties of a Name.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IName
                 * @property {string|null} [givenName] Name givenName
                 * @property {string|null} [familyName] Name familyName
                 * @property {string|null} [prefix] Name prefix
                 * @property {string|null} [suffix] Name suffix
                 * @property {string|null} [middleName] Name middleName
                 * @property {string|null} [displayName] Name displayName
                 */

                /**
                 * Constructs a new Name.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a Name.
                 * @implements IName
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IName=} [properties] Properties to set
                 */
                function Name(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Name givenName.
                 * @member {string} givenName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.givenName = "";

                /**
                 * Name familyName.
                 * @member {string} familyName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.familyName = "";

                /**
                 * Name prefix.
                 * @member {string} prefix
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.prefix = "";

                /**
                 * Name suffix.
                 * @member {string} suffix
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.suffix = "";

                /**
                 * Name middleName.
                 * @member {string} middleName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.middleName = "";

                /**
                 * Name displayName.
                 * @member {string} displayName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.displayName = "";

                /**
                 * Encodes the specified Name message. Does not implicitly {@link signalservice.DataMessage.Contact.Name.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.IName} message Name message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Name.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Contact.Name.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.givenName != null && Object.hasOwnProperty.call(message, "givenName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.givenName);
                    if (message.familyName != null && Object.hasOwnProperty.call(message, "familyName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.familyName);
                    if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.prefix);
                    if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                    if (message.middleName != null && Object.hasOwnProperty.call(message, "middleName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.middleName);
                    if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.displayName);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Name message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Name.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.IName} message Name message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Name.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Name message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Name.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Name();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.givenName = reader.string();
                            break;
                        case 2:
                            message.familyName = reader.string();
                            break;
                        case 3:
                            message.prefix = reader.string();
                            break;
                        case 4:
                            message.suffix = reader.string();
                            break;
                        case 5:
                            message.middleName = reader.string();
                            break;
                        case 6:
                            message.displayName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Name message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Name.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a Name message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 */
                Name.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Name)
                        return object;
                    var message = new $root.signalservice.DataMessage.Contact.Name();
                    if (object.givenName != null)
                        message.givenName = String(object.givenName);
                    if (object.familyName != null)
                        message.familyName = String(object.familyName);
                    if (object.prefix != null)
                        message.prefix = String(object.prefix);
                    if (object.suffix != null)
                        message.suffix = String(object.suffix);
                    if (object.middleName != null)
                        message.middleName = String(object.middleName);
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    return message;
                };

                /**
                 * Creates a plain object from a Name message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.Name} message Name
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Name.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.givenName = "";
                        object.familyName = "";
                        object.prefix = "";
                        object.suffix = "";
                        object.middleName = "";
                        object.displayName = "";
                    }
                    if (message.givenName != null && message.hasOwnProperty("givenName"))
                        object.givenName = message.givenName;
                    if (message.familyName != null && message.hasOwnProperty("familyName"))
                        object.familyName = message.familyName;
                    if (message.prefix != null && message.hasOwnProperty("prefix"))
                        object.prefix = message.prefix;
                    if (message.suffix != null && message.hasOwnProperty("suffix"))
                        object.suffix = message.suffix;
                    if (message.middleName != null && message.hasOwnProperty("middleName"))
                        object.middleName = message.middleName;
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    return object;
                };

                /**
                 * Converts this Name to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Name.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Name;
            })();

            Contact.Phone = (function() {

                /**
                 * Properties of a Phone.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IPhone
                 * @property {string|null} [value] Phone value
                 * @property {signalservice.DataMessage.Contact.Phone.Type|null} [type] Phone type
                 * @property {string|null} [label] Phone label
                 */

                /**
                 * Constructs a new Phone.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a Phone.
                 * @implements IPhone
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IPhone=} [properties] Properties to set
                 */
                function Phone(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Phone value.
                 * @member {string} value
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.value = "";

                /**
                 * Phone type.
                 * @member {signalservice.DataMessage.Contact.Phone.Type} type
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.type = 1;

                /**
                 * Phone label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.label = "";

                /**
                 * Encodes the specified Phone message. Does not implicitly {@link signalservice.DataMessage.Contact.Phone.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPhone} message Phone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Phone.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Contact.Phone.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Phone message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Phone.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPhone} message Phone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Phone.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Phone message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Phone.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Phone();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.label = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Phone message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Phone.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a Phone message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 */
                Phone.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Phone)
                        return object;
                    var message = new $root.signalservice.DataMessage.Contact.Phone();
                    if (object.value != null)
                        message.value = String(object.value);
                    switch (object.type) {
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "MOBILE":
                    case 2:
                        message.type = 2;
                        break;
                    case "WORK":
                    case 3:
                        message.type = 3;
                        break;
                    case "CUSTOM":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from a Phone message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.Phone} message Phone
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Phone.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.Phone.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this Phone to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Phone.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.Phone.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} MOBILE=2 MOBILE value
                 * @property {number} WORK=3 WORK value
                 * @property {number} CUSTOM=4 CUSTOM value
                 */
                Phone.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "MOBILE"] = 2;
                    values[valuesById[3] = "WORK"] = 3;
                    values[valuesById[4] = "CUSTOM"] = 4;
                    return values;
                })();

                return Phone;
            })();

            Contact.Email = (function() {

                /**
                 * Properties of an Email.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IEmail
                 * @property {string|null} [value] Email value
                 * @property {signalservice.DataMessage.Contact.Email.Type|null} [type] Email type
                 * @property {string|null} [label] Email label
                 */

                /**
                 * Constructs a new Email.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents an Email.
                 * @implements IEmail
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IEmail=} [properties] Properties to set
                 */
                function Email(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Email value.
                 * @member {string} value
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.value = "";

                /**
                 * Email type.
                 * @member {signalservice.DataMessage.Contact.Email.Type} type
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.type = 1;

                /**
                 * Email label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.label = "";

                /**
                 * Encodes the specified Email message. Does not implicitly {@link signalservice.DataMessage.Contact.Email.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.IEmail} message Email message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Email.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Contact.Email.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Email message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Email.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.IEmail} message Email message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Email.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Email message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Email.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Email();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.label = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Email message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Email.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an Email message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 */
                Email.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Email)
                        return object;
                    var message = new $root.signalservice.DataMessage.Contact.Email();
                    if (object.value != null)
                        message.value = String(object.value);
                    switch (object.type) {
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "MOBILE":
                    case 2:
                        message.type = 2;
                        break;
                    case "WORK":
                    case 3:
                        message.type = 3;
                        break;
                    case "CUSTOM":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from an Email message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.Email} message Email
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Email.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.Email.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this Email to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Email.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.Email.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} MOBILE=2 MOBILE value
                 * @property {number} WORK=3 WORK value
                 * @property {number} CUSTOM=4 CUSTOM value
                 */
                Email.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "MOBILE"] = 2;
                    values[valuesById[3] = "WORK"] = 3;
                    values[valuesById[4] = "CUSTOM"] = 4;
                    return values;
                })();

                return Email;
            })();

            Contact.PostalAddress = (function() {

                /**
                 * Properties of a PostalAddress.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IPostalAddress
                 * @property {signalservice.DataMessage.Contact.PostalAddress.Type|null} [type] PostalAddress type
                 * @property {string|null} [label] PostalAddress label
                 * @property {string|null} [street] PostalAddress street
                 * @property {string|null} [pobox] PostalAddress pobox
                 * @property {string|null} [neighborhood] PostalAddress neighborhood
                 * @property {string|null} [city] PostalAddress city
                 * @property {string|null} [region] PostalAddress region
                 * @property {string|null} [postcode] PostalAddress postcode
                 * @property {string|null} [country] PostalAddress country
                 */

                /**
                 * Constructs a new PostalAddress.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a PostalAddress.
                 * @implements IPostalAddress
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IPostalAddress=} [properties] Properties to set
                 */
                function PostalAddress(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PostalAddress type.
                 * @member {signalservice.DataMessage.Contact.PostalAddress.Type} type
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.type = 1;

                /**
                 * PostalAddress label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.label = "";

                /**
                 * PostalAddress street.
                 * @member {string} street
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.street = "";

                /**
                 * PostalAddress pobox.
                 * @member {string} pobox
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.pobox = "";

                /**
                 * PostalAddress neighborhood.
                 * @member {string} neighborhood
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.neighborhood = "";

                /**
                 * PostalAddress city.
                 * @member {string} city
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.city = "";

                /**
                 * PostalAddress region.
                 * @member {string} region
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.region = "";

                /**
                 * PostalAddress postcode.
                 * @member {string} postcode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.postcode = "";

                /**
                 * PostalAddress country.
                 * @member {string} country
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.country = "";

                /**
                 * Encodes the specified PostalAddress message. Does not implicitly {@link signalservice.DataMessage.Contact.PostalAddress.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPostalAddress} message PostalAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostalAddress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Contact.PostalAddress.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                    if (message.street != null && Object.hasOwnProperty.call(message, "street"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.street);
                    if (message.pobox != null && Object.hasOwnProperty.call(message, "pobox"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.pobox);
                    if (message.neighborhood != null && Object.hasOwnProperty.call(message, "neighborhood"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.neighborhood);
                    if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.city);
                    if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.region);
                    if (message.postcode != null && Object.hasOwnProperty.call(message, "postcode"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.postcode);
                    if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.country);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified PostalAddress message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.PostalAddress.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPostalAddress} message PostalAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostalAddress.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PostalAddress message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostalAddress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.PostalAddress();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.label = reader.string();
                            break;
                        case 3:
                            message.street = reader.string();
                            break;
                        case 4:
                            message.pobox = reader.string();
                            break;
                        case 5:
                            message.neighborhood = reader.string();
                            break;
                        case 6:
                            message.city = reader.string();
                            break;
                        case 7:
                            message.region = reader.string();
                            break;
                        case 8:
                            message.postcode = reader.string();
                            break;
                        case 9:
                            message.country = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PostalAddress message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostalAddress.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a PostalAddress message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 */
                PostalAddress.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.PostalAddress)
                        return object;
                    var message = new $root.signalservice.DataMessage.Contact.PostalAddress();
                    switch (object.type) {
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "WORK":
                    case 2:
                        message.type = 2;
                        break;
                    case "CUSTOM":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.street != null)
                        message.street = String(object.street);
                    if (object.pobox != null)
                        message.pobox = String(object.pobox);
                    if (object.neighborhood != null)
                        message.neighborhood = String(object.neighborhood);
                    if (object.city != null)
                        message.city = String(object.city);
                    if (object.region != null)
                        message.region = String(object.region);
                    if (object.postcode != null)
                        message.postcode = String(object.postcode);
                    if (object.country != null)
                        message.country = String(object.country);
                    return message;
                };

                /**
                 * Creates a plain object from a PostalAddress message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.PostalAddress} message PostalAddress
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PostalAddress.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                        object.street = "";
                        object.pobox = "";
                        object.neighborhood = "";
                        object.city = "";
                        object.region = "";
                        object.postcode = "";
                        object.country = "";
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.PostalAddress.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.street != null && message.hasOwnProperty("street"))
                        object.street = message.street;
                    if (message.pobox != null && message.hasOwnProperty("pobox"))
                        object.pobox = message.pobox;
                    if (message.neighborhood != null && message.hasOwnProperty("neighborhood"))
                        object.neighborhood = message.neighborhood;
                    if (message.city != null && message.hasOwnProperty("city"))
                        object.city = message.city;
                    if (message.region != null && message.hasOwnProperty("region"))
                        object.region = message.region;
                    if (message.postcode != null && message.hasOwnProperty("postcode"))
                        object.postcode = message.postcode;
                    if (message.country != null && message.hasOwnProperty("country"))
                        object.country = message.country;
                    return object;
                };

                /**
                 * Converts this PostalAddress to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PostalAddress.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.PostalAddress.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} WORK=2 WORK value
                 * @property {number} CUSTOM=3 CUSTOM value
                 */
                PostalAddress.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "WORK"] = 2;
                    values[valuesById[3] = "CUSTOM"] = 3;
                    return values;
                })();

                return PostalAddress;
            })();

            Contact.Avatar = (function() {

                /**
                 * Properties of an Avatar.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IAvatar
                 * @property {signalservice.IAttachmentPointer|null} [avatar] Avatar avatar
                 * @property {boolean|null} [isProfile] Avatar isProfile
                 */

                /**
                 * Constructs a new Avatar.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents an Avatar.
                 * @implements IAvatar
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IAvatar=} [properties] Properties to set
                 */
                function Avatar(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Avatar avatar.
                 * @member {signalservice.IAttachmentPointer|null|undefined} avatar
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 */
                Avatar.prototype.avatar = null;

                /**
                 * Avatar isProfile.
                 * @member {boolean} isProfile
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 */
                Avatar.prototype.isProfile = false;

                /**
                 * Encodes the specified Avatar message. Does not implicitly {@link signalservice.DataMessage.Contact.Avatar.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.DataMessage.Contact.Avatar.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                        $root.signalservice.AttachmentPointer.encode(message.avatar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.isProfile != null && Object.hasOwnProperty.call(message, "isProfile"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isProfile);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Avatar message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Avatar.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Avatar();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.avatar = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.isProfile = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 */
                Avatar.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Avatar)
                        return object;
                    var message = new $root.signalservice.DataMessage.Contact.Avatar();
                    if (object.avatar != null) {
                        if (typeof object.avatar !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.Avatar.avatar: object expected");
                        message.avatar = $root.signalservice.AttachmentPointer.fromObject(object.avatar);
                    }
                    if (object.isProfile != null)
                        message.isProfile = Boolean(object.isProfile);
                    return message;
                };

                /**
                 * Creates a plain object from an Avatar message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.Avatar} message Avatar
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Avatar.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.avatar = null;
                        object.isProfile = false;
                    }
                    if (message.avatar != null && message.hasOwnProperty("avatar"))
                        object.avatar = $root.signalservice.AttachmentPointer.toObject(message.avatar, options);
                    if (message.isProfile != null && message.hasOwnProperty("isProfile"))
                        object.isProfile = message.isProfile;
                    return object;
                };

                /**
                 * Converts this Avatar to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Avatar.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Avatar;
            })();

            return Contact;
        })();

        DataMessage.Preview = (function() {

            /**
             * Properties of a Preview.
             * @memberof signalservice.DataMessage
             * @interface IPreview
             * @property {string|null} [url] Preview url
             * @property {string|null} [title] Preview title
             * @property {signalservice.IAttachmentPointer|null} [image] Preview image
             * @property {string|null} [description] Preview description
             * @property {Long|null} [date] Preview date
             */

            /**
             * Constructs a new Preview.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Preview.
             * @implements IPreview
             * @constructor
             * @param {signalservice.DataMessage.IPreview=} [properties] Properties to set
             */
            function Preview(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Preview url.
             * @member {string} url
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.url = "";

            /**
             * Preview title.
             * @member {string} title
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.title = "";

            /**
             * Preview image.
             * @member {signalservice.IAttachmentPointer|null|undefined} image
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.image = null;

            /**
             * Preview description.
             * @member {string} description
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.description = "";

            /**
             * Preview date.
             * @member {Long} date
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.date = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Preview message. Does not implicitly {@link signalservice.DataMessage.Preview.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.IPreview} message Preview message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Preview.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Preview.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.signalservice.AttachmentPointer.encode(message.image, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.date != null && Object.hasOwnProperty.call(message, "date"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.date);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Preview message, length delimited. Does not implicitly {@link signalservice.DataMessage.Preview.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.IPreview} message Preview message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Preview.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Preview message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Preview} Preview
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Preview.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Preview();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.title = reader.string();
                        break;
                    case 3:
                        message.image = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.description = reader.string();
                        break;
                    case 5:
                        message.date = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Preview message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Preview} Preview
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Preview.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Preview message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Preview} Preview
             */
            Preview.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Preview)
                    return object;
                var message = new $root.signalservice.DataMessage.Preview();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".signalservice.DataMessage.Preview.image: object expected");
                    message.image = $root.signalservice.AttachmentPointer.fromObject(object.image);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.date != null)
                    if ($util.Long)
                        (message.date = $util.Long.fromValue(object.date)).unsigned = true;
                    else if (typeof object.date === "string")
                        message.date = parseInt(object.date, 10);
                    else if (typeof object.date === "number")
                        message.date = object.date;
                    else if (typeof object.date === "object")
                        message.date = new $util.LongBits(object.date.low >>> 0, object.date.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Preview message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.Preview} message Preview
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Preview.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.image = null;
                    object.description = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.date = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.date = options.longs === String ? "0" : 0;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.signalservice.AttachmentPointer.toObject(message.image, options);
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.date != null && message.hasOwnProperty("date"))
                    if (typeof message.date === "number")
                        object.date = options.longs === String ? String(message.date) : message.date;
                    else
                        object.date = options.longs === String ? $util.Long.prototype.toString.call(message.date) : options.longs === Number ? new $util.LongBits(message.date.low >>> 0, message.date.high >>> 0).toNumber(true) : message.date;
                return object;
            };

            /**
             * Converts this Preview to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Preview
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Preview.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Preview;
        })();

        DataMessage.Sticker = (function() {

            /**
             * Properties of a Sticker.
             * @memberof signalservice.DataMessage
             * @interface ISticker
             * @property {Uint8Array|null} [packId] Sticker packId
             * @property {Uint8Array|null} [packKey] Sticker packKey
             * @property {number|null} [stickerId] Sticker stickerId
             * @property {signalservice.IAttachmentPointer|null} [data] Sticker data
             * @property {string|null} [emoji] Sticker emoji
             */

            /**
             * Constructs a new Sticker.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Sticker.
             * @implements ISticker
             * @constructor
             * @param {signalservice.DataMessage.ISticker=} [properties] Properties to set
             */
            function Sticker(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sticker packId.
             * @member {Uint8Array} packId
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.packId = $util.newBuffer([]);

            /**
             * Sticker packKey.
             * @member {Uint8Array} packKey
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.packKey = $util.newBuffer([]);

            /**
             * Sticker stickerId.
             * @member {number} stickerId
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.stickerId = 0;

            /**
             * Sticker data.
             * @member {signalservice.IAttachmentPointer|null|undefined} data
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.data = null;

            /**
             * Sticker emoji.
             * @member {string} emoji
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.emoji = "";

            /**
             * Encodes the specified Sticker message. Does not implicitly {@link signalservice.DataMessage.Sticker.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Sticker.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.packId != null && Object.hasOwnProperty.call(message, "packId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.packId);
                if (message.packKey != null && Object.hasOwnProperty.call(message, "packKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packKey);
                if (message.stickerId != null && Object.hasOwnProperty.call(message, "stickerId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stickerId);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.signalservice.AttachmentPointer.encode(message.data, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.emoji);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Sticker message, length delimited. Does not implicitly {@link signalservice.DataMessage.Sticker.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Sticker();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packId = reader.bytes();
                        break;
                    case 2:
                        message.packKey = reader.bytes();
                        break;
                    case 3:
                        message.stickerId = reader.uint32();
                        break;
                    case 4:
                        message.data = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.emoji = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Sticker message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Sticker} Sticker
             */
            Sticker.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Sticker)
                    return object;
                var message = new $root.signalservice.DataMessage.Sticker();
                if (object.packId != null)
                    if (typeof object.packId === "string")
                        $util.base64.decode(object.packId, message.packId = $util.newBuffer($util.base64.length(object.packId)), 0);
                    else if (object.packId.length)
                        message.packId = object.packId;
                if (object.packKey != null)
                    if (typeof object.packKey === "string")
                        $util.base64.decode(object.packKey, message.packKey = $util.newBuffer($util.base64.length(object.packKey)), 0);
                    else if (object.packKey.length)
                        message.packKey = object.packKey;
                if (object.stickerId != null)
                    message.stickerId = object.stickerId >>> 0;
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".signalservice.DataMessage.Sticker.data: object expected");
                    message.data = $root.signalservice.AttachmentPointer.fromObject(object.data);
                }
                if (object.emoji != null)
                    message.emoji = String(object.emoji);
                return message;
            };

            /**
             * Creates a plain object from a Sticker message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.Sticker} message Sticker
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sticker.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.packId = "";
                    else {
                        object.packId = [];
                        if (options.bytes !== Array)
                            object.packId = $util.newBuffer(object.packId);
                    }
                    if (options.bytes === String)
                        object.packKey = "";
                    else {
                        object.packKey = [];
                        if (options.bytes !== Array)
                            object.packKey = $util.newBuffer(object.packKey);
                    }
                    object.stickerId = 0;
                    object.data = null;
                    object.emoji = "";
                }
                if (message.packId != null && message.hasOwnProperty("packId"))
                    object.packId = options.bytes === String ? $util.base64.encode(message.packId, 0, message.packId.length) : options.bytes === Array ? Array.prototype.slice.call(message.packId) : message.packId;
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    object.packKey = options.bytes === String ? $util.base64.encode(message.packKey, 0, message.packKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.packKey) : message.packKey;
                if (message.stickerId != null && message.hasOwnProperty("stickerId"))
                    object.stickerId = message.stickerId;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.signalservice.AttachmentPointer.toObject(message.data, options);
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    object.emoji = message.emoji;
                return object;
            };

            /**
             * Converts this Sticker to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sticker.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sticker;
        })();

        DataMessage.Reaction = (function() {

            /**
             * Properties of a Reaction.
             * @memberof signalservice.DataMessage
             * @interface IReaction
             * @property {string|null} [emoji] Reaction emoji
             * @property {boolean|null} [remove] Reaction remove
             * @property {string|null} [targetAuthorUuid] Reaction targetAuthorUuid
             * @property {Long|null} [targetTimestamp] Reaction targetTimestamp
             */

            /**
             * Constructs a new Reaction.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Reaction.
             * @implements IReaction
             * @constructor
             * @param {signalservice.DataMessage.IReaction=} [properties] Properties to set
             */
            function Reaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reaction emoji.
             * @member {string} emoji
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.emoji = "";

            /**
             * Reaction remove.
             * @member {boolean} remove
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.remove = false;

            /**
             * Reaction targetAuthorUuid.
             * @member {string} targetAuthorUuid
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.targetAuthorUuid = "";

            /**
             * Reaction targetTimestamp.
             * @member {Long} targetTimestamp
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.targetTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Reaction message. Does not implicitly {@link signalservice.DataMessage.Reaction.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.IReaction} message Reaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Reaction.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.emoji);
                if (message.remove != null && Object.hasOwnProperty.call(message, "remove"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.remove);
                if (message.targetAuthorUuid != null && Object.hasOwnProperty.call(message, "targetAuthorUuid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetAuthorUuid);
                if (message.targetTimestamp != null && Object.hasOwnProperty.call(message, "targetTimestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetTimestamp);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Reaction message, length delimited. Does not implicitly {@link signalservice.DataMessage.Reaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.IReaction} message Reaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Reaction message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Reaction} Reaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Reaction();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.emoji = reader.string();
                        break;
                    case 2:
                        message.remove = reader.bool();
                        break;
                    case 4:
                        message.targetAuthorUuid = reader.string();
                        break;
                    case 5:
                        message.targetTimestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Reaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Reaction} Reaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Reaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Reaction} Reaction
             */
            Reaction.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Reaction)
                    return object;
                var message = new $root.signalservice.DataMessage.Reaction();
                if (object.emoji != null)
                    message.emoji = String(object.emoji);
                if (object.remove != null)
                    message.remove = Boolean(object.remove);
                if (object.targetAuthorUuid != null)
                    message.targetAuthorUuid = String(object.targetAuthorUuid);
                if (object.targetTimestamp != null)
                    if ($util.Long)
                        (message.targetTimestamp = $util.Long.fromValue(object.targetTimestamp)).unsigned = true;
                    else if (typeof object.targetTimestamp === "string")
                        message.targetTimestamp = parseInt(object.targetTimestamp, 10);
                    else if (typeof object.targetTimestamp === "number")
                        message.targetTimestamp = object.targetTimestamp;
                    else if (typeof object.targetTimestamp === "object")
                        message.targetTimestamp = new $util.LongBits(object.targetTimestamp.low >>> 0, object.targetTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Reaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.Reaction} message Reaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Reaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.emoji = "";
                    object.remove = false;
                    object.targetAuthorUuid = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.targetTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    object.emoji = message.emoji;
                if (message.remove != null && message.hasOwnProperty("remove"))
                    object.remove = message.remove;
                if (message.targetAuthorUuid != null && message.hasOwnProperty("targetAuthorUuid"))
                    object.targetAuthorUuid = message.targetAuthorUuid;
                if (message.targetTimestamp != null && message.hasOwnProperty("targetTimestamp"))
                    if (typeof message.targetTimestamp === "number")
                        object.targetTimestamp = options.longs === String ? String(message.targetTimestamp) : message.targetTimestamp;
                    else
                        object.targetTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.targetTimestamp) : options.longs === Number ? new $util.LongBits(message.targetTimestamp.low >>> 0, message.targetTimestamp.high >>> 0).toNumber(true) : message.targetTimestamp;
                return object;
            };

            /**
             * Converts this Reaction to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Reaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Reaction;
        })();

        DataMessage.Delete = (function() {

            /**
             * Properties of a Delete.
             * @memberof signalservice.DataMessage
             * @interface IDelete
             * @property {Long|null} [targetSentTimestamp] Delete targetSentTimestamp
             */

            /**
             * Constructs a new Delete.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Delete.
             * @implements IDelete
             * @constructor
             * @param {signalservice.DataMessage.IDelete=} [properties] Properties to set
             */
            function Delete(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Delete targetSentTimestamp.
             * @member {Long} targetSentTimestamp
             * @memberof signalservice.DataMessage.Delete
             * @instance
             */
            Delete.prototype.targetSentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Delete message. Does not implicitly {@link signalservice.DataMessage.Delete.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.IDelete} message Delete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Delete.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.Delete.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.targetSentTimestamp != null && Object.hasOwnProperty.call(message, "targetSentTimestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.targetSentTimestamp);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Delete message, length delimited. Does not implicitly {@link signalservice.DataMessage.Delete.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.IDelete} message Delete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Delete.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Delete message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Delete} Delete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Delete.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Delete();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.targetSentTimestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Delete message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Delete} Delete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Delete.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Delete message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Delete} Delete
             */
            Delete.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Delete)
                    return object;
                var message = new $root.signalservice.DataMessage.Delete();
                if (object.targetSentTimestamp != null)
                    if ($util.Long)
                        (message.targetSentTimestamp = $util.Long.fromValue(object.targetSentTimestamp)).unsigned = true;
                    else if (typeof object.targetSentTimestamp === "string")
                        message.targetSentTimestamp = parseInt(object.targetSentTimestamp, 10);
                    else if (typeof object.targetSentTimestamp === "number")
                        message.targetSentTimestamp = object.targetSentTimestamp;
                    else if (typeof object.targetSentTimestamp === "object")
                        message.targetSentTimestamp = new $util.LongBits(object.targetSentTimestamp.low >>> 0, object.targetSentTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Delete message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.Delete} message Delete
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Delete.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.targetSentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetSentTimestamp = options.longs === String ? "0" : 0;
                if (message.targetSentTimestamp != null && message.hasOwnProperty("targetSentTimestamp"))
                    if (typeof message.targetSentTimestamp === "number")
                        object.targetSentTimestamp = options.longs === String ? String(message.targetSentTimestamp) : message.targetSentTimestamp;
                    else
                        object.targetSentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.targetSentTimestamp) : options.longs === Number ? new $util.LongBits(message.targetSentTimestamp.low >>> 0, message.targetSentTimestamp.high >>> 0).toNumber(true) : message.targetSentTimestamp;
                return object;
            };

            /**
             * Converts this Delete to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Delete
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Delete.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Delete;
        })();

        DataMessage.BodyRange = (function() {

            /**
             * Properties of a BodyRange.
             * @memberof signalservice.DataMessage
             * @interface IBodyRange
             * @property {number|null} [start] BodyRange start
             * @property {number|null} [length] BodyRange length
             * @property {string|null} [mentionUuid] BodyRange mentionUuid
             */

            /**
             * Constructs a new BodyRange.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a BodyRange.
             * @implements IBodyRange
             * @constructor
             * @param {signalservice.DataMessage.IBodyRange=} [properties] Properties to set
             */
            function BodyRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BodyRange start.
             * @member {number} start
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.start = 0;

            /**
             * BodyRange length.
             * @member {number} length
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.length = 0;

            /**
             * BodyRange mentionUuid.
             * @member {string} mentionUuid
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.mentionUuid = "";

            /**
             * Encodes the specified BodyRange message. Does not implicitly {@link signalservice.DataMessage.BodyRange.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.IBodyRange} message BodyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BodyRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.BodyRange.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.start);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                if (message.mentionUuid != null && Object.hasOwnProperty.call(message, "mentionUuid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mentionUuid);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified BodyRange message, length delimited. Does not implicitly {@link signalservice.DataMessage.BodyRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.IBodyRange} message BodyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BodyRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BodyRange message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BodyRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.BodyRange();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = reader.uint32();
                        break;
                    case 2:
                        message.length = reader.uint32();
                        break;
                    case 3:
                        message.mentionUuid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BodyRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BodyRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a BodyRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             */
            BodyRange.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.BodyRange)
                    return object;
                var message = new $root.signalservice.DataMessage.BodyRange();
                if (object.start != null)
                    message.start = object.start >>> 0;
                if (object.length != null)
                    message.length = object.length >>> 0;
                if (object.mentionUuid != null)
                    message.mentionUuid = String(object.mentionUuid);
                return message;
            };

            /**
             * Creates a plain object from a BodyRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.BodyRange} message BodyRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BodyRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start = 0;
                    object.length = 0;
                    object.mentionUuid = "";
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = message.start;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                if (message.mentionUuid != null && message.hasOwnProperty("mentionUuid"))
                    object.mentionUuid = message.mentionUuid;
                return object;
            };

            /**
             * Converts this BodyRange to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BodyRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BodyRange;
        })();

        DataMessage.GroupCallUpdate = (function() {

            /**
             * Properties of a GroupCallUpdate.
             * @memberof signalservice.DataMessage
             * @interface IGroupCallUpdate
             * @property {string|null} [eraId] GroupCallUpdate eraId
             */

            /**
             * Constructs a new GroupCallUpdate.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a GroupCallUpdate.
             * @implements IGroupCallUpdate
             * @constructor
             * @param {signalservice.DataMessage.IGroupCallUpdate=} [properties] Properties to set
             */
            function GroupCallUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupCallUpdate eraId.
             * @member {string} eraId
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @instance
             */
            GroupCallUpdate.prototype.eraId = "";

            /**
             * Encodes the specified GroupCallUpdate message. Does not implicitly {@link signalservice.DataMessage.GroupCallUpdate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.IGroupCallUpdate} message GroupCallUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCallUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.GroupCallUpdate.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.eraId != null && Object.hasOwnProperty.call(message, "eraId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.eraId);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified GroupCallUpdate message, length delimited. Does not implicitly {@link signalservice.DataMessage.GroupCallUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.IGroupCallUpdate} message GroupCallUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCallUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupCallUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCallUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.GroupCallUpdate();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eraId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupCallUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCallUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a GroupCallUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             */
            GroupCallUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.GroupCallUpdate)
                    return object;
                var message = new $root.signalservice.DataMessage.GroupCallUpdate();
                if (object.eraId != null)
                    message.eraId = String(object.eraId);
                return message;
            };

            /**
             * Creates a plain object from a GroupCallUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.GroupCallUpdate} message GroupCallUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupCallUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.eraId = "";
                if (message.eraId != null && message.hasOwnProperty("eraId"))
                    object.eraId = message.eraId;
                return object;
            };

            /**
             * Converts this GroupCallUpdate to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupCallUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupCallUpdate;
        })();

        DataMessage.StoryContext = (function() {

            /**
             * Properties of a StoryContext.
             * @memberof signalservice.DataMessage
             * @interface IStoryContext
             * @property {string|null} [authorUuid] StoryContext authorUuid
             * @property {Long|null} [sentTimestamp] StoryContext sentTimestamp
             */

            /**
             * Constructs a new StoryContext.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a StoryContext.
             * @implements IStoryContext
             * @constructor
             * @param {signalservice.DataMessage.IStoryContext=} [properties] Properties to set
             */
            function StoryContext(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoryContext authorUuid.
             * @member {string} authorUuid
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             */
            StoryContext.prototype.authorUuid = "";

            /**
             * StoryContext sentTimestamp.
             * @member {Long} sentTimestamp
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             */
            StoryContext.prototype.sentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified StoryContext message. Does not implicitly {@link signalservice.DataMessage.StoryContext.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.IStoryContext} message StoryContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoryContext.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.StoryContext.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.authorUuid != null && Object.hasOwnProperty.call(message, "authorUuid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorUuid);
                if (message.sentTimestamp != null && Object.hasOwnProperty.call(message, "sentTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sentTimestamp);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified StoryContext message, length delimited. Does not implicitly {@link signalservice.DataMessage.StoryContext.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.IStoryContext} message StoryContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoryContext.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoryContext message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoryContext.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.StoryContext();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.authorUuid = reader.string();
                        break;
                    case 2:
                        message.sentTimestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoryContext message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoryContext.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a StoryContext message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             */
            StoryContext.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.StoryContext)
                    return object;
                var message = new $root.signalservice.DataMessage.StoryContext();
                if (object.authorUuid != null)
                    message.authorUuid = String(object.authorUuid);
                if (object.sentTimestamp != null)
                    if ($util.Long)
                        (message.sentTimestamp = $util.Long.fromValue(object.sentTimestamp)).unsigned = true;
                    else if (typeof object.sentTimestamp === "string")
                        message.sentTimestamp = parseInt(object.sentTimestamp, 10);
                    else if (typeof object.sentTimestamp === "number")
                        message.sentTimestamp = object.sentTimestamp;
                    else if (typeof object.sentTimestamp === "object")
                        message.sentTimestamp = new $util.LongBits(object.sentTimestamp.low >>> 0, object.sentTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a StoryContext message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.StoryContext} message StoryContext
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoryContext.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.authorUuid = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.sentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sentTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.authorUuid != null && message.hasOwnProperty("authorUuid"))
                    object.authorUuid = message.authorUuid;
                if (message.sentTimestamp != null && message.hasOwnProperty("sentTimestamp"))
                    if (typeof message.sentTimestamp === "number")
                        object.sentTimestamp = options.longs === String ? String(message.sentTimestamp) : message.sentTimestamp;
                    else
                        object.sentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimestamp) : options.longs === Number ? new $util.LongBits(message.sentTimestamp.low >>> 0, message.sentTimestamp.high >>> 0).toNumber(true) : message.sentTimestamp;
                return object;
            };

            /**
             * Converts this StoryContext to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoryContext.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoryContext;
        })();

        /**
         * ProtocolVersion enum.
         * @name signalservice.DataMessage.ProtocolVersion
         * @enum {number}
         * @property {number} INITIAL=0 INITIAL value
         * @property {number} MESSAGE_TIMERS=1 MESSAGE_TIMERS value
         * @property {number} VIEW_ONCE=2 VIEW_ONCE value
         * @property {number} VIEW_ONCE_VIDEO=3 VIEW_ONCE_VIDEO value
         * @property {number} REACTIONS=4 REACTIONS value
         * @property {number} CDN_SELECTOR_ATTACHMENTS=5 CDN_SELECTOR_ATTACHMENTS value
         * @property {number} MENTIONS=6 MENTIONS value
         * @property {number} PAYMENTS=7 PAYMENTS value
         * @property {number} CURRENT=7 CURRENT value
         */
        DataMessage.ProtocolVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INITIAL"] = 0;
            values[valuesById[1] = "MESSAGE_TIMERS"] = 1;
            values[valuesById[2] = "VIEW_ONCE"] = 2;
            values[valuesById[3] = "VIEW_ONCE_VIDEO"] = 3;
            values[valuesById[4] = "REACTIONS"] = 4;
            values[valuesById[5] = "CDN_SELECTOR_ATTACHMENTS"] = 5;
            values[valuesById[6] = "MENTIONS"] = 6;
            values[valuesById[7] = "PAYMENTS"] = 7;
            values["CURRENT"] = 7;
            return values;
        })();

        DataMessage.GiftBadge = (function() {

            /**
             * Properties of a GiftBadge.
             * @memberof signalservice.DataMessage
             * @interface IGiftBadge
             * @property {Uint8Array|null} [receiptCredentialPresentation] GiftBadge receiptCredentialPresentation
             */

            /**
             * Constructs a new GiftBadge.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a GiftBadge.
             * @implements IGiftBadge
             * @constructor
             * @param {signalservice.DataMessage.IGiftBadge=} [properties] Properties to set
             */
            function GiftBadge(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftBadge receiptCredentialPresentation.
             * @member {Uint8Array} receiptCredentialPresentation
             * @memberof signalservice.DataMessage.GiftBadge
             * @instance
             */
            GiftBadge.prototype.receiptCredentialPresentation = $util.newBuffer([]);

            /**
             * Encodes the specified GiftBadge message. Does not implicitly {@link signalservice.DataMessage.GiftBadge.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.IGiftBadge} message GiftBadge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftBadge.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.DataMessage.GiftBadge.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.receiptCredentialPresentation != null && Object.hasOwnProperty.call(message, "receiptCredentialPresentation"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.receiptCredentialPresentation);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified GiftBadge message, length delimited. Does not implicitly {@link signalservice.DataMessage.GiftBadge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.IGiftBadge} message GiftBadge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftBadge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftBadge message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftBadge.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.GiftBadge();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.receiptCredentialPresentation = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftBadge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftBadge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a GiftBadge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             */
            GiftBadge.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.GiftBadge)
                    return object;
                var message = new $root.signalservice.DataMessage.GiftBadge();
                if (object.receiptCredentialPresentation != null)
                    if (typeof object.receiptCredentialPresentation === "string")
                        $util.base64.decode(object.receiptCredentialPresentation, message.receiptCredentialPresentation = $util.newBuffer($util.base64.length(object.receiptCredentialPresentation)), 0);
                    else if (object.receiptCredentialPresentation.length)
                        message.receiptCredentialPresentation = object.receiptCredentialPresentation;
                return message;
            };

            /**
             * Creates a plain object from a GiftBadge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.GiftBadge} message GiftBadge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftBadge.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.receiptCredentialPresentation = "";
                    else {
                        object.receiptCredentialPresentation = [];
                        if (options.bytes !== Array)
                            object.receiptCredentialPresentation = $util.newBuffer(object.receiptCredentialPresentation);
                    }
                if (message.receiptCredentialPresentation != null && message.hasOwnProperty("receiptCredentialPresentation"))
                    object.receiptCredentialPresentation = options.bytes === String ? $util.base64.encode(message.receiptCredentialPresentation, 0, message.receiptCredentialPresentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiptCredentialPresentation) : message.receiptCredentialPresentation;
                return object;
            };

            /**
             * Converts this GiftBadge to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.GiftBadge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftBadge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GiftBadge;
        })();

        return DataMessage;
    })();

    signalservice.NullMessage = (function() {

        /**
         * Properties of a NullMessage.
         * @memberof signalservice
         * @interface INullMessage
         * @property {Uint8Array|null} [padding] NullMessage padding
         */

        /**
         * Constructs a new NullMessage.
         * @memberof signalservice
         * @classdesc Represents a NullMessage.
         * @implements INullMessage
         * @constructor
         * @param {signalservice.INullMessage=} [properties] Properties to set
         */
        function NullMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NullMessage padding.
         * @member {Uint8Array} padding
         * @memberof signalservice.NullMessage
         * @instance
         */
        NullMessage.prototype.padding = $util.newBuffer([]);

        /**
         * Encodes the specified NullMessage message. Does not implicitly {@link signalservice.NullMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.INullMessage} message NullMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NullMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.NullMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.padding);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified NullMessage message, length delimited. Does not implicitly {@link signalservice.NullMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.INullMessage} message NullMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NullMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NullMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.NullMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.NullMessage} NullMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NullMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.NullMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.padding = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NullMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.NullMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.NullMessage} NullMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NullMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a NullMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.NullMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.NullMessage} NullMessage
         */
        NullMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.NullMessage)
                return object;
            var message = new $root.signalservice.NullMessage();
            if (object.padding != null)
                if (typeof object.padding === "string")
                    $util.base64.decode(object.padding, message.padding = $util.newBuffer($util.base64.length(object.padding)), 0);
                else if (object.padding.length)
                    message.padding = object.padding;
            return message;
        };

        /**
         * Creates a plain object from a NullMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.NullMessage} message NullMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NullMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.padding = "";
                else {
                    object.padding = [];
                    if (options.bytes !== Array)
                        object.padding = $util.newBuffer(object.padding);
                }
            if (message.padding != null && message.hasOwnProperty("padding"))
                object.padding = options.bytes === String ? $util.base64.encode(message.padding, 0, message.padding.length) : options.bytes === Array ? Array.prototype.slice.call(message.padding) : message.padding;
            return object;
        };

        /**
         * Converts this NullMessage to JSON.
         * @function toJSON
         * @memberof signalservice.NullMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NullMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NullMessage;
    })();

    signalservice.ReceiptMessage = (function() {

        /**
         * Properties of a ReceiptMessage.
         * @memberof signalservice
         * @interface IReceiptMessage
         * @property {signalservice.ReceiptMessage.Type|null} [type] ReceiptMessage type
         * @property {Array.<Long>|null} [timestamp] ReceiptMessage timestamp
         */

        /**
         * Constructs a new ReceiptMessage.
         * @memberof signalservice
         * @classdesc Represents a ReceiptMessage.
         * @implements IReceiptMessage
         * @constructor
         * @param {signalservice.IReceiptMessage=} [properties] Properties to set
         */
        function ReceiptMessage(properties) {
            this.timestamp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiptMessage type.
         * @member {signalservice.ReceiptMessage.Type} type
         * @memberof signalservice.ReceiptMessage
         * @instance
         */
        ReceiptMessage.prototype.type = 0;

        /**
         * ReceiptMessage timestamp.
         * @member {Array.<Long>} timestamp
         * @memberof signalservice.ReceiptMessage
         * @instance
         */
        ReceiptMessage.prototype.timestamp = $util.emptyArray;

        /**
         * Encodes the specified ReceiptMessage message. Does not implicitly {@link signalservice.ReceiptMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.IReceiptMessage} message ReceiptMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReceiptMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ReceiptMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.timestamp != null && message.timestamp.length)
                for (var i = 0; i < message.timestamp.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp[i]);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ReceiptMessage message, length delimited. Does not implicitly {@link signalservice.ReceiptMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.IReceiptMessage} message ReceiptMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReceiptMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReceiptMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiptMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ReceiptMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.timestamp && message.timestamp.length))
                        message.timestamp = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.timestamp.push(reader.uint64());
                    } else
                        message.timestamp.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReceiptMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiptMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ReceiptMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         */
        ReceiptMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ReceiptMessage)
                return object;
            var message = new $root.signalservice.ReceiptMessage();
            switch (object.type) {
            case "DELIVERY":
            case 0:
                message.type = 0;
                break;
            case "READ":
            case 1:
                message.type = 1;
                break;
            case "VIEWED":
            case 2:
                message.type = 2;
                break;
            }
            if (object.timestamp) {
                if (!Array.isArray(object.timestamp))
                    throw TypeError(".signalservice.ReceiptMessage.timestamp: array expected");
                message.timestamp = [];
                for (var i = 0; i < object.timestamp.length; ++i)
                    if ($util.Long)
                        (message.timestamp[i] = $util.Long.fromValue(object.timestamp[i])).unsigned = true;
                    else if (typeof object.timestamp[i] === "string")
                        message.timestamp[i] = parseInt(object.timestamp[i], 10);
                    else if (typeof object.timestamp[i] === "number")
                        message.timestamp[i] = object.timestamp[i];
                    else if (typeof object.timestamp[i] === "object")
                        message.timestamp[i] = new $util.LongBits(object.timestamp[i].low >>> 0, object.timestamp[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReceiptMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.ReceiptMessage} message ReceiptMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReceiptMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.timestamp = [];
            if (options.defaults)
                object.type = options.enums === String ? "DELIVERY" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.ReceiptMessage.Type[message.type] : message.type;
            if (message.timestamp && message.timestamp.length) {
                object.timestamp = [];
                for (var j = 0; j < message.timestamp.length; ++j)
                    if (typeof message.timestamp[j] === "number")
                        object.timestamp[j] = options.longs === String ? String(message.timestamp[j]) : message.timestamp[j];
                    else
                        object.timestamp[j] = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp[j]) : options.longs === Number ? new $util.LongBits(message.timestamp[j].low >>> 0, message.timestamp[j].high >>> 0).toNumber(true) : message.timestamp[j];
            }
            return object;
        };

        /**
         * Converts this ReceiptMessage to JSON.
         * @function toJSON
         * @memberof signalservice.ReceiptMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReceiptMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name signalservice.ReceiptMessage.Type
         * @enum {number}
         * @property {number} DELIVERY=0 DELIVERY value
         * @property {number} READ=1 READ value
         * @property {number} VIEWED=2 VIEWED value
         */
        ReceiptMessage.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DELIVERY"] = 0;
            values[valuesById[1] = "READ"] = 1;
            values[valuesById[2] = "VIEWED"] = 2;
            return values;
        })();

        return ReceiptMessage;
    })();

    signalservice.TypingMessage = (function() {

        /**
         * Properties of a TypingMessage.
         * @memberof signalservice
         * @interface ITypingMessage
         * @property {Long|null} [timestamp] TypingMessage timestamp
         * @property {signalservice.TypingMessage.Action|null} [action] TypingMessage action
         * @property {Uint8Array|null} [groupId] TypingMessage groupId
         */

        /**
         * Constructs a new TypingMessage.
         * @memberof signalservice
         * @classdesc Represents a TypingMessage.
         * @implements ITypingMessage
         * @constructor
         * @param {signalservice.ITypingMessage=} [properties] Properties to set
         */
        function TypingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypingMessage timestamp.
         * @member {Long} timestamp
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TypingMessage action.
         * @member {signalservice.TypingMessage.Action} action
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.action = 0;

        /**
         * TypingMessage groupId.
         * @member {Uint8Array} groupId
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.groupId = $util.newBuffer([]);

        /**
         * Encodes the specified TypingMessage message. Does not implicitly {@link signalservice.TypingMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.ITypingMessage} message TypingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.TypingMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupId);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified TypingMessage message, length delimited. Does not implicitly {@link signalservice.TypingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.ITypingMessage} message TypingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.TypingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.TypingMessage} TypingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TypingMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.action = reader.int32();
                    break;
                case 3:
                    message.groupId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.TypingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.TypingMessage} TypingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a TypingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.TypingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.TypingMessage} TypingMessage
         */
        TypingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.TypingMessage)
                return object;
            var message = new $root.signalservice.TypingMessage();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            switch (object.action) {
            case "STARTED":
            case 0:
                message.action = 0;
                break;
            case "STOPPED":
            case 1:
                message.action = 1;
                break;
            }
            if (object.groupId != null)
                if (typeof object.groupId === "string")
                    $util.base64.decode(object.groupId, message.groupId = $util.newBuffer($util.base64.length(object.groupId)), 0);
                else if (object.groupId.length)
                    message.groupId = object.groupId;
            return message;
        };

        /**
         * Creates a plain object from a TypingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.TypingMessage} message TypingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.action = options.enums === String ? "STARTED" : 0;
                if (options.bytes === String)
                    object.groupId = "";
                else {
                    object.groupId = [];
                    if (options.bytes !== Array)
                        object.groupId = $util.newBuffer(object.groupId);
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.signalservice.TypingMessage.Action[message.action] : message.action;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = options.bytes === String ? $util.base64.encode(message.groupId, 0, message.groupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupId) : message.groupId;
            return object;
        };

        /**
         * Converts this TypingMessage to JSON.
         * @function toJSON
         * @memberof signalservice.TypingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name signalservice.TypingMessage.Action
         * @enum {number}
         * @property {number} STARTED=0 STARTED value
         * @property {number} STOPPED=1 STOPPED value
         */
        TypingMessage.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STARTED"] = 0;
            values[valuesById[1] = "STOPPED"] = 1;
            return values;
        })();

        return TypingMessage;
    })();

    signalservice.StoryMessage = (function() {

        /**
         * Properties of a StoryMessage.
         * @memberof signalservice
         * @interface IStoryMessage
         * @property {Uint8Array|null} [profileKey] StoryMessage profileKey
         * @property {signalservice.IGroupContextV2|null} [group] StoryMessage group
         * @property {signalservice.IAttachmentPointer|null} [fileAttachment] StoryMessage fileAttachment
         * @property {signalservice.ITextAttachment|null} [textAttachment] StoryMessage textAttachment
         * @property {boolean|null} [allowsReplies] StoryMessage allowsReplies
         */

        /**
         * Constructs a new StoryMessage.
         * @memberof signalservice
         * @classdesc Represents a StoryMessage.
         * @implements IStoryMessage
         * @constructor
         * @param {signalservice.IStoryMessage=} [properties] Properties to set
         */
        function StoryMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StoryMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * StoryMessage group.
         * @member {signalservice.IGroupContextV2|null|undefined} group
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.group = null;

        /**
         * StoryMessage fileAttachment.
         * @member {signalservice.IAttachmentPointer|null|undefined} fileAttachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.fileAttachment = null;

        /**
         * StoryMessage textAttachment.
         * @member {signalservice.ITextAttachment|null|undefined} textAttachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.textAttachment = null;

        /**
         * StoryMessage allowsReplies.
         * @member {boolean} allowsReplies
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.allowsReplies = false;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * StoryMessage attachment.
         * @member {"fileAttachment"|"textAttachment"|undefined} attachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        Object.defineProperty(StoryMessage.prototype, "attachment", {
            get: $util.oneOfGetter($oneOfFields = ["fileAttachment", "textAttachment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified StoryMessage message. Does not implicitly {@link signalservice.StoryMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.IStoryMessage} message StoryMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StoryMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.profileKey);
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                $root.signalservice.GroupContextV2.encode(message.group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.fileAttachment != null && Object.hasOwnProperty.call(message, "fileAttachment"))
                $root.signalservice.AttachmentPointer.encode(message.fileAttachment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.textAttachment != null && Object.hasOwnProperty.call(message, "textAttachment"))
                $root.signalservice.TextAttachment.encode(message.textAttachment, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.allowsReplies != null && Object.hasOwnProperty.call(message, "allowsReplies"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.allowsReplies);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StoryMessage message, length delimited. Does not implicitly {@link signalservice.StoryMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.IStoryMessage} message StoryMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StoryMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StoryMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StoryMessage} StoryMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StoryMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.profileKey = reader.bytes();
                    break;
                case 2:
                    message.group = $root.signalservice.GroupContextV2.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.fileAttachment = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.textAttachment = $root.signalservice.TextAttachment.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.allowsReplies = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StoryMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StoryMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StoryMessage} StoryMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StoryMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StoryMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StoryMessage} StoryMessage
         */
        StoryMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StoryMessage)
                return object;
            var message = new $root.signalservice.StoryMessage();
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".signalservice.StoryMessage.group: object expected");
                message.group = $root.signalservice.GroupContextV2.fromObject(object.group);
            }
            if (object.fileAttachment != null) {
                if (typeof object.fileAttachment !== "object")
                    throw TypeError(".signalservice.StoryMessage.fileAttachment: object expected");
                message.fileAttachment = $root.signalservice.AttachmentPointer.fromObject(object.fileAttachment);
            }
            if (object.textAttachment != null) {
                if (typeof object.textAttachment !== "object")
                    throw TypeError(".signalservice.StoryMessage.textAttachment: object expected");
                message.textAttachment = $root.signalservice.TextAttachment.fromObject(object.textAttachment);
            }
            if (object.allowsReplies != null)
                message.allowsReplies = Boolean(object.allowsReplies);
            return message;
        };

        /**
         * Creates a plain object from a StoryMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.StoryMessage} message StoryMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StoryMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.group = null;
                object.allowsReplies = false;
            }
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.signalservice.GroupContextV2.toObject(message.group, options);
            if (message.fileAttachment != null && message.hasOwnProperty("fileAttachment")) {
                object.fileAttachment = $root.signalservice.AttachmentPointer.toObject(message.fileAttachment, options);
                if (options.oneofs)
                    object.attachment = "fileAttachment";
            }
            if (message.textAttachment != null && message.hasOwnProperty("textAttachment")) {
                object.textAttachment = $root.signalservice.TextAttachment.toObject(message.textAttachment, options);
                if (options.oneofs)
                    object.attachment = "textAttachment";
            }
            if (message.allowsReplies != null && message.hasOwnProperty("allowsReplies"))
                object.allowsReplies = message.allowsReplies;
            return object;
        };

        /**
         * Converts this StoryMessage to JSON.
         * @function toJSON
         * @memberof signalservice.StoryMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StoryMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StoryMessage;
    })();

    signalservice.TextAttachment = (function() {

        /**
         * Properties of a TextAttachment.
         * @memberof signalservice
         * @interface ITextAttachment
         * @property {string|null} [text] TextAttachment text
         * @property {signalservice.TextAttachment.Style|null} [textStyle] TextAttachment textStyle
         * @property {number|null} [textForegroundColor] TextAttachment textForegroundColor
         * @property {number|null} [textBackgroundColor] TextAttachment textBackgroundColor
         * @property {signalservice.DataMessage.IPreview|null} [preview] TextAttachment preview
         * @property {signalservice.TextAttachment.IGradient|null} [gradient] TextAttachment gradient
         * @property {number|null} [color] TextAttachment color
         */

        /**
         * Constructs a new TextAttachment.
         * @memberof signalservice
         * @classdesc Represents a TextAttachment.
         * @implements ITextAttachment
         * @constructor
         * @param {signalservice.ITextAttachment=} [properties] Properties to set
         */
        function TextAttachment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextAttachment text.
         * @member {string} text
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.text = "";

        /**
         * TextAttachment textStyle.
         * @member {signalservice.TextAttachment.Style} textStyle
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textStyle = 0;

        /**
         * TextAttachment textForegroundColor.
         * @member {number} textForegroundColor
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textForegroundColor = 0;

        /**
         * TextAttachment textBackgroundColor.
         * @member {number} textBackgroundColor
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textBackgroundColor = 0;

        /**
         * TextAttachment preview.
         * @member {signalservice.DataMessage.IPreview|null|undefined} preview
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.preview = null;

        /**
         * TextAttachment gradient.
         * @member {signalservice.TextAttachment.IGradient|null|undefined} gradient
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.gradient = null;

        /**
         * TextAttachment color.
         * @member {number|null|undefined} color
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.color = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TextAttachment background.
         * @member {"gradient"|"color"|undefined} background
         * @memberof signalservice.TextAttachment
         * @instance
         */
        Object.defineProperty(TextAttachment.prototype, "background", {
            get: $util.oneOfGetter($oneOfFields = ["gradient", "color"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified TextAttachment message. Does not implicitly {@link signalservice.TextAttachment.verify|verify} messages.
         * @function encode
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.ITextAttachment} message TextAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextAttachment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.TextAttachment.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.textStyle != null && Object.hasOwnProperty.call(message, "textStyle"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.textStyle);
            if (message.textForegroundColor != null && Object.hasOwnProperty.call(message, "textForegroundColor"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.textForegroundColor);
            if (message.textBackgroundColor != null && Object.hasOwnProperty.call(message, "textBackgroundColor"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.textBackgroundColor);
            if (message.preview != null && Object.hasOwnProperty.call(message, "preview"))
                $root.signalservice.DataMessage.Preview.encode(message.preview, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.gradient != null && Object.hasOwnProperty.call(message, "gradient"))
                $root.signalservice.TextAttachment.Gradient.encode(message.gradient, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.color);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified TextAttachment message, length delimited. Does not implicitly {@link signalservice.TextAttachment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.ITextAttachment} message TextAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextAttachment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextAttachment message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.TextAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.TextAttachment} TextAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextAttachment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TextAttachment();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.textStyle = reader.int32();
                    break;
                case 3:
                    message.textForegroundColor = reader.uint32();
                    break;
                case 4:
                    message.textBackgroundColor = reader.uint32();
                    break;
                case 5:
                    message.preview = $root.signalservice.DataMessage.Preview.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.gradient = $root.signalservice.TextAttachment.Gradient.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.color = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextAttachment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.TextAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.TextAttachment} TextAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextAttachment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a TextAttachment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.TextAttachment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.TextAttachment} TextAttachment
         */
        TextAttachment.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.TextAttachment)
                return object;
            var message = new $root.signalservice.TextAttachment();
            if (object.text != null)
                message.text = String(object.text);
            switch (object.textStyle) {
            case "DEFAULT":
            case 0:
                message.textStyle = 0;
                break;
            case "REGULAR":
            case 1:
                message.textStyle = 1;
                break;
            case "BOLD":
            case 2:
                message.textStyle = 2;
                break;
            case "SERIF":
            case 3:
                message.textStyle = 3;
                break;
            case "SCRIPT":
            case 4:
                message.textStyle = 4;
                break;
            case "CONDENSED":
            case 5:
                message.textStyle = 5;
                break;
            }
            if (object.textForegroundColor != null)
                message.textForegroundColor = object.textForegroundColor >>> 0;
            if (object.textBackgroundColor != null)
                message.textBackgroundColor = object.textBackgroundColor >>> 0;
            if (object.preview != null) {
                if (typeof object.preview !== "object")
                    throw TypeError(".signalservice.TextAttachment.preview: object expected");
                message.preview = $root.signalservice.DataMessage.Preview.fromObject(object.preview);
            }
            if (object.gradient != null) {
                if (typeof object.gradient !== "object")
                    throw TypeError(".signalservice.TextAttachment.gradient: object expected");
                message.gradient = $root.signalservice.TextAttachment.Gradient.fromObject(object.gradient);
            }
            if (object.color != null)
                message.color = object.color >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TextAttachment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.TextAttachment} message TextAttachment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextAttachment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.text = "";
                object.textStyle = options.enums === String ? "DEFAULT" : 0;
                object.textForegroundColor = 0;
                object.textBackgroundColor = 0;
                object.preview = null;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.textStyle != null && message.hasOwnProperty("textStyle"))
                object.textStyle = options.enums === String ? $root.signalservice.TextAttachment.Style[message.textStyle] : message.textStyle;
            if (message.textForegroundColor != null && message.hasOwnProperty("textForegroundColor"))
                object.textForegroundColor = message.textForegroundColor;
            if (message.textBackgroundColor != null && message.hasOwnProperty("textBackgroundColor"))
                object.textBackgroundColor = message.textBackgroundColor;
            if (message.preview != null && message.hasOwnProperty("preview"))
                object.preview = $root.signalservice.DataMessage.Preview.toObject(message.preview, options);
            if (message.gradient != null && message.hasOwnProperty("gradient")) {
                object.gradient = $root.signalservice.TextAttachment.Gradient.toObject(message.gradient, options);
                if (options.oneofs)
                    object.background = "gradient";
            }
            if (message.color != null && message.hasOwnProperty("color")) {
                object.color = message.color;
                if (options.oneofs)
                    object.background = "color";
            }
            return object;
        };

        /**
         * Converts this TextAttachment to JSON.
         * @function toJSON
         * @memberof signalservice.TextAttachment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextAttachment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Style enum.
         * @name signalservice.TextAttachment.Style
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} REGULAR=1 REGULAR value
         * @property {number} BOLD=2 BOLD value
         * @property {number} SERIF=3 SERIF value
         * @property {number} SCRIPT=4 SCRIPT value
         * @property {number} CONDENSED=5 CONDENSED value
         */
        TextAttachment.Style = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "REGULAR"] = 1;
            values[valuesById[2] = "BOLD"] = 2;
            values[valuesById[3] = "SERIF"] = 3;
            values[valuesById[4] = "SCRIPT"] = 4;
            values[valuesById[5] = "CONDENSED"] = 5;
            return values;
        })();

        TextAttachment.Gradient = (function() {

            /**
             * Properties of a Gradient.
             * @memberof signalservice.TextAttachment
             * @interface IGradient
             * @property {number|null} [startColor] Gradient startColor
             * @property {number|null} [endColor] Gradient endColor
             * @property {number|null} [angle] Gradient angle
             */

            /**
             * Constructs a new Gradient.
             * @memberof signalservice.TextAttachment
             * @classdesc Represents a Gradient.
             * @implements IGradient
             * @constructor
             * @param {signalservice.TextAttachment.IGradient=} [properties] Properties to set
             */
            function Gradient(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Gradient startColor.
             * @member {number} startColor
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.startColor = 0;

            /**
             * Gradient endColor.
             * @member {number} endColor
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.endColor = 0;

            /**
             * Gradient angle.
             * @member {number} angle
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.angle = 0;

            /**
             * Encodes the specified Gradient message. Does not implicitly {@link signalservice.TextAttachment.Gradient.verify|verify} messages.
             * @function encode
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.IGradient} message Gradient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Gradient.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.TextAttachment.Gradient.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.startColor != null && Object.hasOwnProperty.call(message, "startColor"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.startColor);
                if (message.endColor != null && Object.hasOwnProperty.call(message, "endColor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.endColor);
                if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.angle);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Gradient message, length delimited. Does not implicitly {@link signalservice.TextAttachment.Gradient.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.IGradient} message Gradient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Gradient.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Gradient message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Gradient.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TextAttachment.Gradient();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startColor = reader.uint32();
                        break;
                    case 2:
                        message.endColor = reader.uint32();
                        break;
                    case 3:
                        message.angle = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Gradient message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Gradient.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Gradient message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             */
            Gradient.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.TextAttachment.Gradient)
                    return object;
                var message = new $root.signalservice.TextAttachment.Gradient();
                if (object.startColor != null)
                    message.startColor = object.startColor >>> 0;
                if (object.endColor != null)
                    message.endColor = object.endColor >>> 0;
                if (object.angle != null)
                    message.angle = object.angle >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Gradient message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.Gradient} message Gradient
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Gradient.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.startColor = 0;
                    object.endColor = 0;
                    object.angle = 0;
                }
                if (message.startColor != null && message.hasOwnProperty("startColor"))
                    object.startColor = message.startColor;
                if (message.endColor != null && message.hasOwnProperty("endColor"))
                    object.endColor = message.endColor;
                if (message.angle != null && message.hasOwnProperty("angle"))
                    object.angle = message.angle;
                return object;
            };

            /**
             * Converts this Gradient to JSON.
             * @function toJSON
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Gradient.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Gradient;
        })();

        return TextAttachment;
    })();

    signalservice.Verified = (function() {

        /**
         * Properties of a Verified.
         * @memberof signalservice
         * @interface IVerified
         * @property {string|null} [destination] Verified destination
         * @property {string|null} [destinationUuid] Verified destinationUuid
         * @property {Uint8Array|null} [identityKey] Verified identityKey
         * @property {signalservice.Verified.State|null} [state] Verified state
         * @property {Uint8Array|null} [nullMessage] Verified nullMessage
         */

        /**
         * Constructs a new Verified.
         * @memberof signalservice
         * @classdesc Represents a Verified.
         * @implements IVerified
         * @constructor
         * @param {signalservice.IVerified=} [properties] Properties to set
         */
        function Verified(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Verified destination.
         * @member {string} destination
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.destination = "";

        /**
         * Verified destinationUuid.
         * @member {string} destinationUuid
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.destinationUuid = "";

        /**
         * Verified identityKey.
         * @member {Uint8Array} identityKey
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.identityKey = $util.newBuffer([]);

        /**
         * Verified state.
         * @member {signalservice.Verified.State} state
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.state = 0;

        /**
         * Verified nullMessage.
         * @member {Uint8Array} nullMessage
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.nullMessage = $util.newBuffer([]);

        /**
         * Encodes the specified Verified message. Does not implicitly {@link signalservice.Verified.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.IVerified} message Verified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Verified.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.Verified.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identityKey);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            if (message.nullMessage != null && Object.hasOwnProperty.call(message, "nullMessage"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nullMessage);
            if (message.destinationUuid != null && Object.hasOwnProperty.call(message, "destinationUuid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationUuid);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified Verified message, length delimited. Does not implicitly {@link signalservice.Verified.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.IVerified} message Verified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Verified.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Verified message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Verified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Verified} Verified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Verified.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Verified();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destination = reader.string();
                    break;
                case 5:
                    message.destinationUuid = reader.string();
                    break;
                case 2:
                    message.identityKey = reader.bytes();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.nullMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Verified message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Verified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Verified} Verified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Verified.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a Verified message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Verified
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Verified} Verified
         */
        Verified.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Verified)
                return object;
            var message = new $root.signalservice.Verified();
            if (object.destination != null)
                message.destination = String(object.destination);
            if (object.destinationUuid != null)
                message.destinationUuid = String(object.destinationUuid);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            switch (object.state) {
            case "DEFAULT":
            case 0:
                message.state = 0;
                break;
            case "VERIFIED":
            case 1:
                message.state = 1;
                break;
            case "UNVERIFIED":
            case 2:
                message.state = 2;
                break;
            }
            if (object.nullMessage != null)
                if (typeof object.nullMessage === "string")
                    $util.base64.decode(object.nullMessage, message.nullMessage = $util.newBuffer($util.base64.length(object.nullMessage)), 0);
                else if (object.nullMessage.length)
                    message.nullMessage = object.nullMessage;
            return message;
        };

        /**
         * Creates a plain object from a Verified message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.Verified} message Verified
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Verified.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.destination = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                object.state = options.enums === String ? "DEFAULT" : 0;
                if (options.bytes === String)
                    object.nullMessage = "";
                else {
                    object.nullMessage = [];
                    if (options.bytes !== Array)
                        object.nullMessage = $util.newBuffer(object.nullMessage);
                }
                object.destinationUuid = "";
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = message.destination;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.signalservice.Verified.State[message.state] : message.state;
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage"))
                object.nullMessage = options.bytes === String ? $util.base64.encode(message.nullMessage, 0, message.nullMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.nullMessage) : message.nullMessage;
            if (message.destinationUuid != null && message.hasOwnProperty("destinationUuid"))
                object.destinationUuid = message.destinationUuid;
            return object;
        };

        /**
         * Converts this Verified to JSON.
         * @function toJSON
         * @memberof signalservice.Verified
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Verified.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * State enum.
         * @name signalservice.Verified.State
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} VERIFIED=1 VERIFIED value
         * @property {number} UNVERIFIED=2 UNVERIFIED value
         */
        Verified.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "VERIFIED"] = 1;
            values[valuesById[2] = "UNVERIFIED"] = 2;
            return values;
        })();

        return Verified;
    })();

    signalservice.SyncMessage = (function() {

        /**
         * Properties of a SyncMessage.
         * @memberof signalservice
         * @interface ISyncMessage
         * @property {signalservice.SyncMessage.ISent|null} [sent] SyncMessage sent
         * @property {signalservice.SyncMessage.IContacts|null} [contacts] SyncMessage contacts
         * @property {signalservice.SyncMessage.IGroups|null} [groups] SyncMessage groups
         * @property {signalservice.SyncMessage.IRequest|null} [request] SyncMessage request
         * @property {Array.<signalservice.SyncMessage.IRead>|null} [read] SyncMessage read
         * @property {signalservice.SyncMessage.IBlocked|null} [blocked] SyncMessage blocked
         * @property {signalservice.IVerified|null} [verified] SyncMessage verified
         * @property {signalservice.SyncMessage.IConfiguration|null} [configuration] SyncMessage configuration
         * @property {Uint8Array|null} [padding] SyncMessage padding
         * @property {Array.<signalservice.SyncMessage.IStickerPackOperation>|null} [stickerPackOperation] SyncMessage stickerPackOperation
         * @property {signalservice.SyncMessage.IViewOnceOpen|null} [viewOnceOpen] SyncMessage viewOnceOpen
         * @property {signalservice.SyncMessage.IFetchLatest|null} [fetchLatest] SyncMessage fetchLatest
         * @property {signalservice.SyncMessage.IKeys|null} [keys] SyncMessage keys
         * @property {signalservice.SyncMessage.IMessageRequestResponse|null} [messageRequestResponse] SyncMessage messageRequestResponse
         * @property {Array.<signalservice.SyncMessage.IViewed>|null} [viewed] SyncMessage viewed
         * @property {signalservice.SyncMessage.IPniIdentity|null} [pniIdentity] SyncMessage pniIdentity
         * @property {signalservice.SyncMessage.IPniChangeNumber|null} [pniChangeNumber] SyncMessage pniChangeNumber
         */

        /**
         * Constructs a new SyncMessage.
         * @memberof signalservice
         * @classdesc Represents a SyncMessage.
         * @implements ISyncMessage
         * @constructor
         * @param {signalservice.ISyncMessage=} [properties] Properties to set
         */
        function SyncMessage(properties) {
            this.read = [];
            this.stickerPackOperation = [];
            this.viewed = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncMessage sent.
         * @member {signalservice.SyncMessage.ISent|null|undefined} sent
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.sent = null;

        /**
         * SyncMessage contacts.
         * @member {signalservice.SyncMessage.IContacts|null|undefined} contacts
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.contacts = null;

        /**
         * SyncMessage groups.
         * @member {signalservice.SyncMessage.IGroups|null|undefined} groups
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.groups = null;

        /**
         * SyncMessage request.
         * @member {signalservice.SyncMessage.IRequest|null|undefined} request
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.request = null;

        /**
         * SyncMessage read.
         * @member {Array.<signalservice.SyncMessage.IRead>} read
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.read = $util.emptyArray;

        /**
         * SyncMessage blocked.
         * @member {signalservice.SyncMessage.IBlocked|null|undefined} blocked
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.blocked = null;

        /**
         * SyncMessage verified.
         * @member {signalservice.IVerified|null|undefined} verified
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.verified = null;

        /**
         * SyncMessage configuration.
         * @member {signalservice.SyncMessage.IConfiguration|null|undefined} configuration
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.configuration = null;

        /**
         * SyncMessage padding.
         * @member {Uint8Array} padding
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.padding = $util.newBuffer([]);

        /**
         * SyncMessage stickerPackOperation.
         * @member {Array.<signalservice.SyncMessage.IStickerPackOperation>} stickerPackOperation
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.stickerPackOperation = $util.emptyArray;

        /**
         * SyncMessage viewOnceOpen.
         * @member {signalservice.SyncMessage.IViewOnceOpen|null|undefined} viewOnceOpen
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.viewOnceOpen = null;

        /**
         * SyncMessage fetchLatest.
         * @member {signalservice.SyncMessage.IFetchLatest|null|undefined} fetchLatest
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.fetchLatest = null;

        /**
         * SyncMessage keys.
         * @member {signalservice.SyncMessage.IKeys|null|undefined} keys
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.keys = null;

        /**
         * SyncMessage messageRequestResponse.
         * @member {signalservice.SyncMessage.IMessageRequestResponse|null|undefined} messageRequestResponse
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.messageRequestResponse = null;

        /**
         * SyncMessage viewed.
         * @member {Array.<signalservice.SyncMessage.IViewed>} viewed
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.viewed = $util.emptyArray;

        /**
         * SyncMessage pniIdentity.
         * @member {signalservice.SyncMessage.IPniIdentity|null|undefined} pniIdentity
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.pniIdentity = null;

        /**
         * SyncMessage pniChangeNumber.
         * @member {signalservice.SyncMessage.IPniChangeNumber|null|undefined} pniChangeNumber
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.pniChangeNumber = null;

        /**
         * Encodes the specified SyncMessage message. Does not implicitly {@link signalservice.SyncMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.SyncMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.sent != null && Object.hasOwnProperty.call(message, "sent"))
                $root.signalservice.SyncMessage.Sent.encode(message.sent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contacts != null && Object.hasOwnProperty.call(message, "contacts"))
                $root.signalservice.SyncMessage.Contacts.encode(message.contacts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.groups != null && Object.hasOwnProperty.call(message, "groups"))
                $root.signalservice.SyncMessage.Groups.encode(message.groups, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                $root.signalservice.SyncMessage.Request.encode(message.request, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.read != null && message.read.length)
                for (var i = 0; i < message.read.length; ++i)
                    $root.signalservice.SyncMessage.Read.encode(message.read[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                $root.signalservice.SyncMessage.Blocked.encode(message.blocked, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.verified != null && Object.hasOwnProperty.call(message, "verified"))
                $root.signalservice.Verified.encode(message.verified, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.padding);
            if (message.configuration != null && Object.hasOwnProperty.call(message, "configuration"))
                $root.signalservice.SyncMessage.Configuration.encode(message.configuration, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.stickerPackOperation != null && message.stickerPackOperation.length)
                for (var i = 0; i < message.stickerPackOperation.length; ++i)
                    $root.signalservice.SyncMessage.StickerPackOperation.encode(message.stickerPackOperation[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.viewOnceOpen != null && Object.hasOwnProperty.call(message, "viewOnceOpen"))
                $root.signalservice.SyncMessage.ViewOnceOpen.encode(message.viewOnceOpen, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.fetchLatest != null && Object.hasOwnProperty.call(message, "fetchLatest"))
                $root.signalservice.SyncMessage.FetchLatest.encode(message.fetchLatest, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
                $root.signalservice.SyncMessage.Keys.encode(message.keys, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.messageRequestResponse != null && Object.hasOwnProperty.call(message, "messageRequestResponse"))
                $root.signalservice.SyncMessage.MessageRequestResponse.encode(message.messageRequestResponse, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.viewed != null && message.viewed.length)
                for (var i = 0; i < message.viewed.length; ++i)
                    $root.signalservice.SyncMessage.Viewed.encode(message.viewed[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.pniIdentity != null && Object.hasOwnProperty.call(message, "pniIdentity"))
                $root.signalservice.SyncMessage.PniIdentity.encode(message.pniIdentity, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.pniChangeNumber != null && Object.hasOwnProperty.call(message, "pniChangeNumber"))
                $root.signalservice.SyncMessage.PniChangeNumber.encode(message.pniChangeNumber, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified SyncMessage message, length delimited. Does not implicitly {@link signalservice.SyncMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sent = $root.signalservice.SyncMessage.Sent.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.contacts = $root.signalservice.SyncMessage.Contacts.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.groups = $root.signalservice.SyncMessage.Groups.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.request = $root.signalservice.SyncMessage.Request.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.read && message.read.length))
                        message.read = [];
                    message.read.push($root.signalservice.SyncMessage.Read.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.blocked = $root.signalservice.SyncMessage.Blocked.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.verified = $root.signalservice.Verified.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.configuration = $root.signalservice.SyncMessage.Configuration.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.padding = reader.bytes();
                    break;
                case 10:
                    if (!(message.stickerPackOperation && message.stickerPackOperation.length))
                        message.stickerPackOperation = [];
                    message.stickerPackOperation.push($root.signalservice.SyncMessage.StickerPackOperation.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.keys = $root.signalservice.SyncMessage.Keys.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.decode(reader, reader.uint32());
                    break;
                case 16:
                    if (!(message.viewed && message.viewed.length))
                        message.viewed = [];
                    message.viewed.push($root.signalservice.SyncMessage.Viewed.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.pniIdentity = $root.signalservice.SyncMessage.PniIdentity.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a SyncMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.SyncMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.SyncMessage} SyncMessage
         */
        SyncMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.SyncMessage)
                return object;
            var message = new $root.signalservice.SyncMessage();
            if (object.sent != null) {
                if (typeof object.sent !== "object")
                    throw TypeError(".signalservice.SyncMessage.sent: object expected");
                message.sent = $root.signalservice.SyncMessage.Sent.fromObject(object.sent);
            }
            if (object.contacts != null) {
                if (typeof object.contacts !== "object")
                    throw TypeError(".signalservice.SyncMessage.contacts: object expected");
                message.contacts = $root.signalservice.SyncMessage.Contacts.fromObject(object.contacts);
            }
            if (object.groups != null) {
                if (typeof object.groups !== "object")
                    throw TypeError(".signalservice.SyncMessage.groups: object expected");
                message.groups = $root.signalservice.SyncMessage.Groups.fromObject(object.groups);
            }
            if (object.request != null) {
                if (typeof object.request !== "object")
                    throw TypeError(".signalservice.SyncMessage.request: object expected");
                message.request = $root.signalservice.SyncMessage.Request.fromObject(object.request);
            }
            if (object.read) {
                if (!Array.isArray(object.read))
                    throw TypeError(".signalservice.SyncMessage.read: array expected");
                message.read = [];
                for (var i = 0; i < object.read.length; ++i) {
                    if (typeof object.read[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.read: object expected");
                    message.read[i] = $root.signalservice.SyncMessage.Read.fromObject(object.read[i]);
                }
            }
            if (object.blocked != null) {
                if (typeof object.blocked !== "object")
                    throw TypeError(".signalservice.SyncMessage.blocked: object expected");
                message.blocked = $root.signalservice.SyncMessage.Blocked.fromObject(object.blocked);
            }
            if (object.verified != null) {
                if (typeof object.verified !== "object")
                    throw TypeError(".signalservice.SyncMessage.verified: object expected");
                message.verified = $root.signalservice.Verified.fromObject(object.verified);
            }
            if (object.configuration != null) {
                if (typeof object.configuration !== "object")
                    throw TypeError(".signalservice.SyncMessage.configuration: object expected");
                message.configuration = $root.signalservice.SyncMessage.Configuration.fromObject(object.configuration);
            }
            if (object.padding != null)
                if (typeof object.padding === "string")
                    $util.base64.decode(object.padding, message.padding = $util.newBuffer($util.base64.length(object.padding)), 0);
                else if (object.padding.length)
                    message.padding = object.padding;
            if (object.stickerPackOperation) {
                if (!Array.isArray(object.stickerPackOperation))
                    throw TypeError(".signalservice.SyncMessage.stickerPackOperation: array expected");
                message.stickerPackOperation = [];
                for (var i = 0; i < object.stickerPackOperation.length; ++i) {
                    if (typeof object.stickerPackOperation[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.stickerPackOperation: object expected");
                    message.stickerPackOperation[i] = $root.signalservice.SyncMessage.StickerPackOperation.fromObject(object.stickerPackOperation[i]);
                }
            }
            if (object.viewOnceOpen != null) {
                if (typeof object.viewOnceOpen !== "object")
                    throw TypeError(".signalservice.SyncMessage.viewOnceOpen: object expected");
                message.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.fromObject(object.viewOnceOpen);
            }
            if (object.fetchLatest != null) {
                if (typeof object.fetchLatest !== "object")
                    throw TypeError(".signalservice.SyncMessage.fetchLatest: object expected");
                message.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.fromObject(object.fetchLatest);
            }
            if (object.keys != null) {
                if (typeof object.keys !== "object")
                    throw TypeError(".signalservice.SyncMessage.keys: object expected");
                message.keys = $root.signalservice.SyncMessage.Keys.fromObject(object.keys);
            }
            if (object.messageRequestResponse != null) {
                if (typeof object.messageRequestResponse !== "object")
                    throw TypeError(".signalservice.SyncMessage.messageRequestResponse: object expected");
                message.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.fromObject(object.messageRequestResponse);
            }
            if (object.viewed) {
                if (!Array.isArray(object.viewed))
                    throw TypeError(".signalservice.SyncMessage.viewed: array expected");
                message.viewed = [];
                for (var i = 0; i < object.viewed.length; ++i) {
                    if (typeof object.viewed[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.viewed: object expected");
                    message.viewed[i] = $root.signalservice.SyncMessage.Viewed.fromObject(object.viewed[i]);
                }
            }
            if (object.pniIdentity != null) {
                if (typeof object.pniIdentity !== "object")
                    throw TypeError(".signalservice.SyncMessage.pniIdentity: object expected");
                message.pniIdentity = $root.signalservice.SyncMessage.PniIdentity.fromObject(object.pniIdentity);
            }
            if (object.pniChangeNumber != null) {
                if (typeof object.pniChangeNumber !== "object")
                    throw TypeError(".signalservice.SyncMessage.pniChangeNumber: object expected");
                message.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.fromObject(object.pniChangeNumber);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.SyncMessage} message SyncMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.read = [];
                object.stickerPackOperation = [];
                object.viewed = [];
            }
            if (options.defaults) {
                object.sent = null;
                object.contacts = null;
                object.groups = null;
                object.request = null;
                object.blocked = null;
                object.verified = null;
                if (options.bytes === String)
                    object.padding = "";
                else {
                    object.padding = [];
                    if (options.bytes !== Array)
                        object.padding = $util.newBuffer(object.padding);
                }
                object.configuration = null;
                object.viewOnceOpen = null;
                object.fetchLatest = null;
                object.keys = null;
                object.messageRequestResponse = null;
                object.pniIdentity = null;
                object.pniChangeNumber = null;
            }
            if (message.sent != null && message.hasOwnProperty("sent"))
                object.sent = $root.signalservice.SyncMessage.Sent.toObject(message.sent, options);
            if (message.contacts != null && message.hasOwnProperty("contacts"))
                object.contacts = $root.signalservice.SyncMessage.Contacts.toObject(message.contacts, options);
            if (message.groups != null && message.hasOwnProperty("groups"))
                object.groups = $root.signalservice.SyncMessage.Groups.toObject(message.groups, options);
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = $root.signalservice.SyncMessage.Request.toObject(message.request, options);
            if (message.read && message.read.length) {
                object.read = [];
                for (var j = 0; j < message.read.length; ++j)
                    object.read[j] = $root.signalservice.SyncMessage.Read.toObject(message.read[j], options);
            }
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = $root.signalservice.SyncMessage.Blocked.toObject(message.blocked, options);
            if (message.verified != null && message.hasOwnProperty("verified"))
                object.verified = $root.signalservice.Verified.toObject(message.verified, options);
            if (message.padding != null && message.hasOwnProperty("padding"))
                object.padding = options.bytes === String ? $util.base64.encode(message.padding, 0, message.padding.length) : options.bytes === Array ? Array.prototype.slice.call(message.padding) : message.padding;
            if (message.configuration != null && message.hasOwnProperty("configuration"))
                object.configuration = $root.signalservice.SyncMessage.Configuration.toObject(message.configuration, options);
            if (message.stickerPackOperation && message.stickerPackOperation.length) {
                object.stickerPackOperation = [];
                for (var j = 0; j < message.stickerPackOperation.length; ++j)
                    object.stickerPackOperation[j] = $root.signalservice.SyncMessage.StickerPackOperation.toObject(message.stickerPackOperation[j], options);
            }
            if (message.viewOnceOpen != null && message.hasOwnProperty("viewOnceOpen"))
                object.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.toObject(message.viewOnceOpen, options);
            if (message.fetchLatest != null && message.hasOwnProperty("fetchLatest"))
                object.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.toObject(message.fetchLatest, options);
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = $root.signalservice.SyncMessage.Keys.toObject(message.keys, options);
            if (message.messageRequestResponse != null && message.hasOwnProperty("messageRequestResponse"))
                object.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.toObject(message.messageRequestResponse, options);
            if (message.viewed && message.viewed.length) {
                object.viewed = [];
                for (var j = 0; j < message.viewed.length; ++j)
                    object.viewed[j] = $root.signalservice.SyncMessage.Viewed.toObject(message.viewed[j], options);
            }
            if (message.pniIdentity != null && message.hasOwnProperty("pniIdentity"))
                object.pniIdentity = $root.signalservice.SyncMessage.PniIdentity.toObject(message.pniIdentity, options);
            if (message.pniChangeNumber != null && message.hasOwnProperty("pniChangeNumber"))
                object.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.toObject(message.pniChangeNumber, options);
            return object;
        };

        /**
         * Converts this SyncMessage to JSON.
         * @function toJSON
         * @memberof signalservice.SyncMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SyncMessage.Sent = (function() {

            /**
             * Properties of a Sent.
             * @memberof signalservice.SyncMessage
             * @interface ISent
             * @property {string|null} [destination] Sent destination
             * @property {string|null} [destinationUuid] Sent destinationUuid
             * @property {Long|null} [timestamp] Sent timestamp
             * @property {signalservice.IDataMessage|null} [message] Sent message
             * @property {Long|null} [expirationStartTimestamp] Sent expirationStartTimestamp
             * @property {Array.<signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus>|null} [unidentifiedStatus] Sent unidentifiedStatus
             * @property {boolean|null} [isRecipientUpdate] Sent isRecipientUpdate
             * @property {signalservice.IStoryMessage|null} [storyMessage] Sent storyMessage
             * @property {Array.<signalservice.SyncMessage.Sent.IStoryMessageRecipient>|null} [storyMessageRecipients] Sent storyMessageRecipients
             */

            /**
             * Constructs a new Sent.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Sent.
             * @implements ISent
             * @constructor
             * @param {signalservice.SyncMessage.ISent=} [properties] Properties to set
             */
            function Sent(properties) {
                this.unidentifiedStatus = [];
                this.storyMessageRecipients = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sent destination.
             * @member {string} destination
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.destination = "";

            /**
             * Sent destinationUuid.
             * @member {string} destinationUuid
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.destinationUuid = "";

            /**
             * Sent timestamp.
             * @member {Long} timestamp
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Sent message.
             * @member {signalservice.IDataMessage|null|undefined} message
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.message = null;

            /**
             * Sent expirationStartTimestamp.
             * @member {Long} expirationStartTimestamp
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.expirationStartTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Sent unidentifiedStatus.
             * @member {Array.<signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus>} unidentifiedStatus
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.unidentifiedStatus = $util.emptyArray;

            /**
             * Sent isRecipientUpdate.
             * @member {boolean} isRecipientUpdate
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.isRecipientUpdate = false;

            /**
             * Sent storyMessage.
             * @member {signalservice.IStoryMessage|null|undefined} storyMessage
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.storyMessage = null;

            /**
             * Sent storyMessageRecipients.
             * @member {Array.<signalservice.SyncMessage.Sent.IStoryMessageRecipient>} storyMessageRecipients
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.storyMessageRecipients = $util.emptyArray;

            /**
             * Encodes the specified Sent message. Does not implicitly {@link signalservice.SyncMessage.Sent.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.ISent} message Sent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Sent.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.signalservice.DataMessage.encode(message.message, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.expirationStartTimestamp != null && Object.hasOwnProperty.call(message, "expirationStartTimestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.expirationStartTimestamp);
                if (message.unidentifiedStatus != null && message.unidentifiedStatus.length)
                    for (var i = 0; i < message.unidentifiedStatus.length; ++i)
                        $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.encode(message.unidentifiedStatus[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.isRecipientUpdate != null && Object.hasOwnProperty.call(message, "isRecipientUpdate"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isRecipientUpdate);
                if (message.destinationUuid != null && Object.hasOwnProperty.call(message, "destinationUuid"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.destinationUuid);
                if (message.storyMessage != null && Object.hasOwnProperty.call(message, "storyMessage"))
                    $root.signalservice.StoryMessage.encode(message.storyMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.storyMessageRecipients != null && message.storyMessageRecipients.length)
                    for (var i = 0; i < message.storyMessageRecipients.length; ++i)
                        $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.encode(message.storyMessageRecipients[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Sent message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.ISent} message Sent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sent message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Sent} Sent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destination = reader.string();
                        break;
                    case 7:
                        message.destinationUuid = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.uint64();
                        break;
                    case 3:
                        message.message = $root.signalservice.DataMessage.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.expirationStartTimestamp = reader.uint64();
                        break;
                    case 5:
                        if (!(message.unidentifiedStatus && message.unidentifiedStatus.length))
                            message.unidentifiedStatus = [];
                        message.unidentifiedStatus.push($root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.isRecipientUpdate = reader.bool();
                        break;
                    case 8:
                        message.storyMessage = $root.signalservice.StoryMessage.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.storyMessageRecipients && message.storyMessageRecipients.length))
                            message.storyMessageRecipients = [];
                        message.storyMessageRecipients.push($root.signalservice.SyncMessage.Sent.StoryMessageRecipient.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Sent} Sent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Sent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Sent} Sent
             */
            Sent.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Sent)
                    return object;
                var message = new $root.signalservice.SyncMessage.Sent();
                if (object.destination != null)
                    message.destination = String(object.destination);
                if (object.destinationUuid != null)
                    message.destinationUuid = String(object.destinationUuid);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".signalservice.SyncMessage.Sent.message: object expected");
                    message.message = $root.signalservice.DataMessage.fromObject(object.message);
                }
                if (object.expirationStartTimestamp != null)
                    if ($util.Long)
                        (message.expirationStartTimestamp = $util.Long.fromValue(object.expirationStartTimestamp)).unsigned = true;
                    else if (typeof object.expirationStartTimestamp === "string")
                        message.expirationStartTimestamp = parseInt(object.expirationStartTimestamp, 10);
                    else if (typeof object.expirationStartTimestamp === "number")
                        message.expirationStartTimestamp = object.expirationStartTimestamp;
                    else if (typeof object.expirationStartTimestamp === "object")
                        message.expirationStartTimestamp = new $util.LongBits(object.expirationStartTimestamp.low >>> 0, object.expirationStartTimestamp.high >>> 0).toNumber(true);
                if (object.unidentifiedStatus) {
                    if (!Array.isArray(object.unidentifiedStatus))
                        throw TypeError(".signalservice.SyncMessage.Sent.unidentifiedStatus: array expected");
                    message.unidentifiedStatus = [];
                    for (var i = 0; i < object.unidentifiedStatus.length; ++i) {
                        if (typeof object.unidentifiedStatus[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.Sent.unidentifiedStatus: object expected");
                        message.unidentifiedStatus[i] = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.fromObject(object.unidentifiedStatus[i]);
                    }
                }
                if (object.isRecipientUpdate != null)
                    message.isRecipientUpdate = Boolean(object.isRecipientUpdate);
                if (object.storyMessage != null) {
                    if (typeof object.storyMessage !== "object")
                        throw TypeError(".signalservice.SyncMessage.Sent.storyMessage: object expected");
                    message.storyMessage = $root.signalservice.StoryMessage.fromObject(object.storyMessage);
                }
                if (object.storyMessageRecipients) {
                    if (!Array.isArray(object.storyMessageRecipients))
                        throw TypeError(".signalservice.SyncMessage.Sent.storyMessageRecipients: array expected");
                    message.storyMessageRecipients = [];
                    for (var i = 0; i < object.storyMessageRecipients.length; ++i) {
                        if (typeof object.storyMessageRecipients[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.Sent.storyMessageRecipients: object expected");
                        message.storyMessageRecipients[i] = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.fromObject(object.storyMessageRecipients[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Sent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.Sent} message Sent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.unidentifiedStatus = [];
                    object.storyMessageRecipients = [];
                }
                if (options.defaults) {
                    object.destination = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.message = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.expirationStartTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expirationStartTimestamp = options.longs === String ? "0" : 0;
                    object.isRecipientUpdate = false;
                    object.destinationUuid = "";
                    object.storyMessage = null;
                }
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.signalservice.DataMessage.toObject(message.message, options);
                if (message.expirationStartTimestamp != null && message.hasOwnProperty("expirationStartTimestamp"))
                    if (typeof message.expirationStartTimestamp === "number")
                        object.expirationStartTimestamp = options.longs === String ? String(message.expirationStartTimestamp) : message.expirationStartTimestamp;
                    else
                        object.expirationStartTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expirationStartTimestamp) : options.longs === Number ? new $util.LongBits(message.expirationStartTimestamp.low >>> 0, message.expirationStartTimestamp.high >>> 0).toNumber(true) : message.expirationStartTimestamp;
                if (message.unidentifiedStatus && message.unidentifiedStatus.length) {
                    object.unidentifiedStatus = [];
                    for (var j = 0; j < message.unidentifiedStatus.length; ++j)
                        object.unidentifiedStatus[j] = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.toObject(message.unidentifiedStatus[j], options);
                }
                if (message.isRecipientUpdate != null && message.hasOwnProperty("isRecipientUpdate"))
                    object.isRecipientUpdate = message.isRecipientUpdate;
                if (message.destinationUuid != null && message.hasOwnProperty("destinationUuid"))
                    object.destinationUuid = message.destinationUuid;
                if (message.storyMessage != null && message.hasOwnProperty("storyMessage"))
                    object.storyMessage = $root.signalservice.StoryMessage.toObject(message.storyMessage, options);
                if (message.storyMessageRecipients && message.storyMessageRecipients.length) {
                    object.storyMessageRecipients = [];
                    for (var j = 0; j < message.storyMessageRecipients.length; ++j)
                        object.storyMessageRecipients[j] = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.toObject(message.storyMessageRecipients[j], options);
                }
                return object;
            };

            /**
             * Converts this Sent to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Sent.UnidentifiedDeliveryStatus = (function() {

                /**
                 * Properties of an UnidentifiedDeliveryStatus.
                 * @memberof signalservice.SyncMessage.Sent
                 * @interface IUnidentifiedDeliveryStatus
                 * @property {string|null} [destination] UnidentifiedDeliveryStatus destination
                 * @property {string|null} [destinationUuid] UnidentifiedDeliveryStatus destinationUuid
                 * @property {boolean|null} [unidentified] UnidentifiedDeliveryStatus unidentified
                 */

                /**
                 * Constructs a new UnidentifiedDeliveryStatus.
                 * @memberof signalservice.SyncMessage.Sent
                 * @classdesc Represents an UnidentifiedDeliveryStatus.
                 * @implements IUnidentifiedDeliveryStatus
                 * @constructor
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus=} [properties] Properties to set
                 */
                function UnidentifiedDeliveryStatus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UnidentifiedDeliveryStatus destination.
                 * @member {string} destination
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.destination = "";

                /**
                 * UnidentifiedDeliveryStatus destinationUuid.
                 * @member {string} destinationUuid
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.destinationUuid = "";

                /**
                 * UnidentifiedDeliveryStatus unidentified.
                 * @member {boolean} unidentified
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.unidentified = false;

                /**
                 * Encodes the specified UnidentifiedDeliveryStatus message. Does not implicitly {@link signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnidentifiedDeliveryStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                    if (message.unidentified != null && Object.hasOwnProperty.call(message, "unidentified"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.unidentified);
                    if (message.destinationUuid != null && Object.hasOwnProperty.call(message, "destinationUuid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationUuid);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified UnidentifiedDeliveryStatus message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnidentifiedDeliveryStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UnidentifiedDeliveryStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnidentifiedDeliveryStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.destination = reader.string();
                            break;
                        case 3:
                            message.destinationUuid = reader.string();
                            break;
                        case 2:
                            message.unidentified = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UnidentifiedDeliveryStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnidentifiedDeliveryStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an UnidentifiedDeliveryStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 */
                UnidentifiedDeliveryStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus)
                        return object;
                    var message = new $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus();
                    if (object.destination != null)
                        message.destination = String(object.destination);
                    if (object.destinationUuid != null)
                        message.destinationUuid = String(object.destinationUuid);
                    if (object.unidentified != null)
                        message.unidentified = Boolean(object.unidentified);
                    return message;
                };

                /**
                 * Creates a plain object from an UnidentifiedDeliveryStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnidentifiedDeliveryStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.destination = "";
                        object.unidentified = false;
                        object.destinationUuid = "";
                    }
                    if (message.destination != null && message.hasOwnProperty("destination"))
                        object.destination = message.destination;
                    if (message.unidentified != null && message.hasOwnProperty("unidentified"))
                        object.unidentified = message.unidentified;
                    if (message.destinationUuid != null && message.hasOwnProperty("destinationUuid"))
                        object.destinationUuid = message.destinationUuid;
                    return object;
                };

                /**
                 * Converts this UnidentifiedDeliveryStatus to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnidentifiedDeliveryStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UnidentifiedDeliveryStatus;
            })();

            Sent.StoryMessageRecipient = (function() {

                /**
                 * Properties of a StoryMessageRecipient.
                 * @memberof signalservice.SyncMessage.Sent
                 * @interface IStoryMessageRecipient
                 * @property {string|null} [destinationUuid] StoryMessageRecipient destinationUuid
                 * @property {Array.<string>|null} [distributionListIds] StoryMessageRecipient distributionListIds
                 * @property {boolean|null} [isAllowedToReply] StoryMessageRecipient isAllowedToReply
                 */

                /**
                 * Constructs a new StoryMessageRecipient.
                 * @memberof signalservice.SyncMessage.Sent
                 * @classdesc Represents a StoryMessageRecipient.
                 * @implements IStoryMessageRecipient
                 * @constructor
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient=} [properties] Properties to set
                 */
                function StoryMessageRecipient(properties) {
                    this.distributionListIds = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StoryMessageRecipient destinationUuid.
                 * @member {string} destinationUuid
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.destinationUuid = "";

                /**
                 * StoryMessageRecipient distributionListIds.
                 * @member {Array.<string>} distributionListIds
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.distributionListIds = $util.emptyArray;

                /**
                 * StoryMessageRecipient isAllowedToReply.
                 * @member {boolean} isAllowedToReply
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.isAllowedToReply = false;

                /**
                 * Encodes the specified StoryMessageRecipient message. Does not implicitly {@link signalservice.SyncMessage.Sent.StoryMessageRecipient.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient} message StoryMessageRecipient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoryMessageRecipient.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.destinationUuid != null && Object.hasOwnProperty.call(message, "destinationUuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.destinationUuid);
                    if (message.distributionListIds != null && message.distributionListIds.length)
                        for (var i = 0; i < message.distributionListIds.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.distributionListIds[i]);
                    if (message.isAllowedToReply != null && Object.hasOwnProperty.call(message, "isAllowedToReply"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAllowedToReply);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified StoryMessageRecipient message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.StoryMessageRecipient.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient} message StoryMessageRecipient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoryMessageRecipient.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StoryMessageRecipient message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoryMessageRecipient.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent.StoryMessageRecipient();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.destinationUuid = reader.string();
                            break;
                        case 2:
                            if (!(message.distributionListIds && message.distributionListIds.length))
                                message.distributionListIds = [];
                            message.distributionListIds.push(reader.string());
                            break;
                        case 3:
                            message.isAllowedToReply = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StoryMessageRecipient message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoryMessageRecipient.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a StoryMessageRecipient message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 */
                StoryMessageRecipient.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.Sent.StoryMessageRecipient)
                        return object;
                    var message = new $root.signalservice.SyncMessage.Sent.StoryMessageRecipient();
                    if (object.destinationUuid != null)
                        message.destinationUuid = String(object.destinationUuid);
                    if (object.distributionListIds) {
                        if (!Array.isArray(object.distributionListIds))
                            throw TypeError(".signalservice.SyncMessage.Sent.StoryMessageRecipient.distributionListIds: array expected");
                        message.distributionListIds = [];
                        for (var i = 0; i < object.distributionListIds.length; ++i)
                            message.distributionListIds[i] = String(object.distributionListIds[i]);
                    }
                    if (object.isAllowedToReply != null)
                        message.isAllowedToReply = Boolean(object.isAllowedToReply);
                    return message;
                };

                /**
                 * Creates a plain object from a StoryMessageRecipient message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.StoryMessageRecipient} message StoryMessageRecipient
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StoryMessageRecipient.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.distributionListIds = [];
                    if (options.defaults) {
                        object.destinationUuid = "";
                        object.isAllowedToReply = false;
                    }
                    if (message.destinationUuid != null && message.hasOwnProperty("destinationUuid"))
                        object.destinationUuid = message.destinationUuid;
                    if (message.distributionListIds && message.distributionListIds.length) {
                        object.distributionListIds = [];
                        for (var j = 0; j < message.distributionListIds.length; ++j)
                            object.distributionListIds[j] = message.distributionListIds[j];
                    }
                    if (message.isAllowedToReply != null && message.hasOwnProperty("isAllowedToReply"))
                        object.isAllowedToReply = message.isAllowedToReply;
                    return object;
                };

                /**
                 * Converts this StoryMessageRecipient to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StoryMessageRecipient.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StoryMessageRecipient;
            })();

            return Sent;
        })();

        SyncMessage.Contacts = (function() {

            /**
             * Properties of a Contacts.
             * @memberof signalservice.SyncMessage
             * @interface IContacts
             * @property {signalservice.IAttachmentPointer|null} [blob] Contacts blob
             * @property {boolean|null} [complete] Contacts complete
             */

            /**
             * Constructs a new Contacts.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Contacts.
             * @implements IContacts
             * @constructor
             * @param {signalservice.SyncMessage.IContacts=} [properties] Properties to set
             */
            function Contacts(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contacts blob.
             * @member {signalservice.IAttachmentPointer|null|undefined} blob
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             */
            Contacts.prototype.blob = null;

            /**
             * Contacts complete.
             * @member {boolean} complete
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             */
            Contacts.prototype.complete = false;

            /**
             * Encodes the specified Contacts message. Does not implicitly {@link signalservice.SyncMessage.Contacts.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.IContacts} message Contacts message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contacts.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Contacts.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                    $root.signalservice.AttachmentPointer.encode(message.blob, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.complete != null && Object.hasOwnProperty.call(message, "complete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.complete);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Contacts message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Contacts.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.IContacts} message Contacts message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contacts.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contacts message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contacts.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Contacts();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blob = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.complete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contacts message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contacts.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Contacts message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             */
            Contacts.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Contacts)
                    return object;
                var message = new $root.signalservice.SyncMessage.Contacts();
                if (object.blob != null) {
                    if (typeof object.blob !== "object")
                        throw TypeError(".signalservice.SyncMessage.Contacts.blob: object expected");
                    message.blob = $root.signalservice.AttachmentPointer.fromObject(object.blob);
                }
                if (object.complete != null)
                    message.complete = Boolean(object.complete);
                return message;
            };

            /**
             * Creates a plain object from a Contacts message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.Contacts} message Contacts
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contacts.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.blob = null;
                    object.complete = false;
                }
                if (message.blob != null && message.hasOwnProperty("blob"))
                    object.blob = $root.signalservice.AttachmentPointer.toObject(message.blob, options);
                if (message.complete != null && message.hasOwnProperty("complete"))
                    object.complete = message.complete;
                return object;
            };

            /**
             * Converts this Contacts to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contacts.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Contacts;
        })();

        SyncMessage.Groups = (function() {

            /**
             * Properties of a Groups.
             * @memberof signalservice.SyncMessage
             * @interface IGroups
             * @property {signalservice.IAttachmentPointer|null} [blob] Groups blob
             */

            /**
             * Constructs a new Groups.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Groups.
             * @implements IGroups
             * @constructor
             * @param {signalservice.SyncMessage.IGroups=} [properties] Properties to set
             */
            function Groups(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Groups blob.
             * @member {signalservice.IAttachmentPointer|null|undefined} blob
             * @memberof signalservice.SyncMessage.Groups
             * @instance
             */
            Groups.prototype.blob = null;

            /**
             * Encodes the specified Groups message. Does not implicitly {@link signalservice.SyncMessage.Groups.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {signalservice.SyncMessage.IGroups} message Groups message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Groups.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Groups.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                    $root.signalservice.AttachmentPointer.encode(message.blob, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Groups message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Groups.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {signalservice.SyncMessage.IGroups} message Groups message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Groups.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Groups message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Groups} Groups
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Groups.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Groups();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blob = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Groups message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Groups} Groups
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Groups.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Groups message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Groups} Groups
             */
            Groups.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Groups)
                    return object;
                var message = new $root.signalservice.SyncMessage.Groups();
                if (object.blob != null) {
                    if (typeof object.blob !== "object")
                        throw TypeError(".signalservice.SyncMessage.Groups.blob: object expected");
                    message.blob = $root.signalservice.AttachmentPointer.fromObject(object.blob);
                }
                return message;
            };

            /**
             * Creates a plain object from a Groups message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Groups
             * @static
             * @param {signalservice.SyncMessage.Groups} message Groups
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Groups.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.blob = null;
                if (message.blob != null && message.hasOwnProperty("blob"))
                    object.blob = $root.signalservice.AttachmentPointer.toObject(message.blob, options);
                return object;
            };

            /**
             * Converts this Groups to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Groups
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Groups.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Groups;
        })();

        SyncMessage.Blocked = (function() {

            /**
             * Properties of a Blocked.
             * @memberof signalservice.SyncMessage
             * @interface IBlocked
             * @property {Array.<string>|null} [numbers] Blocked numbers
             * @property {Array.<string>|null} [uuids] Blocked uuids
             * @property {Array.<Uint8Array>|null} [groupIds] Blocked groupIds
             */

            /**
             * Constructs a new Blocked.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Blocked.
             * @implements IBlocked
             * @constructor
             * @param {signalservice.SyncMessage.IBlocked=} [properties] Properties to set
             */
            function Blocked(properties) {
                this.numbers = [];
                this.uuids = [];
                this.groupIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Blocked numbers.
             * @member {Array.<string>} numbers
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.numbers = $util.emptyArray;

            /**
             * Blocked uuids.
             * @member {Array.<string>} uuids
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.uuids = $util.emptyArray;

            /**
             * Blocked groupIds.
             * @member {Array.<Uint8Array>} groupIds
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.groupIds = $util.emptyArray;

            /**
             * Encodes the specified Blocked message. Does not implicitly {@link signalservice.SyncMessage.Blocked.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.IBlocked} message Blocked message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Blocked.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Blocked.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.numbers != null && message.numbers.length)
                    for (var i = 0; i < message.numbers.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.numbers[i]);
                if (message.groupIds != null && message.groupIds.length)
                    for (var i = 0; i < message.groupIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.groupIds[i]);
                if (message.uuids != null && message.uuids.length)
                    for (var i = 0; i < message.uuids.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.uuids[i]);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Blocked message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Blocked.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.IBlocked} message Blocked message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Blocked.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Blocked message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Blocked.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Blocked();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.numbers && message.numbers.length))
                            message.numbers = [];
                        message.numbers.push(reader.string());
                        break;
                    case 3:
                        if (!(message.uuids && message.uuids.length))
                            message.uuids = [];
                        message.uuids.push(reader.string());
                        break;
                    case 2:
                        if (!(message.groupIds && message.groupIds.length))
                            message.groupIds = [];
                        message.groupIds.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Blocked message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Blocked.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Blocked message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             */
            Blocked.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Blocked)
                    return object;
                var message = new $root.signalservice.SyncMessage.Blocked();
                if (object.numbers) {
                    if (!Array.isArray(object.numbers))
                        throw TypeError(".signalservice.SyncMessage.Blocked.numbers: array expected");
                    message.numbers = [];
                    for (var i = 0; i < object.numbers.length; ++i)
                        message.numbers[i] = String(object.numbers[i]);
                }
                if (object.uuids) {
                    if (!Array.isArray(object.uuids))
                        throw TypeError(".signalservice.SyncMessage.Blocked.uuids: array expected");
                    message.uuids = [];
                    for (var i = 0; i < object.uuids.length; ++i)
                        message.uuids[i] = String(object.uuids[i]);
                }
                if (object.groupIds) {
                    if (!Array.isArray(object.groupIds))
                        throw TypeError(".signalservice.SyncMessage.Blocked.groupIds: array expected");
                    message.groupIds = [];
                    for (var i = 0; i < object.groupIds.length; ++i)
                        if (typeof object.groupIds[i] === "string")
                            $util.base64.decode(object.groupIds[i], message.groupIds[i] = $util.newBuffer($util.base64.length(object.groupIds[i])), 0);
                        else if (object.groupIds[i].length)
                            message.groupIds[i] = object.groupIds[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a Blocked message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.Blocked} message Blocked
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Blocked.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.numbers = [];
                    object.groupIds = [];
                    object.uuids = [];
                }
                if (message.numbers && message.numbers.length) {
                    object.numbers = [];
                    for (var j = 0; j < message.numbers.length; ++j)
                        object.numbers[j] = message.numbers[j];
                }
                if (message.groupIds && message.groupIds.length) {
                    object.groupIds = [];
                    for (var j = 0; j < message.groupIds.length; ++j)
                        object.groupIds[j] = options.bytes === String ? $util.base64.encode(message.groupIds[j], 0, message.groupIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.groupIds[j]) : message.groupIds[j];
                }
                if (message.uuids && message.uuids.length) {
                    object.uuids = [];
                    for (var j = 0; j < message.uuids.length; ++j)
                        object.uuids[j] = message.uuids[j];
                }
                return object;
            };

            /**
             * Converts this Blocked to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Blocked.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Blocked;
        })();

        SyncMessage.Request = (function() {

            /**
             * Properties of a Request.
             * @memberof signalservice.SyncMessage
             * @interface IRequest
             * @property {signalservice.SyncMessage.Request.Type|null} [type] Request type
             */

            /**
             * Constructs a new Request.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {signalservice.SyncMessage.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Request type.
             * @member {signalservice.SyncMessage.Request.Type} type
             * @memberof signalservice.SyncMessage.Request
             * @instance
             */
            Request.prototype.type = 0;

            /**
             * Encodes the specified Request message. Does not implicitly {@link signalservice.SyncMessage.Request.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Request.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Request();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Request)
                    return object;
                var message = new $root.signalservice.SyncMessage.Request();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "CONTACTS":
                case 1:
                    message.type = 1;
                    break;
                case "GROUPS":
                case 2:
                    message.type = 2;
                    break;
                case "BLOCKED":
                case 3:
                    message.type = 3;
                    break;
                case "CONFIGURATION":
                case 4:
                    message.type = 4;
                    break;
                case "KEYS":
                case 5:
                    message.type = 5;
                    break;
                case "PNI_IDENTITY":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.Request.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.Request.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CONTACTS=1 CONTACTS value
             * @property {number} GROUPS=2 GROUPS value
             * @property {number} BLOCKED=3 BLOCKED value
             * @property {number} CONFIGURATION=4 CONFIGURATION value
             * @property {number} KEYS=5 KEYS value
             * @property {number} PNI_IDENTITY=6 PNI_IDENTITY value
             */
            Request.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CONTACTS"] = 1;
                values[valuesById[2] = "GROUPS"] = 2;
                values[valuesById[3] = "BLOCKED"] = 3;
                values[valuesById[4] = "CONFIGURATION"] = 4;
                values[valuesById[5] = "KEYS"] = 5;
                values[valuesById[6] = "PNI_IDENTITY"] = 6;
                return values;
            })();

            return Request;
        })();

        SyncMessage.Keys = (function() {

            /**
             * Properties of a Keys.
             * @memberof signalservice.SyncMessage
             * @interface IKeys
             * @property {Uint8Array|null} [storageService] Keys storageService
             */

            /**
             * Constructs a new Keys.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Keys.
             * @implements IKeys
             * @constructor
             * @param {signalservice.SyncMessage.IKeys=} [properties] Properties to set
             */
            function Keys(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Keys storageService.
             * @member {Uint8Array} storageService
             * @memberof signalservice.SyncMessage.Keys
             * @instance
             */
            Keys.prototype.storageService = $util.newBuffer([]);

            /**
             * Encodes the specified Keys message. Does not implicitly {@link signalservice.SyncMessage.Keys.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Keys.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.storageService != null && Object.hasOwnProperty.call(message, "storageService"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.storageService);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Keys message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Keys.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Keys message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Keys();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.storageService = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Keys message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Keys message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Keys} Keys
             */
            Keys.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Keys)
                    return object;
                var message = new $root.signalservice.SyncMessage.Keys();
                if (object.storageService != null)
                    if (typeof object.storageService === "string")
                        $util.base64.decode(object.storageService, message.storageService = $util.newBuffer($util.base64.length(object.storageService)), 0);
                    else if (object.storageService.length)
                        message.storageService = object.storageService;
                return message;
            };

            /**
             * Creates a plain object from a Keys message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.Keys} message Keys
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Keys.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.storageService = "";
                    else {
                        object.storageService = [];
                        if (options.bytes !== Array)
                            object.storageService = $util.newBuffer(object.storageService);
                    }
                if (message.storageService != null && message.hasOwnProperty("storageService"))
                    object.storageService = options.bytes === String ? $util.base64.encode(message.storageService, 0, message.storageService.length) : options.bytes === Array ? Array.prototype.slice.call(message.storageService) : message.storageService;
                return object;
            };

            /**
             * Converts this Keys to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Keys
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Keys.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Keys;
        })();

        SyncMessage.PniIdentity = (function() {

            /**
             * Properties of a PniIdentity.
             * @memberof signalservice.SyncMessage
             * @interface IPniIdentity
             * @property {Uint8Array|null} [publicKey] PniIdentity publicKey
             * @property {Uint8Array|null} [privateKey] PniIdentity privateKey
             */

            /**
             * Constructs a new PniIdentity.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a PniIdentity.
             * @implements IPniIdentity
             * @constructor
             * @param {signalservice.SyncMessage.IPniIdentity=} [properties] Properties to set
             */
            function PniIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PniIdentity publicKey.
             * @member {Uint8Array} publicKey
             * @memberof signalservice.SyncMessage.PniIdentity
             * @instance
             */
            PniIdentity.prototype.publicKey = $util.newBuffer([]);

            /**
             * PniIdentity privateKey.
             * @member {Uint8Array} privateKey
             * @memberof signalservice.SyncMessage.PniIdentity
             * @instance
             */
            PniIdentity.prototype.privateKey = $util.newBuffer([]);

            /**
             * Encodes the specified PniIdentity message. Does not implicitly {@link signalservice.SyncMessage.PniIdentity.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {signalservice.SyncMessage.IPniIdentity} message PniIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.PniIdentity.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified PniIdentity message, length delimited. Does not implicitly {@link signalservice.SyncMessage.PniIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {signalservice.SyncMessage.IPniIdentity} message PniIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PniIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.PniIdentity} PniIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.PniIdentity();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.publicKey = reader.bytes();
                        break;
                    case 2:
                        message.privateKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PniIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.PniIdentity} PniIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a PniIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.PniIdentity} PniIdentity
             */
            PniIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.PniIdentity)
                    return object;
                var message = new $root.signalservice.SyncMessage.PniIdentity();
                if (object.publicKey != null)
                    if (typeof object.publicKey === "string")
                        $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                    else if (object.publicKey.length)
                        message.publicKey = object.publicKey;
                if (object.privateKey != null)
                    if (typeof object.privateKey === "string")
                        $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                    else if (object.privateKey.length)
                        message.privateKey = object.privateKey;
                return message;
            };

            /**
             * Creates a plain object from a PniIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.PniIdentity
             * @static
             * @param {signalservice.SyncMessage.PniIdentity} message PniIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PniIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.publicKey = "";
                    else {
                        object.publicKey = [];
                        if (options.bytes !== Array)
                            object.publicKey = $util.newBuffer(object.publicKey);
                    }
                    if (options.bytes === String)
                        object.privateKey = "";
                    else {
                        object.privateKey = [];
                        if (options.bytes !== Array)
                            object.privateKey = $util.newBuffer(object.privateKey);
                    }
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                return object;
            };

            /**
             * Converts this PniIdentity to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.PniIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PniIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PniIdentity;
        })();

        SyncMessage.Read = (function() {

            /**
             * Properties of a Read.
             * @memberof signalservice.SyncMessage
             * @interface IRead
             * @property {string|null} [sender] Read sender
             * @property {string|null} [senderUuid] Read senderUuid
             * @property {Long|null} [timestamp] Read timestamp
             */

            /**
             * Constructs a new Read.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Read.
             * @implements IRead
             * @constructor
             * @param {signalservice.SyncMessage.IRead=} [properties] Properties to set
             */
            function Read(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Read sender.
             * @member {string} sender
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.sender = "";

            /**
             * Read senderUuid.
             * @member {string} senderUuid
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.senderUuid = "";

            /**
             * Read timestamp.
             * @member {Long} timestamp
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Read message. Does not implicitly {@link signalservice.SyncMessage.Read.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.IRead} message Read message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Read.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Read.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderUuid != null && Object.hasOwnProperty.call(message, "senderUuid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderUuid);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Read message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Read.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.IRead} message Read message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Read.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Read message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Read} Read
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Read.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Read();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sender = reader.string();
                        break;
                    case 3:
                        message.senderUuid = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Read message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Read} Read
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Read.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Read message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Read} Read
             */
            Read.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Read)
                    return object;
                var message = new $root.signalservice.SyncMessage.Read();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.senderUuid != null)
                    message.senderUuid = String(object.senderUuid);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Read message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.Read} message Read
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Read.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sender = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderUuid = "";
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderUuid != null && message.hasOwnProperty("senderUuid"))
                    object.senderUuid = message.senderUuid;
                return object;
            };

            /**
             * Converts this Read to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Read
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Read.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Read;
        })();

        SyncMessage.Viewed = (function() {

            /**
             * Properties of a Viewed.
             * @memberof signalservice.SyncMessage
             * @interface IViewed
             * @property {string|null} [senderE164] Viewed senderE164
             * @property {string|null} [senderUuid] Viewed senderUuid
             * @property {Long|null} [timestamp] Viewed timestamp
             */

            /**
             * Constructs a new Viewed.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Viewed.
             * @implements IViewed
             * @constructor
             * @param {signalservice.SyncMessage.IViewed=} [properties] Properties to set
             */
            function Viewed(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Viewed senderE164.
             * @member {string} senderE164
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.senderE164 = "";

            /**
             * Viewed senderUuid.
             * @member {string} senderUuid
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.senderUuid = "";

            /**
             * Viewed timestamp.
             * @member {Long} timestamp
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified Viewed message. Does not implicitly {@link signalservice.SyncMessage.Viewed.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.IViewed} message Viewed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Viewed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Viewed.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.senderE164 != null && Object.hasOwnProperty.call(message, "senderE164"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderE164);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderUuid != null && Object.hasOwnProperty.call(message, "senderUuid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderUuid);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Viewed message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Viewed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.IViewed} message Viewed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Viewed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Viewed message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Viewed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Viewed();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.senderE164 = reader.string();
                        break;
                    case 3:
                        message.senderUuid = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Viewed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Viewed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Viewed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             */
            Viewed.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Viewed)
                    return object;
                var message = new $root.signalservice.SyncMessage.Viewed();
                if (object.senderE164 != null)
                    message.senderE164 = String(object.senderE164);
                if (object.senderUuid != null)
                    message.senderUuid = String(object.senderUuid);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Viewed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.Viewed} message Viewed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Viewed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.senderE164 = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderUuid = "";
                }
                if (message.senderE164 != null && message.hasOwnProperty("senderE164"))
                    object.senderE164 = message.senderE164;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderUuid != null && message.hasOwnProperty("senderUuid"))
                    object.senderUuid = message.senderUuid;
                return object;
            };

            /**
             * Converts this Viewed to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Viewed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Viewed;
        })();

        SyncMessage.Configuration = (function() {

            /**
             * Properties of a Configuration.
             * @memberof signalservice.SyncMessage
             * @interface IConfiguration
             * @property {boolean|null} [readReceipts] Configuration readReceipts
             * @property {boolean|null} [unidentifiedDeliveryIndicators] Configuration unidentifiedDeliveryIndicators
             * @property {boolean|null} [typingIndicators] Configuration typingIndicators
             * @property {number|null} [provisioningVersion] Configuration provisioningVersion
             * @property {boolean|null} [linkPreviews] Configuration linkPreviews
             */

            /**
             * Constructs a new Configuration.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Configuration.
             * @implements IConfiguration
             * @constructor
             * @param {signalservice.SyncMessage.IConfiguration=} [properties] Properties to set
             */
            function Configuration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Configuration readReceipts.
             * @member {boolean} readReceipts
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.readReceipts = false;

            /**
             * Configuration unidentifiedDeliveryIndicators.
             * @member {boolean} unidentifiedDeliveryIndicators
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.unidentifiedDeliveryIndicators = false;

            /**
             * Configuration typingIndicators.
             * @member {boolean} typingIndicators
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.typingIndicators = false;

            /**
             * Configuration provisioningVersion.
             * @member {number} provisioningVersion
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.provisioningVersion = 0;

            /**
             * Configuration linkPreviews.
             * @member {boolean} linkPreviews
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.linkPreviews = false;

            /**
             * Encodes the specified Configuration message. Does not implicitly {@link signalservice.SyncMessage.Configuration.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.Configuration.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.readReceipts != null && Object.hasOwnProperty.call(message, "readReceipts"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.readReceipts);
                if (message.unidentifiedDeliveryIndicators != null && Object.hasOwnProperty.call(message, "unidentifiedDeliveryIndicators"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.unidentifiedDeliveryIndicators);
                if (message.typingIndicators != null && Object.hasOwnProperty.call(message, "typingIndicators"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.typingIndicators);
                if (message.provisioningVersion != null && Object.hasOwnProperty.call(message, "provisioningVersion"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.provisioningVersion);
                if (message.linkPreviews != null && Object.hasOwnProperty.call(message, "linkPreviews"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.linkPreviews);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Configuration message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Configuration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Configuration message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Configuration();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.readReceipts = reader.bool();
                        break;
                    case 2:
                        message.unidentifiedDeliveryIndicators = reader.bool();
                        break;
                    case 3:
                        message.typingIndicators = reader.bool();
                        break;
                    case 5:
                        message.provisioningVersion = reader.uint32();
                        break;
                    case 6:
                        message.linkPreviews = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Configuration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             */
            Configuration.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Configuration)
                    return object;
                var message = new $root.signalservice.SyncMessage.Configuration();
                if (object.readReceipts != null)
                    message.readReceipts = Boolean(object.readReceipts);
                if (object.unidentifiedDeliveryIndicators != null)
                    message.unidentifiedDeliveryIndicators = Boolean(object.unidentifiedDeliveryIndicators);
                if (object.typingIndicators != null)
                    message.typingIndicators = Boolean(object.typingIndicators);
                if (object.provisioningVersion != null)
                    message.provisioningVersion = object.provisioningVersion >>> 0;
                if (object.linkPreviews != null)
                    message.linkPreviews = Boolean(object.linkPreviews);
                return message;
            };

            /**
             * Creates a plain object from a Configuration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.Configuration} message Configuration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Configuration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.readReceipts = false;
                    object.unidentifiedDeliveryIndicators = false;
                    object.typingIndicators = false;
                    object.provisioningVersion = 0;
                    object.linkPreviews = false;
                }
                if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                    object.readReceipts = message.readReceipts;
                if (message.unidentifiedDeliveryIndicators != null && message.hasOwnProperty("unidentifiedDeliveryIndicators"))
                    object.unidentifiedDeliveryIndicators = message.unidentifiedDeliveryIndicators;
                if (message.typingIndicators != null && message.hasOwnProperty("typingIndicators"))
                    object.typingIndicators = message.typingIndicators;
                if (message.provisioningVersion != null && message.hasOwnProperty("provisioningVersion"))
                    object.provisioningVersion = message.provisioningVersion;
                if (message.linkPreviews != null && message.hasOwnProperty("linkPreviews"))
                    object.linkPreviews = message.linkPreviews;
                return object;
            };

            /**
             * Converts this Configuration to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Configuration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Configuration;
        })();

        SyncMessage.StickerPackOperation = (function() {

            /**
             * Properties of a StickerPackOperation.
             * @memberof signalservice.SyncMessage
             * @interface IStickerPackOperation
             * @property {Uint8Array|null} [packId] StickerPackOperation packId
             * @property {Uint8Array|null} [packKey] StickerPackOperation packKey
             * @property {signalservice.SyncMessage.StickerPackOperation.Type|null} [type] StickerPackOperation type
             */

            /**
             * Constructs a new StickerPackOperation.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a StickerPackOperation.
             * @implements IStickerPackOperation
             * @constructor
             * @param {signalservice.SyncMessage.IStickerPackOperation=} [properties] Properties to set
             */
            function StickerPackOperation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StickerPackOperation packId.
             * @member {Uint8Array} packId
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.packId = $util.newBuffer([]);

            /**
             * StickerPackOperation packKey.
             * @member {Uint8Array} packKey
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.packKey = $util.newBuffer([]);

            /**
             * StickerPackOperation type.
             * @member {signalservice.SyncMessage.StickerPackOperation.Type} type
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.type = 0;

            /**
             * Encodes the specified StickerPackOperation message. Does not implicitly {@link signalservice.SyncMessage.StickerPackOperation.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.IStickerPackOperation} message StickerPackOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerPackOperation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.StickerPackOperation.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.packId != null && Object.hasOwnProperty.call(message, "packId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.packId);
                if (message.packKey != null && Object.hasOwnProperty.call(message, "packKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packKey);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified StickerPackOperation message, length delimited. Does not implicitly {@link signalservice.SyncMessage.StickerPackOperation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.IStickerPackOperation} message StickerPackOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerPackOperation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StickerPackOperation message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerPackOperation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.StickerPackOperation();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packId = reader.bytes();
                        break;
                    case 2:
                        message.packKey = reader.bytes();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StickerPackOperation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerPackOperation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a StickerPackOperation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             */
            StickerPackOperation.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.StickerPackOperation)
                    return object;
                var message = new $root.signalservice.SyncMessage.StickerPackOperation();
                if (object.packId != null)
                    if (typeof object.packId === "string")
                        $util.base64.decode(object.packId, message.packId = $util.newBuffer($util.base64.length(object.packId)), 0);
                    else if (object.packId.length)
                        message.packId = object.packId;
                if (object.packKey != null)
                    if (typeof object.packKey === "string")
                        $util.base64.decode(object.packKey, message.packKey = $util.newBuffer($util.base64.length(object.packKey)), 0);
                    else if (object.packKey.length)
                        message.packKey = object.packKey;
                switch (object.type) {
                case "INSTALL":
                case 0:
                    message.type = 0;
                    break;
                case "REMOVE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a StickerPackOperation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.StickerPackOperation} message StickerPackOperation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StickerPackOperation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.packId = "";
                    else {
                        object.packId = [];
                        if (options.bytes !== Array)
                            object.packId = $util.newBuffer(object.packId);
                    }
                    if (options.bytes === String)
                        object.packKey = "";
                    else {
                        object.packKey = [];
                        if (options.bytes !== Array)
                            object.packKey = $util.newBuffer(object.packKey);
                    }
                    object.type = options.enums === String ? "INSTALL" : 0;
                }
                if (message.packId != null && message.hasOwnProperty("packId"))
                    object.packId = options.bytes === String ? $util.base64.encode(message.packId, 0, message.packId.length) : options.bytes === Array ? Array.prototype.slice.call(message.packId) : message.packId;
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    object.packKey = options.bytes === String ? $util.base64.encode(message.packKey, 0, message.packKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.packKey) : message.packKey;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.StickerPackOperation.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this StickerPackOperation to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StickerPackOperation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.StickerPackOperation.Type
             * @enum {number}
             * @property {number} INSTALL=0 INSTALL value
             * @property {number} REMOVE=1 REMOVE value
             */
            StickerPackOperation.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INSTALL"] = 0;
                values[valuesById[1] = "REMOVE"] = 1;
                return values;
            })();

            return StickerPackOperation;
        })();

        SyncMessage.ViewOnceOpen = (function() {

            /**
             * Properties of a ViewOnceOpen.
             * @memberof signalservice.SyncMessage
             * @interface IViewOnceOpen
             * @property {string|null} [sender] ViewOnceOpen sender
             * @property {string|null} [senderUuid] ViewOnceOpen senderUuid
             * @property {Long|null} [timestamp] ViewOnceOpen timestamp
             */

            /**
             * Constructs a new ViewOnceOpen.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a ViewOnceOpen.
             * @implements IViewOnceOpen
             * @constructor
             * @param {signalservice.SyncMessage.IViewOnceOpen=} [properties] Properties to set
             */
            function ViewOnceOpen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ViewOnceOpen sender.
             * @member {string} sender
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.sender = "";

            /**
             * ViewOnceOpen senderUuid.
             * @member {string} senderUuid
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.senderUuid = "";

            /**
             * ViewOnceOpen timestamp.
             * @member {Long} timestamp
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified ViewOnceOpen message. Does not implicitly {@link signalservice.SyncMessage.ViewOnceOpen.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.IViewOnceOpen} message ViewOnceOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewOnceOpen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.ViewOnceOpen.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderUuid != null && Object.hasOwnProperty.call(message, "senderUuid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderUuid);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified ViewOnceOpen message, length delimited. Does not implicitly {@link signalservice.SyncMessage.ViewOnceOpen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.IViewOnceOpen} message ViewOnceOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewOnceOpen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ViewOnceOpen message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewOnceOpen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.ViewOnceOpen();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sender = reader.string();
                        break;
                    case 3:
                        message.senderUuid = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ViewOnceOpen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewOnceOpen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a ViewOnceOpen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             */
            ViewOnceOpen.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.ViewOnceOpen)
                    return object;
                var message = new $root.signalservice.SyncMessage.ViewOnceOpen();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.senderUuid != null)
                    message.senderUuid = String(object.senderUuid);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ViewOnceOpen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.ViewOnceOpen} message ViewOnceOpen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ViewOnceOpen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sender = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderUuid = "";
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderUuid != null && message.hasOwnProperty("senderUuid"))
                    object.senderUuid = message.senderUuid;
                return object;
            };

            /**
             * Converts this ViewOnceOpen to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ViewOnceOpen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ViewOnceOpen;
        })();

        SyncMessage.MessageRequestResponse = (function() {

            /**
             * Properties of a MessageRequestResponse.
             * @memberof signalservice.SyncMessage
             * @interface IMessageRequestResponse
             * @property {string|null} [threadE164] MessageRequestResponse threadE164
             * @property {string|null} [threadUuid] MessageRequestResponse threadUuid
             * @property {Uint8Array|null} [groupId] MessageRequestResponse groupId
             * @property {signalservice.SyncMessage.MessageRequestResponse.Type|null} [type] MessageRequestResponse type
             */

            /**
             * Constructs a new MessageRequestResponse.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a MessageRequestResponse.
             * @implements IMessageRequestResponse
             * @constructor
             * @param {signalservice.SyncMessage.IMessageRequestResponse=} [properties] Properties to set
             */
            function MessageRequestResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageRequestResponse threadE164.
             * @member {string} threadE164
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.threadE164 = "";

            /**
             * MessageRequestResponse threadUuid.
             * @member {string} threadUuid
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.threadUuid = "";

            /**
             * MessageRequestResponse groupId.
             * @member {Uint8Array} groupId
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.groupId = $util.newBuffer([]);

            /**
             * MessageRequestResponse type.
             * @member {signalservice.SyncMessage.MessageRequestResponse.Type} type
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.type = 0;

            /**
             * Encodes the specified MessageRequestResponse message. Does not implicitly {@link signalservice.SyncMessage.MessageRequestResponse.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.IMessageRequestResponse} message MessageRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageRequestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.MessageRequestResponse.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.threadE164 != null && Object.hasOwnProperty.call(message, "threadE164"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.threadE164);
                if (message.threadUuid != null && Object.hasOwnProperty.call(message, "threadUuid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadUuid);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified MessageRequestResponse message, length delimited. Does not implicitly {@link signalservice.SyncMessage.MessageRequestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.IMessageRequestResponse} message MessageRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageRequestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageRequestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageRequestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.MessageRequestResponse();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.threadE164 = reader.string();
                        break;
                    case 2:
                        message.threadUuid = reader.string();
                        break;
                    case 3:
                        message.groupId = reader.bytes();
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageRequestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageRequestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a MessageRequestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             */
            MessageRequestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.MessageRequestResponse)
                    return object;
                var message = new $root.signalservice.SyncMessage.MessageRequestResponse();
                if (object.threadE164 != null)
                    message.threadE164 = String(object.threadE164);
                if (object.threadUuid != null)
                    message.threadUuid = String(object.threadUuid);
                if (object.groupId != null)
                    if (typeof object.groupId === "string")
                        $util.base64.decode(object.groupId, message.groupId = $util.newBuffer($util.base64.length(object.groupId)), 0);
                    else if (object.groupId.length)
                        message.groupId = object.groupId;
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "ACCEPT":
                case 1:
                    message.type = 1;
                    break;
                case "DELETE":
                case 2:
                    message.type = 2;
                    break;
                case "BLOCK":
                case 3:
                    message.type = 3;
                    break;
                case "BLOCK_AND_DELETE":
                case 4:
                    message.type = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageRequestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.MessageRequestResponse} message MessageRequestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageRequestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.threadE164 = "";
                    object.threadUuid = "";
                    if (options.bytes === String)
                        object.groupId = "";
                    else {
                        object.groupId = [];
                        if (options.bytes !== Array)
                            object.groupId = $util.newBuffer(object.groupId);
                    }
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.threadE164 != null && message.hasOwnProperty("threadE164"))
                    object.threadE164 = message.threadE164;
                if (message.threadUuid != null && message.hasOwnProperty("threadUuid"))
                    object.threadUuid = message.threadUuid;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = options.bytes === String ? $util.base64.encode(message.groupId, 0, message.groupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupId) : message.groupId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.MessageRequestResponse.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this MessageRequestResponse to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageRequestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.MessageRequestResponse.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} ACCEPT=1 ACCEPT value
             * @property {number} DELETE=2 DELETE value
             * @property {number} BLOCK=3 BLOCK value
             * @property {number} BLOCK_AND_DELETE=4 BLOCK_AND_DELETE value
             */
            MessageRequestResponse.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "ACCEPT"] = 1;
                values[valuesById[2] = "DELETE"] = 2;
                values[valuesById[3] = "BLOCK"] = 3;
                values[valuesById[4] = "BLOCK_AND_DELETE"] = 4;
                return values;
            })();

            return MessageRequestResponse;
        })();

        SyncMessage.FetchLatest = (function() {

            /**
             * Properties of a FetchLatest.
             * @memberof signalservice.SyncMessage
             * @interface IFetchLatest
             * @property {signalservice.SyncMessage.FetchLatest.Type|null} [type] FetchLatest type
             */

            /**
             * Constructs a new FetchLatest.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a FetchLatest.
             * @implements IFetchLatest
             * @constructor
             * @param {signalservice.SyncMessage.IFetchLatest=} [properties] Properties to set
             */
            function FetchLatest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FetchLatest type.
             * @member {signalservice.SyncMessage.FetchLatest.Type} type
             * @memberof signalservice.SyncMessage.FetchLatest
             * @instance
             */
            FetchLatest.prototype.type = 0;

            /**
             * Encodes the specified FetchLatest message. Does not implicitly {@link signalservice.SyncMessage.FetchLatest.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.IFetchLatest} message FetchLatest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchLatest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.FetchLatest.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified FetchLatest message, length delimited. Does not implicitly {@link signalservice.SyncMessage.FetchLatest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.IFetchLatest} message FetchLatest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchLatest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FetchLatest message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchLatest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.FetchLatest();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FetchLatest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchLatest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a FetchLatest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             */
            FetchLatest.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.FetchLatest)
                    return object;
                var message = new $root.signalservice.SyncMessage.FetchLatest();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "LOCAL_PROFILE":
                case 1:
                    message.type = 1;
                    break;
                case "STORAGE_MANIFEST":
                case 2:
                    message.type = 2;
                    break;
                case "SUBSCRIPTION_STATUS":
                case 3:
                    message.type = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FetchLatest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.FetchLatest} message FetchLatest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FetchLatest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.FetchLatest.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this FetchLatest to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.FetchLatest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FetchLatest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.FetchLatest.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} LOCAL_PROFILE=1 LOCAL_PROFILE value
             * @property {number} STORAGE_MANIFEST=2 STORAGE_MANIFEST value
             * @property {number} SUBSCRIPTION_STATUS=3 SUBSCRIPTION_STATUS value
             */
            FetchLatest.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "LOCAL_PROFILE"] = 1;
                values[valuesById[2] = "STORAGE_MANIFEST"] = 2;
                values[valuesById[3] = "SUBSCRIPTION_STATUS"] = 3;
                return values;
            })();

            return FetchLatest;
        })();

        SyncMessage.PniChangeNumber = (function() {

            /**
             * Properties of a PniChangeNumber.
             * @memberof signalservice.SyncMessage
             * @interface IPniChangeNumber
             * @property {Uint8Array|null} [identityKeyPair] PniChangeNumber identityKeyPair
             * @property {Uint8Array|null} [signedPreKey] PniChangeNumber signedPreKey
             * @property {number|null} [registrationId] PniChangeNumber registrationId
             */

            /**
             * Constructs a new PniChangeNumber.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a PniChangeNumber.
             * @implements IPniChangeNumber
             * @constructor
             * @param {signalservice.SyncMessage.IPniChangeNumber=} [properties] Properties to set
             */
            function PniChangeNumber(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PniChangeNumber identityKeyPair.
             * @member {Uint8Array} identityKeyPair
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.identityKeyPair = $util.newBuffer([]);

            /**
             * PniChangeNumber signedPreKey.
             * @member {Uint8Array} signedPreKey
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.signedPreKey = $util.newBuffer([]);

            /**
             * PniChangeNumber registrationId.
             * @member {number} registrationId
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.registrationId = 0;

            /**
             * Encodes the specified PniChangeNumber message. Does not implicitly {@link signalservice.SyncMessage.PniChangeNumber.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.IPniChangeNumber} message PniChangeNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniChangeNumber.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SyncMessage.PniChangeNumber.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.identityKeyPair != null && Object.hasOwnProperty.call(message, "identityKeyPair"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.identityKeyPair);
                if (message.signedPreKey != null && Object.hasOwnProperty.call(message, "signedPreKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signedPreKey);
                if (message.registrationId != null && Object.hasOwnProperty.call(message, "registrationId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.registrationId);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified PniChangeNumber message, length delimited. Does not implicitly {@link signalservice.SyncMessage.PniChangeNumber.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.IPniChangeNumber} message PniChangeNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniChangeNumber.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PniChangeNumber message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniChangeNumber.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.PniChangeNumber();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.identityKeyPair = reader.bytes();
                        break;
                    case 2:
                        message.signedPreKey = reader.bytes();
                        break;
                    case 3:
                        message.registrationId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PniChangeNumber message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniChangeNumber.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a PniChangeNumber message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             */
            PniChangeNumber.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.PniChangeNumber)
                    return object;
                var message = new $root.signalservice.SyncMessage.PniChangeNumber();
                if (object.identityKeyPair != null)
                    if (typeof object.identityKeyPair === "string")
                        $util.base64.decode(object.identityKeyPair, message.identityKeyPair = $util.newBuffer($util.base64.length(object.identityKeyPair)), 0);
                    else if (object.identityKeyPair.length)
                        message.identityKeyPair = object.identityKeyPair;
                if (object.signedPreKey != null)
                    if (typeof object.signedPreKey === "string")
                        $util.base64.decode(object.signedPreKey, message.signedPreKey = $util.newBuffer($util.base64.length(object.signedPreKey)), 0);
                    else if (object.signedPreKey.length)
                        message.signedPreKey = object.signedPreKey;
                if (object.registrationId != null)
                    message.registrationId = object.registrationId >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PniChangeNumber message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.PniChangeNumber} message PniChangeNumber
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PniChangeNumber.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.identityKeyPair = "";
                    else {
                        object.identityKeyPair = [];
                        if (options.bytes !== Array)
                            object.identityKeyPair = $util.newBuffer(object.identityKeyPair);
                    }
                    if (options.bytes === String)
                        object.signedPreKey = "";
                    else {
                        object.signedPreKey = [];
                        if (options.bytes !== Array)
                            object.signedPreKey = $util.newBuffer(object.signedPreKey);
                    }
                    object.registrationId = 0;
                }
                if (message.identityKeyPair != null && message.hasOwnProperty("identityKeyPair"))
                    object.identityKeyPair = options.bytes === String ? $util.base64.encode(message.identityKeyPair, 0, message.identityKeyPair.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKeyPair) : message.identityKeyPair;
                if (message.signedPreKey != null && message.hasOwnProperty("signedPreKey"))
                    object.signedPreKey = options.bytes === String ? $util.base64.encode(message.signedPreKey, 0, message.signedPreKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedPreKey) : message.signedPreKey;
                if (message.registrationId != null && message.hasOwnProperty("registrationId"))
                    object.registrationId = message.registrationId;
                return object;
            };

            /**
             * Converts this PniChangeNumber to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PniChangeNumber.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PniChangeNumber;
        })();

        return SyncMessage;
    })();

    signalservice.AttachmentPointer = (function() {

        /**
         * Properties of an AttachmentPointer.
         * @memberof signalservice
         * @interface IAttachmentPointer
         * @property {Long|null} [cdnId] AttachmentPointer cdnId
         * @property {string|null} [cdnKey] AttachmentPointer cdnKey
         * @property {string|null} [contentType] AttachmentPointer contentType
         * @property {Uint8Array|null} [key] AttachmentPointer key
         * @property {number|null} [size] AttachmentPointer size
         * @property {Uint8Array|null} [thumbnail] AttachmentPointer thumbnail
         * @property {Uint8Array|null} [digest] AttachmentPointer digest
         * @property {string|null} [fileName] AttachmentPointer fileName
         * @property {number|null} [flags] AttachmentPointer flags
         * @property {number|null} [width] AttachmentPointer width
         * @property {number|null} [height] AttachmentPointer height
         * @property {string|null} [caption] AttachmentPointer caption
         * @property {string|null} [blurHash] AttachmentPointer blurHash
         * @property {Long|null} [uploadTimestamp] AttachmentPointer uploadTimestamp
         * @property {number|null} [cdnNumber] AttachmentPointer cdnNumber
         */

        /**
         * Constructs a new AttachmentPointer.
         * @memberof signalservice
         * @classdesc Represents an AttachmentPointer.
         * @implements IAttachmentPointer
         * @constructor
         * @param {signalservice.IAttachmentPointer=} [properties] Properties to set
         */
        function AttachmentPointer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttachmentPointer cdnId.
         * @member {Long|null|undefined} cdnId
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnId = null;

        /**
         * AttachmentPointer cdnKey.
         * @member {string|null|undefined} cdnKey
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnKey = null;

        /**
         * AttachmentPointer contentType.
         * @member {string} contentType
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.contentType = "";

        /**
         * AttachmentPointer key.
         * @member {Uint8Array} key
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.key = $util.newBuffer([]);

        /**
         * AttachmentPointer size.
         * @member {number} size
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.size = 0;

        /**
         * AttachmentPointer thumbnail.
         * @member {Uint8Array} thumbnail
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.thumbnail = $util.newBuffer([]);

        /**
         * AttachmentPointer digest.
         * @member {Uint8Array} digest
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.digest = $util.newBuffer([]);

        /**
         * AttachmentPointer fileName.
         * @member {string} fileName
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.fileName = "";

        /**
         * AttachmentPointer flags.
         * @member {number} flags
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.flags = 0;

        /**
         * AttachmentPointer width.
         * @member {number} width
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.width = 0;

        /**
         * AttachmentPointer height.
         * @member {number} height
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.height = 0;

        /**
         * AttachmentPointer caption.
         * @member {string} caption
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.caption = "";

        /**
         * AttachmentPointer blurHash.
         * @member {string} blurHash
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.blurHash = "";

        /**
         * AttachmentPointer uploadTimestamp.
         * @member {Long} uploadTimestamp
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.uploadTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AttachmentPointer cdnNumber.
         * @member {number} cdnNumber
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnNumber = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AttachmentPointer attachmentIdentifier.
         * @member {"cdnId"|"cdnKey"|undefined} attachmentIdentifier
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        Object.defineProperty(AttachmentPointer.prototype, "attachmentIdentifier", {
            get: $util.oneOfGetter($oneOfFields = ["cdnId", "cdnKey"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified AttachmentPointer message. Does not implicitly {@link signalservice.AttachmentPointer.verify|verify} messages.
         * @function encode
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.IAttachmentPointer} message AttachmentPointer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttachmentPointer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.AttachmentPointer.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.cdnId != null && Object.hasOwnProperty.call(message, "cdnId"))
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.cdnId);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);
            if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.thumbnail);
            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.digest);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.height);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.caption);
            if (message.blurHash != null && Object.hasOwnProperty.call(message, "blurHash"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.blurHash);
            if (message.uploadTimestamp != null && Object.hasOwnProperty.call(message, "uploadTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.uploadTimestamp);
            if (message.cdnNumber != null && Object.hasOwnProperty.call(message, "cdnNumber"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.cdnNumber);
            if (message.cdnKey != null && Object.hasOwnProperty.call(message, "cdnKey"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.cdnKey);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified AttachmentPointer message, length delimited. Does not implicitly {@link signalservice.AttachmentPointer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.IAttachmentPointer} message AttachmentPointer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttachmentPointer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttachmentPointer message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttachmentPointer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AttachmentPointer();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cdnId = reader.fixed64();
                    break;
                case 15:
                    message.cdnKey = reader.string();
                    break;
                case 2:
                    message.contentType = reader.string();
                    break;
                case 3:
                    message.key = reader.bytes();
                    break;
                case 4:
                    message.size = reader.uint32();
                    break;
                case 5:
                    message.thumbnail = reader.bytes();
                    break;
                case 6:
                    message.digest = reader.bytes();
                    break;
                case 7:
                    message.fileName = reader.string();
                    break;
                case 8:
                    message.flags = reader.uint32();
                    break;
                case 9:
                    message.width = reader.uint32();
                    break;
                case 10:
                    message.height = reader.uint32();
                    break;
                case 11:
                    message.caption = reader.string();
                    break;
                case 12:
                    message.blurHash = reader.string();
                    break;
                case 13:
                    message.uploadTimestamp = reader.uint64();
                    break;
                case 14:
                    message.cdnNumber = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttachmentPointer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttachmentPointer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an AttachmentPointer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         */
        AttachmentPointer.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.AttachmentPointer)
                return object;
            var message = new $root.signalservice.AttachmentPointer();
            if (object.cdnId != null)
                if ($util.Long)
                    (message.cdnId = $util.Long.fromValue(object.cdnId)).unsigned = false;
                else if (typeof object.cdnId === "string")
                    message.cdnId = parseInt(object.cdnId, 10);
                else if (typeof object.cdnId === "number")
                    message.cdnId = object.cdnId;
                else if (typeof object.cdnId === "object")
                    message.cdnId = new $util.LongBits(object.cdnId.low >>> 0, object.cdnId.high >>> 0).toNumber();
            if (object.cdnKey != null)
                message.cdnKey = String(object.cdnKey);
            if (object.contentType != null)
                message.contentType = String(object.contentType);
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.size != null)
                message.size = object.size >>> 0;
            if (object.thumbnail != null)
                if (typeof object.thumbnail === "string")
                    $util.base64.decode(object.thumbnail, message.thumbnail = $util.newBuffer($util.base64.length(object.thumbnail)), 0);
                else if (object.thumbnail.length)
                    message.thumbnail = object.thumbnail;
            if (object.digest != null)
                if (typeof object.digest === "string")
                    $util.base64.decode(object.digest, message.digest = $util.newBuffer($util.base64.length(object.digest)), 0);
                else if (object.digest.length)
                    message.digest = object.digest;
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.blurHash != null)
                message.blurHash = String(object.blurHash);
            if (object.uploadTimestamp != null)
                if ($util.Long)
                    (message.uploadTimestamp = $util.Long.fromValue(object.uploadTimestamp)).unsigned = true;
                else if (typeof object.uploadTimestamp === "string")
                    message.uploadTimestamp = parseInt(object.uploadTimestamp, 10);
                else if (typeof object.uploadTimestamp === "number")
                    message.uploadTimestamp = object.uploadTimestamp;
                else if (typeof object.uploadTimestamp === "object")
                    message.uploadTimestamp = new $util.LongBits(object.uploadTimestamp.low >>> 0, object.uploadTimestamp.high >>> 0).toNumber(true);
            if (object.cdnNumber != null)
                message.cdnNumber = object.cdnNumber >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an AttachmentPointer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.AttachmentPointer} message AttachmentPointer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AttachmentPointer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contentType = "";
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                object.size = 0;
                if (options.bytes === String)
                    object.thumbnail = "";
                else {
                    object.thumbnail = [];
                    if (options.bytes !== Array)
                        object.thumbnail = $util.newBuffer(object.thumbnail);
                }
                if (options.bytes === String)
                    object.digest = "";
                else {
                    object.digest = [];
                    if (options.bytes !== Array)
                        object.digest = $util.newBuffer(object.digest);
                }
                object.fileName = "";
                object.flags = 0;
                object.width = 0;
                object.height = 0;
                object.caption = "";
                object.blurHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.uploadTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uploadTimestamp = options.longs === String ? "0" : 0;
                object.cdnNumber = 0;
            }
            if (message.cdnId != null && message.hasOwnProperty("cdnId")) {
                if (typeof message.cdnId === "number")
                    object.cdnId = options.longs === String ? String(message.cdnId) : message.cdnId;
                else
                    object.cdnId = options.longs === String ? $util.Long.prototype.toString.call(message.cdnId) : options.longs === Number ? new $util.LongBits(message.cdnId.low >>> 0, message.cdnId.high >>> 0).toNumber() : message.cdnId;
                if (options.oneofs)
                    object.attachmentIdentifier = "cdnId";
            }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                object.thumbnail = options.bytes === String ? $util.base64.encode(message.thumbnail, 0, message.thumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnail) : message.thumbnail;
            if (message.digest != null && message.hasOwnProperty("digest"))
                object.digest = options.bytes === String ? $util.base64.encode(message.digest, 0, message.digest.length) : options.bytes === Array ? Array.prototype.slice.call(message.digest) : message.digest;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.blurHash != null && message.hasOwnProperty("blurHash"))
                object.blurHash = message.blurHash;
            if (message.uploadTimestamp != null && message.hasOwnProperty("uploadTimestamp"))
                if (typeof message.uploadTimestamp === "number")
                    object.uploadTimestamp = options.longs === String ? String(message.uploadTimestamp) : message.uploadTimestamp;
                else
                    object.uploadTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.uploadTimestamp) : options.longs === Number ? new $util.LongBits(message.uploadTimestamp.low >>> 0, message.uploadTimestamp.high >>> 0).toNumber(true) : message.uploadTimestamp;
            if (message.cdnNumber != null && message.hasOwnProperty("cdnNumber"))
                object.cdnNumber = message.cdnNumber;
            if (message.cdnKey != null && message.hasOwnProperty("cdnKey")) {
                object.cdnKey = message.cdnKey;
                if (options.oneofs)
                    object.attachmentIdentifier = "cdnKey";
            }
            return object;
        };

        /**
         * Converts this AttachmentPointer to JSON.
         * @function toJSON
         * @memberof signalservice.AttachmentPointer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AttachmentPointer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Flags enum.
         * @name signalservice.AttachmentPointer.Flags
         * @enum {number}
         * @property {number} VOICE_MESSAGE=1 VOICE_MESSAGE value
         * @property {number} BORDERLESS=2 BORDERLESS value
         * @property {number} GIF=8 GIF value
         */
        AttachmentPointer.Flags = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "VOICE_MESSAGE"] = 1;
            values[valuesById[2] = "BORDERLESS"] = 2;
            values[valuesById[8] = "GIF"] = 8;
            return values;
        })();

        return AttachmentPointer;
    })();

    signalservice.GroupContext = (function() {

        /**
         * Properties of a GroupContext.
         * @memberof signalservice
         * @interface IGroupContext
         * @property {Uint8Array|null} [id] GroupContext id
         * @property {signalservice.GroupContext.Type|null} [type] GroupContext type
         * @property {string|null} [name] GroupContext name
         * @property {Array.<string>|null} [membersE164] GroupContext membersE164
         * @property {signalservice.IAttachmentPointer|null} [avatar] GroupContext avatar
         */

        /**
         * Constructs a new GroupContext.
         * @memberof signalservice
         * @classdesc Represents a GroupContext.
         * @implements IGroupContext
         * @constructor
         * @param {signalservice.IGroupContext=} [properties] Properties to set
         */
        function GroupContext(properties) {
            this.membersE164 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupContext id.
         * @member {Uint8Array} id
         * @memberof signalservice.GroupContext
         * @instance
         */
        GroupContext.prototype.id = $util.newBuffer([]);

        /**
         * GroupContext type.
         * @member {signalservice.GroupContext.Type} type
         * @memberof signalservice.GroupContext
         * @instance
         */
        GroupContext.prototype.type = 0;

        /**
         * GroupContext name.
         * @member {string} name
         * @memberof signalservice.GroupContext
         * @instance
         */
        GroupContext.prototype.name = "";

        /**
         * GroupContext membersE164.
         * @member {Array.<string>} membersE164
         * @memberof signalservice.GroupContext
         * @instance
         */
        GroupContext.prototype.membersE164 = $util.emptyArray;

        /**
         * GroupContext avatar.
         * @member {signalservice.IAttachmentPointer|null|undefined} avatar
         * @memberof signalservice.GroupContext
         * @instance
         */
        GroupContext.prototype.avatar = null;

        /**
         * Encodes the specified GroupContext message. Does not implicitly {@link signalservice.GroupContext.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupContext
         * @static
         * @param {signalservice.IGroupContext} message GroupContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupContext.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.membersE164 != null && message.membersE164.length)
                for (var i = 0; i < message.membersE164.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.membersE164[i]);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.signalservice.AttachmentPointer.encode(message.avatar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupContext message, length delimited. Does not implicitly {@link signalservice.GroupContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupContext
         * @static
         * @param {signalservice.IGroupContext} message GroupContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupContext message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupContext} GroupContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupContext();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    if (!(message.membersE164 && message.membersE164.length))
                        message.membersE164 = [];
                    message.membersE164.push(reader.string());
                    break;
                case 5:
                    message.avatar = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupContext} GroupContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupContext} GroupContext
         */
        GroupContext.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupContext)
                return object;
            var message = new $root.signalservice.GroupContext();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "UPDATE":
            case 1:
                message.type = 1;
                break;
            case "DELIVER":
            case 2:
                message.type = 2;
                break;
            case "QUIT":
            case 3:
                message.type = 3;
                break;
            case "REQUEST_INFO":
            case 4:
                message.type = 4;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.membersE164) {
                if (!Array.isArray(object.membersE164))
                    throw TypeError(".signalservice.GroupContext.membersE164: array expected");
                message.membersE164 = [];
                for (var i = 0; i < object.membersE164.length; ++i)
                    message.membersE164[i] = String(object.membersE164[i]);
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".signalservice.GroupContext.avatar: object expected");
                message.avatar = $root.signalservice.AttachmentPointer.fromObject(object.avatar);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupContext
         * @static
         * @param {signalservice.GroupContext} message GroupContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.membersE164 = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.name = "";
                object.avatar = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.GroupContext.Type[message.type] : message.type;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.membersE164 && message.membersE164.length) {
                object.membersE164 = [];
                for (var j = 0; j < message.membersE164.length; ++j)
                    object.membersE164[j] = message.membersE164[j];
            }
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = $root.signalservice.AttachmentPointer.toObject(message.avatar, options);
            return object;
        };

        /**
         * Converts this GroupContext to JSON.
         * @function toJSON
         * @memberof signalservice.GroupContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name signalservice.GroupContext.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} UPDATE=1 UPDATE value
         * @property {number} DELIVER=2 DELIVER value
         * @property {number} QUIT=3 QUIT value
         * @property {number} REQUEST_INFO=4 REQUEST_INFO value
         */
        GroupContext.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "UPDATE"] = 1;
            values[valuesById[2] = "DELIVER"] = 2;
            values[valuesById[3] = "QUIT"] = 3;
            values[valuesById[4] = "REQUEST_INFO"] = 4;
            return values;
        })();

        return GroupContext;
    })();

    signalservice.GroupContextV2 = (function() {

        /**
         * Properties of a GroupContextV2.
         * @memberof signalservice
         * @interface IGroupContextV2
         * @property {Uint8Array|null} [masterKey] GroupContextV2 masterKey
         * @property {number|null} [revision] GroupContextV2 revision
         * @property {Uint8Array|null} [groupChange] GroupContextV2 groupChange
         */

        /**
         * Constructs a new GroupContextV2.
         * @memberof signalservice
         * @classdesc Represents a GroupContextV2.
         * @implements IGroupContextV2
         * @constructor
         * @param {signalservice.IGroupContextV2=} [properties] Properties to set
         */
        function GroupContextV2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupContextV2 masterKey.
         * @member {Uint8Array} masterKey
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.masterKey = $util.newBuffer([]);

        /**
         * GroupContextV2 revision.
         * @member {number} revision
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.revision = 0;

        /**
         * GroupContextV2 groupChange.
         * @member {Uint8Array} groupChange
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.groupChange = $util.newBuffer([]);

        /**
         * Encodes the specified GroupContextV2 message. Does not implicitly {@link signalservice.GroupContextV2.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.IGroupContextV2} message GroupContextV2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContextV2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupContextV2.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.masterKey != null && Object.hasOwnProperty.call(message, "masterKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterKey);
            if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.revision);
            if (message.groupChange != null && Object.hasOwnProperty.call(message, "groupChange"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupChange);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupContextV2 message, length delimited. Does not implicitly {@link signalservice.GroupContextV2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.IGroupContextV2} message GroupContextV2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContextV2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupContextV2 message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupContextV2} GroupContextV2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContextV2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupContextV2();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.masterKey = reader.bytes();
                    break;
                case 2:
                    message.revision = reader.uint32();
                    break;
                case 3:
                    message.groupChange = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupContextV2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupContextV2} GroupContextV2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContextV2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupContextV2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupContextV2} GroupContextV2
         */
        GroupContextV2.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupContextV2)
                return object;
            var message = new $root.signalservice.GroupContextV2();
            if (object.masterKey != null)
                if (typeof object.masterKey === "string")
                    $util.base64.decode(object.masterKey, message.masterKey = $util.newBuffer($util.base64.length(object.masterKey)), 0);
                else if (object.masterKey.length)
                    message.masterKey = object.masterKey;
            if (object.revision != null)
                message.revision = object.revision >>> 0;
            if (object.groupChange != null)
                if (typeof object.groupChange === "string")
                    $util.base64.decode(object.groupChange, message.groupChange = $util.newBuffer($util.base64.length(object.groupChange)), 0);
                else if (object.groupChange.length)
                    message.groupChange = object.groupChange;
            return message;
        };

        /**
         * Creates a plain object from a GroupContextV2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.GroupContextV2} message GroupContextV2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupContextV2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.masterKey = "";
                else {
                    object.masterKey = [];
                    if (options.bytes !== Array)
                        object.masterKey = $util.newBuffer(object.masterKey);
                }
                object.revision = 0;
                if (options.bytes === String)
                    object.groupChange = "";
                else {
                    object.groupChange = [];
                    if (options.bytes !== Array)
                        object.groupChange = $util.newBuffer(object.groupChange);
                }
            }
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                object.masterKey = options.bytes === String ? $util.base64.encode(message.masterKey, 0, message.masterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterKey) : message.masterKey;
            if (message.revision != null && message.hasOwnProperty("revision"))
                object.revision = message.revision;
            if (message.groupChange != null && message.hasOwnProperty("groupChange"))
                object.groupChange = options.bytes === String ? $util.base64.encode(message.groupChange, 0, message.groupChange.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupChange) : message.groupChange;
            return object;
        };

        /**
         * Converts this GroupContextV2 to JSON.
         * @function toJSON
         * @memberof signalservice.GroupContextV2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupContextV2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupContextV2;
    })();

    signalservice.ContactDetails = (function() {

        /**
         * Properties of a ContactDetails.
         * @memberof signalservice
         * @interface IContactDetails
         * @property {string|null} [number] ContactDetails number
         * @property {string|null} [uuid] ContactDetails uuid
         * @property {string|null} [name] ContactDetails name
         * @property {signalservice.ContactDetails.IAvatar|null} [avatar] ContactDetails avatar
         * @property {string|null} [color] ContactDetails color
         * @property {signalservice.IVerified|null} [verified] ContactDetails verified
         * @property {Uint8Array|null} [profileKey] ContactDetails profileKey
         * @property {boolean|null} [blocked] ContactDetails blocked
         * @property {number|null} [expireTimer] ContactDetails expireTimer
         * @property {number|null} [inboxPosition] ContactDetails inboxPosition
         */

        /**
         * Constructs a new ContactDetails.
         * @memberof signalservice
         * @classdesc Represents a ContactDetails.
         * @implements IContactDetails
         * @constructor
         * @param {signalservice.IContactDetails=} [properties] Properties to set
         */
        function ContactDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactDetails number.
         * @member {string} number
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.number = "";

        /**
         * ContactDetails uuid.
         * @member {string} uuid
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.uuid = "";

        /**
         * ContactDetails name.
         * @member {string} name
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.name = "";

        /**
         * ContactDetails avatar.
         * @member {signalservice.ContactDetails.IAvatar|null|undefined} avatar
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.avatar = null;

        /**
         * ContactDetails color.
         * @member {string} color
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.color = "";

        /**
         * ContactDetails verified.
         * @member {signalservice.IVerified|null|undefined} verified
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.verified = null;

        /**
         * ContactDetails profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.profileKey = $util.newBuffer([]);

        /**
         * ContactDetails blocked.
         * @member {boolean} blocked
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.blocked = false;

        /**
         * ContactDetails expireTimer.
         * @member {number} expireTimer
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.expireTimer = 0;

        /**
         * ContactDetails inboxPosition.
         * @member {number} inboxPosition
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.inboxPosition = 0;

        /**
         * Encodes the specified ContactDetails message. Does not implicitly {@link signalservice.ContactDetails.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.IContactDetails} message ContactDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ContactDetails.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.number);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.signalservice.ContactDetails.Avatar.encode(message.avatar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.color);
            if (message.verified != null && Object.hasOwnProperty.call(message, "verified"))
                $root.signalservice.Verified.encode(message.verified, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.profileKey);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.blocked);
            if (message.expireTimer != null && Object.hasOwnProperty.call(message, "expireTimer"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expireTimer);
            if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.uuid);
            if (message.inboxPosition != null && Object.hasOwnProperty.call(message, "inboxPosition"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.inboxPosition);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ContactDetails message, length delimited. Does not implicitly {@link signalservice.ContactDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.IContactDetails} message ContactDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactDetails message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ContactDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ContactDetails} ContactDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ContactDetails();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.number = reader.string();
                    break;
                case 9:
                    message.uuid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatar = $root.signalservice.ContactDetails.Avatar.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.color = reader.string();
                    break;
                case 5:
                    message.verified = $root.signalservice.Verified.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.profileKey = reader.bytes();
                    break;
                case 7:
                    message.blocked = reader.bool();
                    break;
                case 8:
                    message.expireTimer = reader.uint32();
                    break;
                case 10:
                    message.inboxPosition = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ContactDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ContactDetails} ContactDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ContactDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ContactDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ContactDetails} ContactDetails
         */
        ContactDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ContactDetails)
                return object;
            var message = new $root.signalservice.ContactDetails();
            if (object.number != null)
                message.number = String(object.number);
            if (object.uuid != null)
                message.uuid = String(object.uuid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".signalservice.ContactDetails.avatar: object expected");
                message.avatar = $root.signalservice.ContactDetails.Avatar.fromObject(object.avatar);
            }
            if (object.color != null)
                message.color = String(object.color);
            if (object.verified != null) {
                if (typeof object.verified !== "object")
                    throw TypeError(".signalservice.ContactDetails.verified: object expected");
                message.verified = $root.signalservice.Verified.fromObject(object.verified);
            }
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.expireTimer != null)
                message.expireTimer = object.expireTimer >>> 0;
            if (object.inboxPosition != null)
                message.inboxPosition = object.inboxPosition >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ContactDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.ContactDetails} message ContactDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.number = "";
                object.name = "";
                object.avatar = null;
                object.color = "";
                object.verified = null;
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.blocked = false;
                object.expireTimer = 0;
                object.uuid = "";
                object.inboxPosition = 0;
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = $root.signalservice.ContactDetails.Avatar.toObject(message.avatar, options);
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.verified != null && message.hasOwnProperty("verified"))
                object.verified = $root.signalservice.Verified.toObject(message.verified, options);
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                object.expireTimer = message.expireTimer;
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                object.uuid = message.uuid;
            if (message.inboxPosition != null && message.hasOwnProperty("inboxPosition"))
                object.inboxPosition = message.inboxPosition;
            return object;
        };

        /**
         * Converts this ContactDetails to JSON.
         * @function toJSON
         * @memberof signalservice.ContactDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ContactDetails.Avatar = (function() {

            /**
             * Properties of an Avatar.
             * @memberof signalservice.ContactDetails
             * @interface IAvatar
             * @property {string|null} [contentType] Avatar contentType
             * @property {number|null} [length] Avatar length
             */

            /**
             * Constructs a new Avatar.
             * @memberof signalservice.ContactDetails
             * @classdesc Represents an Avatar.
             * @implements IAvatar
             * @constructor
             * @param {signalservice.ContactDetails.IAvatar=} [properties] Properties to set
             */
            function Avatar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Avatar contentType.
             * @member {string} contentType
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             */
            Avatar.prototype.contentType = "";

            /**
             * Avatar length.
             * @member {number} length
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             */
            Avatar.prototype.length = 0;

            /**
             * Encodes the specified Avatar message. Does not implicitly {@link signalservice.ContactDetails.Avatar.verify|verify} messages.
             * @function encode
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.ContactDetails.Avatar.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Avatar message, length delimited. Does not implicitly {@link signalservice.ContactDetails.Avatar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ContactDetails.Avatar();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contentType = reader.string();
                        break;
                    case 2:
                        message.length = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             */
            Avatar.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.ContactDetails.Avatar)
                    return object;
                var message = new $root.signalservice.ContactDetails.Avatar();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.length != null)
                    message.length = object.length >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an Avatar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.Avatar} message Avatar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Avatar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.length = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                return object;
            };

            /**
             * Converts this Avatar to JSON.
             * @function toJSON
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Avatar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Avatar;
        })();

        return ContactDetails;
    })();

    signalservice.GroupDetails = (function() {

        /**
         * Properties of a GroupDetails.
         * @memberof signalservice
         * @interface IGroupDetails
         * @property {Uint8Array|null} [id] GroupDetails id
         * @property {string|null} [name] GroupDetails name
         * @property {Array.<string>|null} [membersE164] GroupDetails membersE164
         * @property {Array.<signalservice.GroupDetails.IMember>|null} [members] GroupDetails members
         * @property {signalservice.GroupDetails.IAvatar|null} [avatar] GroupDetails avatar
         * @property {boolean|null} [active] GroupDetails active
         * @property {number|null} [expireTimer] GroupDetails expireTimer
         * @property {string|null} [color] GroupDetails color
         * @property {boolean|null} [blocked] GroupDetails blocked
         * @property {number|null} [inboxPosition] GroupDetails inboxPosition
         */

        /**
         * Constructs a new GroupDetails.
         * @memberof signalservice
         * @classdesc Represents a GroupDetails.
         * @implements IGroupDetails
         * @constructor
         * @param {signalservice.IGroupDetails=} [properties] Properties to set
         */
        function GroupDetails(properties) {
            this.membersE164 = [];
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupDetails id.
         * @member {Uint8Array} id
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.id = $util.newBuffer([]);

        /**
         * GroupDetails name.
         * @member {string} name
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.name = "";

        /**
         * GroupDetails membersE164.
         * @member {Array.<string>} membersE164
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.membersE164 = $util.emptyArray;

        /**
         * GroupDetails members.
         * @member {Array.<signalservice.GroupDetails.IMember>} members
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.members = $util.emptyArray;

        /**
         * GroupDetails avatar.
         * @member {signalservice.GroupDetails.IAvatar|null|undefined} avatar
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.avatar = null;

        /**
         * GroupDetails active.
         * @member {boolean} active
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.active = true;

        /**
         * GroupDetails expireTimer.
         * @member {number} expireTimer
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.expireTimer = 0;

        /**
         * GroupDetails color.
         * @member {string} color
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.color = "";

        /**
         * GroupDetails blocked.
         * @member {boolean} blocked
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.blocked = false;

        /**
         * GroupDetails inboxPosition.
         * @member {number} inboxPosition
         * @memberof signalservice.GroupDetails
         * @instance
         */
        GroupDetails.prototype.inboxPosition = 0;

        /**
         * Encodes the specified GroupDetails message. Does not implicitly {@link signalservice.GroupDetails.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupDetails
         * @static
         * @param {signalservice.IGroupDetails} message GroupDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupDetails.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.membersE164 != null && message.membersE164.length)
                for (var i = 0; i < message.membersE164.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.membersE164[i]);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.signalservice.GroupDetails.Avatar.encode(message.avatar, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.active);
            if (message.expireTimer != null && Object.hasOwnProperty.call(message, "expireTimer"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.expireTimer);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.color);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.blocked);
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.signalservice.GroupDetails.Member.encode(message.members[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.inboxPosition != null && Object.hasOwnProperty.call(message, "inboxPosition"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.inboxPosition);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupDetails message, length delimited. Does not implicitly {@link signalservice.GroupDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupDetails
         * @static
         * @param {signalservice.IGroupDetails} message GroupDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupDetails message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupDetails} GroupDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupDetails();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.membersE164 && message.membersE164.length))
                        message.membersE164 = [];
                    message.membersE164.push(reader.string());
                    break;
                case 9:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.signalservice.GroupDetails.Member.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.avatar = $root.signalservice.GroupDetails.Avatar.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.active = reader.bool();
                    break;
                case 6:
                    message.expireTimer = reader.uint32();
                    break;
                case 7:
                    message.color = reader.string();
                    break;
                case 8:
                    message.blocked = reader.bool();
                    break;
                case 10:
                    message.inboxPosition = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupDetails} GroupDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupDetails} GroupDetails
         */
        GroupDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupDetails)
                return object;
            var message = new $root.signalservice.GroupDetails();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.name != null)
                message.name = String(object.name);
            if (object.membersE164) {
                if (!Array.isArray(object.membersE164))
                    throw TypeError(".signalservice.GroupDetails.membersE164: array expected");
                message.membersE164 = [];
                for (var i = 0; i < object.membersE164.length; ++i)
                    message.membersE164[i] = String(object.membersE164[i]);
            }
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".signalservice.GroupDetails.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".signalservice.GroupDetails.members: object expected");
                    message.members[i] = $root.signalservice.GroupDetails.Member.fromObject(object.members[i]);
                }
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".signalservice.GroupDetails.avatar: object expected");
                message.avatar = $root.signalservice.GroupDetails.Avatar.fromObject(object.avatar);
            }
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.expireTimer != null)
                message.expireTimer = object.expireTimer >>> 0;
            if (object.color != null)
                message.color = String(object.color);
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.inboxPosition != null)
                message.inboxPosition = object.inboxPosition >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupDetails
         * @static
         * @param {signalservice.GroupDetails} message GroupDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.membersE164 = [];
                object.members = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.name = "";
                object.avatar = null;
                object.active = true;
                object.expireTimer = 0;
                object.color = "";
                object.blocked = false;
                object.inboxPosition = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.membersE164 && message.membersE164.length) {
                object.membersE164 = [];
                for (var j = 0; j < message.membersE164.length; ++j)
                    object.membersE164[j] = message.membersE164[j];
            }
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = $root.signalservice.GroupDetails.Avatar.toObject(message.avatar, options);
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                object.expireTimer = message.expireTimer;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.signalservice.GroupDetails.Member.toObject(message.members[j], options);
            }
            if (message.inboxPosition != null && message.hasOwnProperty("inboxPosition"))
                object.inboxPosition = message.inboxPosition;
            return object;
        };

        /**
         * Converts this GroupDetails to JSON.
         * @function toJSON
         * @memberof signalservice.GroupDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GroupDetails.Avatar = (function() {

            /**
             * Properties of an Avatar.
             * @memberof signalservice.GroupDetails
             * @interface IAvatar
             * @property {string|null} [contentType] Avatar contentType
             * @property {number|null} [length] Avatar length
             */

            /**
             * Constructs a new Avatar.
             * @memberof signalservice.GroupDetails
             * @classdesc Represents an Avatar.
             * @implements IAvatar
             * @constructor
             * @param {signalservice.GroupDetails.IAvatar=} [properties] Properties to set
             */
            function Avatar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Avatar contentType.
             * @member {string} contentType
             * @memberof signalservice.GroupDetails.Avatar
             * @instance
             */
            Avatar.prototype.contentType = "";

            /**
             * Avatar length.
             * @member {number} length
             * @memberof signalservice.GroupDetails.Avatar
             * @instance
             */
            Avatar.prototype.length = 0;

            /**
             * Encodes the specified Avatar message. Does not implicitly {@link signalservice.GroupDetails.Avatar.verify|verify} messages.
             * @function encode
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {signalservice.GroupDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.GroupDetails.Avatar.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Avatar message, length delimited. Does not implicitly {@link signalservice.GroupDetails.Avatar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {signalservice.GroupDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.GroupDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupDetails.Avatar();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contentType = reader.string();
                        break;
                    case 2:
                        message.length = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.GroupDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.GroupDetails.Avatar} Avatar
             */
            Avatar.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.GroupDetails.Avatar)
                    return object;
                var message = new $root.signalservice.GroupDetails.Avatar();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.length != null)
                    message.length = object.length >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an Avatar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.GroupDetails.Avatar
             * @static
             * @param {signalservice.GroupDetails.Avatar} message Avatar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Avatar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.length = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                return object;
            };

            /**
             * Converts this Avatar to JSON.
             * @function toJSON
             * @memberof signalservice.GroupDetails.Avatar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Avatar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Avatar;
        })();

        GroupDetails.Member = (function() {

            /**
             * Properties of a Member.
             * @memberof signalservice.GroupDetails
             * @interface IMember
             * @property {string|null} [uuid] Member uuid
             * @property {string|null} [e164] Member e164
             */

            /**
             * Constructs a new Member.
             * @memberof signalservice.GroupDetails
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {signalservice.GroupDetails.IMember=} [properties] Properties to set
             */
            function Member(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Member uuid.
             * @member {string} uuid
             * @memberof signalservice.GroupDetails.Member
             * @instance
             */
            Member.prototype.uuid = "";

            /**
             * Member e164.
             * @member {string} e164
             * @memberof signalservice.GroupDetails.Member
             * @instance
             */
            Member.prototype.e164 = "";

            /**
             * Encodes the specified Member message. Does not implicitly {@link signalservice.GroupDetails.Member.verify|verify} messages.
             * @function encode
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {signalservice.GroupDetails.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.GroupDetails.Member.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);
                if (message.e164 != null && Object.hasOwnProperty.call(message, "e164"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.e164);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Member message, length delimited. Does not implicitly {@link signalservice.GroupDetails.Member.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {signalservice.GroupDetails.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.GroupDetails.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupDetails.Member();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uuid = reader.string();
                        break;
                    case 2:
                        message.e164 = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Member message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.GroupDetails.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Member message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.GroupDetails.Member} Member
             */
            Member.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.GroupDetails.Member)
                    return object;
                var message = new $root.signalservice.GroupDetails.Member();
                if (object.uuid != null)
                    message.uuid = String(object.uuid);
                if (object.e164 != null)
                    message.e164 = String(object.e164);
                return message;
            };

            /**
             * Creates a plain object from a Member message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.GroupDetails.Member
             * @static
             * @param {signalservice.GroupDetails.Member} message Member
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Member.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.uuid = "";
                    object.e164 = "";
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = message.uuid;
                if (message.e164 != null && message.hasOwnProperty("e164"))
                    object.e164 = message.e164;
                return object;
            };

            /**
             * Converts this Member to JSON.
             * @function toJSON
             * @memberof signalservice.GroupDetails.Member
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Member.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Member;
        })();

        return GroupDetails;
    })();

    signalservice.PniSignatureMessage = (function() {

        /**
         * Properties of a PniSignatureMessage.
         * @memberof signalservice
         * @interface IPniSignatureMessage
         * @property {Uint8Array|null} [pni] PniSignatureMessage pni
         * @property {Uint8Array|null} [signature] PniSignatureMessage signature
         */

        /**
         * Constructs a new PniSignatureMessage.
         * @memberof signalservice
         * @classdesc Represents a PniSignatureMessage.
         * @implements IPniSignatureMessage
         * @constructor
         * @param {signalservice.IPniSignatureMessage=} [properties] Properties to set
         */
        function PniSignatureMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PniSignatureMessage pni.
         * @member {Uint8Array} pni
         * @memberof signalservice.PniSignatureMessage
         * @instance
         */
        PniSignatureMessage.prototype.pni = $util.newBuffer([]);

        /**
         * PniSignatureMessage signature.
         * @member {Uint8Array} signature
         * @memberof signalservice.PniSignatureMessage
         * @instance
         */
        PniSignatureMessage.prototype.signature = $util.newBuffer([]);

        /**
         * Encodes the specified PniSignatureMessage message. Does not implicitly {@link signalservice.PniSignatureMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.IPniSignatureMessage} message PniSignatureMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PniSignatureMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.PniSignatureMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pni);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified PniSignatureMessage message, length delimited. Does not implicitly {@link signalservice.PniSignatureMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.IPniSignatureMessage} message PniSignatureMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PniSignatureMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PniSignatureMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PniSignatureMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.PniSignatureMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pni = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PniSignatureMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PniSignatureMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a PniSignatureMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         */
        PniSignatureMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.PniSignatureMessage)
                return object;
            var message = new $root.signalservice.PniSignatureMessage();
            if (object.pni != null)
                if (typeof object.pni === "string")
                    $util.base64.decode(object.pni, message.pni = $util.newBuffer($util.base64.length(object.pni)), 0);
                else if (object.pni.length)
                    message.pni = object.pni;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a PniSignatureMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.PniSignatureMessage} message PniSignatureMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PniSignatureMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.pni = "";
                else {
                    object.pni = [];
                    if (options.bytes !== Array)
                        object.pni = $util.newBuffer(object.pni);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.pni != null && message.hasOwnProperty("pni"))
                object.pni = options.bytes === String ? $util.base64.encode(message.pni, 0, message.pni.length) : options.bytes === Array ? Array.prototype.slice.call(message.pni) : message.pni;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this PniSignatureMessage to JSON.
         * @function toJSON
         * @memberof signalservice.PniSignatureMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PniSignatureMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PniSignatureMessage;
    })();

    signalservice.StorageManifest = (function() {

        /**
         * Properties of a StorageManifest.
         * @memberof signalservice
         * @interface IStorageManifest
         * @property {Long|null} [version] StorageManifest version
         * @property {Uint8Array|null} [value] StorageManifest value
         */

        /**
         * Constructs a new StorageManifest.
         * @memberof signalservice
         * @classdesc Represents a StorageManifest.
         * @implements IStorageManifest
         * @constructor
         * @param {signalservice.IStorageManifest=} [properties] Properties to set
         */
        function StorageManifest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StorageManifest version.
         * @member {Long} version
         * @memberof signalservice.StorageManifest
         * @instance
         */
        StorageManifest.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StorageManifest value.
         * @member {Uint8Array} value
         * @memberof signalservice.StorageManifest
         * @instance
         */
        StorageManifest.prototype.value = $util.newBuffer([]);

        /**
         * Encodes the specified StorageManifest message. Does not implicitly {@link signalservice.StorageManifest.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StorageManifest
         * @static
         * @param {signalservice.IStorageManifest} message StorageManifest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageManifest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StorageManifest.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StorageManifest message, length delimited. Does not implicitly {@link signalservice.StorageManifest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StorageManifest
         * @static
         * @param {signalservice.IStorageManifest} message StorageManifest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageManifest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StorageManifest message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StorageManifest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StorageManifest} StorageManifest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageManifest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StorageManifest();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint64();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StorageManifest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StorageManifest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StorageManifest} StorageManifest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageManifest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StorageManifest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StorageManifest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StorageManifest} StorageManifest
         */
        StorageManifest.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StorageManifest)
                return object;
            var message = new $root.signalservice.StorageManifest();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            return message;
        };

        /**
         * Creates a plain object from a StorageManifest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StorageManifest
         * @static
         * @param {signalservice.StorageManifest} message StorageManifest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StorageManifest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            return object;
        };

        /**
         * Converts this StorageManifest to JSON.
         * @function toJSON
         * @memberof signalservice.StorageManifest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StorageManifest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StorageManifest;
    })();

    signalservice.StorageItem = (function() {

        /**
         * Properties of a StorageItem.
         * @memberof signalservice
         * @interface IStorageItem
         * @property {Uint8Array|null} [key] StorageItem key
         * @property {Uint8Array|null} [value] StorageItem value
         */

        /**
         * Constructs a new StorageItem.
         * @memberof signalservice
         * @classdesc Represents a StorageItem.
         * @implements IStorageItem
         * @constructor
         * @param {signalservice.IStorageItem=} [properties] Properties to set
         */
        function StorageItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StorageItem key.
         * @member {Uint8Array} key
         * @memberof signalservice.StorageItem
         * @instance
         */
        StorageItem.prototype.key = $util.newBuffer([]);

        /**
         * StorageItem value.
         * @member {Uint8Array} value
         * @memberof signalservice.StorageItem
         * @instance
         */
        StorageItem.prototype.value = $util.newBuffer([]);

        /**
         * Encodes the specified StorageItem message. Does not implicitly {@link signalservice.StorageItem.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StorageItem
         * @static
         * @param {signalservice.IStorageItem} message StorageItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StorageItem.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StorageItem message, length delimited. Does not implicitly {@link signalservice.StorageItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StorageItem
         * @static
         * @param {signalservice.IStorageItem} message StorageItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StorageItem message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StorageItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StorageItem} StorageItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StorageItem();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StorageItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StorageItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StorageItem} StorageItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StorageItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StorageItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StorageItem} StorageItem
         */
        StorageItem.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StorageItem)
                return object;
            var message = new $root.signalservice.StorageItem();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            return message;
        };

        /**
         * Creates a plain object from a StorageItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StorageItem
         * @static
         * @param {signalservice.StorageItem} message StorageItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StorageItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            return object;
        };

        /**
         * Converts this StorageItem to JSON.
         * @function toJSON
         * @memberof signalservice.StorageItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StorageItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StorageItem;
    })();

    signalservice.StorageItems = (function() {

        /**
         * Properties of a StorageItems.
         * @memberof signalservice
         * @interface IStorageItems
         * @property {Array.<signalservice.IStorageItem>|null} [items] StorageItems items
         */

        /**
         * Constructs a new StorageItems.
         * @memberof signalservice
         * @classdesc Represents a StorageItems.
         * @implements IStorageItems
         * @constructor
         * @param {signalservice.IStorageItems=} [properties] Properties to set
         */
        function StorageItems(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StorageItems items.
         * @member {Array.<signalservice.IStorageItem>} items
         * @memberof signalservice.StorageItems
         * @instance
         */
        StorageItems.prototype.items = $util.emptyArray;

        /**
         * Encodes the specified StorageItems message. Does not implicitly {@link signalservice.StorageItems.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StorageItems
         * @static
         * @param {signalservice.IStorageItems} message StorageItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StorageItems.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.signalservice.StorageItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StorageItems message, length delimited. Does not implicitly {@link signalservice.StorageItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StorageItems
         * @static
         * @param {signalservice.IStorageItems} message StorageItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StorageItems message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StorageItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StorageItems} StorageItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StorageItems();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.signalservice.StorageItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StorageItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StorageItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StorageItems} StorageItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StorageItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StorageItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StorageItems} StorageItems
         */
        StorageItems.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StorageItems)
                return object;
            var message = new $root.signalservice.StorageItems();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".signalservice.StorageItems.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".signalservice.StorageItems.items: object expected");
                    message.items[i] = $root.signalservice.StorageItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StorageItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StorageItems
         * @static
         * @param {signalservice.StorageItems} message StorageItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StorageItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.signalservice.StorageItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this StorageItems to JSON.
         * @function toJSON
         * @memberof signalservice.StorageItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StorageItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StorageItems;
    })();

    signalservice.ReadOperation = (function() {

        /**
         * Properties of a ReadOperation.
         * @memberof signalservice
         * @interface IReadOperation
         * @property {Array.<Uint8Array>|null} [readKey] ReadOperation readKey
         */

        /**
         * Constructs a new ReadOperation.
         * @memberof signalservice
         * @classdesc Represents a ReadOperation.
         * @implements IReadOperation
         * @constructor
         * @param {signalservice.IReadOperation=} [properties] Properties to set
         */
        function ReadOperation(properties) {
            this.readKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadOperation readKey.
         * @member {Array.<Uint8Array>} readKey
         * @memberof signalservice.ReadOperation
         * @instance
         */
        ReadOperation.prototype.readKey = $util.emptyArray;

        /**
         * Encodes the specified ReadOperation message. Does not implicitly {@link signalservice.ReadOperation.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ReadOperation
         * @static
         * @param {signalservice.IReadOperation} message ReadOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadOperation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ReadOperation.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.readKey != null && message.readKey.length)
                for (var i = 0; i < message.readKey.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.readKey[i]);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ReadOperation message, length delimited. Does not implicitly {@link signalservice.ReadOperation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ReadOperation
         * @static
         * @param {signalservice.IReadOperation} message ReadOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadOperation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadOperation message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ReadOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ReadOperation} ReadOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadOperation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ReadOperation();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.readKey && message.readKey.length))
                        message.readKey = [];
                    message.readKey.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadOperation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ReadOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ReadOperation} ReadOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadOperation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ReadOperation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ReadOperation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ReadOperation} ReadOperation
         */
        ReadOperation.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ReadOperation)
                return object;
            var message = new $root.signalservice.ReadOperation();
            if (object.readKey) {
                if (!Array.isArray(object.readKey))
                    throw TypeError(".signalservice.ReadOperation.readKey: array expected");
                message.readKey = [];
                for (var i = 0; i < object.readKey.length; ++i)
                    if (typeof object.readKey[i] === "string")
                        $util.base64.decode(object.readKey[i], message.readKey[i] = $util.newBuffer($util.base64.length(object.readKey[i])), 0);
                    else if (object.readKey[i].length)
                        message.readKey[i] = object.readKey[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ReadOperation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ReadOperation
         * @static
         * @param {signalservice.ReadOperation} message ReadOperation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReadOperation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.readKey = [];
            if (message.readKey && message.readKey.length) {
                object.readKey = [];
                for (var j = 0; j < message.readKey.length; ++j)
                    object.readKey[j] = options.bytes === String ? $util.base64.encode(message.readKey[j], 0, message.readKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.readKey[j]) : message.readKey[j];
            }
            return object;
        };

        /**
         * Converts this ReadOperation to JSON.
         * @function toJSON
         * @memberof signalservice.ReadOperation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReadOperation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReadOperation;
    })();

    signalservice.WriteOperation = (function() {

        /**
         * Properties of a WriteOperation.
         * @memberof signalservice
         * @interface IWriteOperation
         * @property {signalservice.IStorageManifest|null} [manifest] WriteOperation manifest
         * @property {Array.<signalservice.IStorageItem>|null} [insertItem] WriteOperation insertItem
         * @property {Array.<Uint8Array>|null} [deleteKey] WriteOperation deleteKey
         * @property {boolean|null} [clearAll] WriteOperation clearAll
         */

        /**
         * Constructs a new WriteOperation.
         * @memberof signalservice
         * @classdesc Represents a WriteOperation.
         * @implements IWriteOperation
         * @constructor
         * @param {signalservice.IWriteOperation=} [properties] Properties to set
         */
        function WriteOperation(properties) {
            this.insertItem = [];
            this.deleteKey = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WriteOperation manifest.
         * @member {signalservice.IStorageManifest|null|undefined} manifest
         * @memberof signalservice.WriteOperation
         * @instance
         */
        WriteOperation.prototype.manifest = null;

        /**
         * WriteOperation insertItem.
         * @member {Array.<signalservice.IStorageItem>} insertItem
         * @memberof signalservice.WriteOperation
         * @instance
         */
        WriteOperation.prototype.insertItem = $util.emptyArray;

        /**
         * WriteOperation deleteKey.
         * @member {Array.<Uint8Array>} deleteKey
         * @memberof signalservice.WriteOperation
         * @instance
         */
        WriteOperation.prototype.deleteKey = $util.emptyArray;

        /**
         * WriteOperation clearAll.
         * @member {boolean} clearAll
         * @memberof signalservice.WriteOperation
         * @instance
         */
        WriteOperation.prototype.clearAll = false;

        /**
         * Encodes the specified WriteOperation message. Does not implicitly {@link signalservice.WriteOperation.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WriteOperation
         * @static
         * @param {signalservice.IWriteOperation} message WriteOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteOperation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.WriteOperation.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.manifest != null && Object.hasOwnProperty.call(message, "manifest"))
                $root.signalservice.StorageManifest.encode(message.manifest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.insertItem != null && message.insertItem.length)
                for (var i = 0; i < message.insertItem.length; ++i)
                    $root.signalservice.StorageItem.encode(message.insertItem[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.deleteKey != null && message.deleteKey.length)
                for (var i = 0; i < message.deleteKey.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.deleteKey[i]);
            if (message.clearAll != null && Object.hasOwnProperty.call(message, "clearAll"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.clearAll);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified WriteOperation message, length delimited. Does not implicitly {@link signalservice.WriteOperation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WriteOperation
         * @static
         * @param {signalservice.IWriteOperation} message WriteOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteOperation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WriteOperation message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WriteOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WriteOperation} WriteOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteOperation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WriteOperation();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.manifest = $root.signalservice.StorageManifest.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.insertItem && message.insertItem.length))
                        message.insertItem = [];
                    message.insertItem.push($root.signalservice.StorageItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.deleteKey && message.deleteKey.length))
                        message.deleteKey = [];
                    message.deleteKey.push(reader.bytes());
                    break;
                case 4:
                    message.clearAll = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WriteOperation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WriteOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WriteOperation} WriteOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteOperation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a WriteOperation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WriteOperation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WriteOperation} WriteOperation
         */
        WriteOperation.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WriteOperation)
                return object;
            var message = new $root.signalservice.WriteOperation();
            if (object.manifest != null) {
                if (typeof object.manifest !== "object")
                    throw TypeError(".signalservice.WriteOperation.manifest: object expected");
                message.manifest = $root.signalservice.StorageManifest.fromObject(object.manifest);
            }
            if (object.insertItem) {
                if (!Array.isArray(object.insertItem))
                    throw TypeError(".signalservice.WriteOperation.insertItem: array expected");
                message.insertItem = [];
                for (var i = 0; i < object.insertItem.length; ++i) {
                    if (typeof object.insertItem[i] !== "object")
                        throw TypeError(".signalservice.WriteOperation.insertItem: object expected");
                    message.insertItem[i] = $root.signalservice.StorageItem.fromObject(object.insertItem[i]);
                }
            }
            if (object.deleteKey) {
                if (!Array.isArray(object.deleteKey))
                    throw TypeError(".signalservice.WriteOperation.deleteKey: array expected");
                message.deleteKey = [];
                for (var i = 0; i < object.deleteKey.length; ++i)
                    if (typeof object.deleteKey[i] === "string")
                        $util.base64.decode(object.deleteKey[i], message.deleteKey[i] = $util.newBuffer($util.base64.length(object.deleteKey[i])), 0);
                    else if (object.deleteKey[i].length)
                        message.deleteKey[i] = object.deleteKey[i];
            }
            if (object.clearAll != null)
                message.clearAll = Boolean(object.clearAll);
            return message;
        };

        /**
         * Creates a plain object from a WriteOperation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WriteOperation
         * @static
         * @param {signalservice.WriteOperation} message WriteOperation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WriteOperation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.insertItem = [];
                object.deleteKey = [];
            }
            if (options.defaults) {
                object.manifest = null;
                object.clearAll = false;
            }
            if (message.manifest != null && message.hasOwnProperty("manifest"))
                object.manifest = $root.signalservice.StorageManifest.toObject(message.manifest, options);
            if (message.insertItem && message.insertItem.length) {
                object.insertItem = [];
                for (var j = 0; j < message.insertItem.length; ++j)
                    object.insertItem[j] = $root.signalservice.StorageItem.toObject(message.insertItem[j], options);
            }
            if (message.deleteKey && message.deleteKey.length) {
                object.deleteKey = [];
                for (var j = 0; j < message.deleteKey.length; ++j)
                    object.deleteKey[j] = options.bytes === String ? $util.base64.encode(message.deleteKey[j], 0, message.deleteKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.deleteKey[j]) : message.deleteKey[j];
            }
            if (message.clearAll != null && message.hasOwnProperty("clearAll"))
                object.clearAll = message.clearAll;
            return object;
        };

        /**
         * Converts this WriteOperation to JSON.
         * @function toJSON
         * @memberof signalservice.WriteOperation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WriteOperation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WriteOperation;
    })();

    signalservice.ManifestRecord = (function() {

        /**
         * Properties of a ManifestRecord.
         * @memberof signalservice
         * @interface IManifestRecord
         * @property {Long|null} [version] ManifestRecord version
         * @property {number|null} [sourceDevice] ManifestRecord sourceDevice
         * @property {Array.<signalservice.ManifestRecord.IIdentifier>|null} [keys] ManifestRecord keys
         */

        /**
         * Constructs a new ManifestRecord.
         * @memberof signalservice
         * @classdesc Represents a ManifestRecord.
         * @implements IManifestRecord
         * @constructor
         * @param {signalservice.IManifestRecord=} [properties] Properties to set
         */
        function ManifestRecord(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ManifestRecord version.
         * @member {Long} version
         * @memberof signalservice.ManifestRecord
         * @instance
         */
        ManifestRecord.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ManifestRecord sourceDevice.
         * @member {number} sourceDevice
         * @memberof signalservice.ManifestRecord
         * @instance
         */
        ManifestRecord.prototype.sourceDevice = 0;

        /**
         * ManifestRecord keys.
         * @member {Array.<signalservice.ManifestRecord.IIdentifier>} keys
         * @memberof signalservice.ManifestRecord
         * @instance
         */
        ManifestRecord.prototype.keys = $util.emptyArray;

        /**
         * Encodes the specified ManifestRecord message. Does not implicitly {@link signalservice.ManifestRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {signalservice.IManifestRecord} message ManifestRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ManifestRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ManifestRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.signalservice.ManifestRecord.Identifier.encode(message.keys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sourceDevice != null && Object.hasOwnProperty.call(message, "sourceDevice"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sourceDevice);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ManifestRecord message, length delimited. Does not implicitly {@link signalservice.ManifestRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {signalservice.IManifestRecord} message ManifestRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ManifestRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ManifestRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ManifestRecord} ManifestRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManifestRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ManifestRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint64();
                    break;
                case 3:
                    message.sourceDevice = reader.uint32();
                    break;
                case 2:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.signalservice.ManifestRecord.Identifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ManifestRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ManifestRecord} ManifestRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManifestRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ManifestRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ManifestRecord} ManifestRecord
         */
        ManifestRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ManifestRecord)
                return object;
            var message = new $root.signalservice.ManifestRecord();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
            if (object.sourceDevice != null)
                message.sourceDevice = object.sourceDevice >>> 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".signalservice.ManifestRecord.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".signalservice.ManifestRecord.keys: object expected");
                    message.keys[i] = $root.signalservice.ManifestRecord.Identifier.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ManifestRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ManifestRecord
         * @static
         * @param {signalservice.ManifestRecord} message ManifestRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ManifestRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
                object.sourceDevice = 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.signalservice.ManifestRecord.Identifier.toObject(message.keys[j], options);
            }
            if (message.sourceDevice != null && message.hasOwnProperty("sourceDevice"))
                object.sourceDevice = message.sourceDevice;
            return object;
        };

        /**
         * Converts this ManifestRecord to JSON.
         * @function toJSON
         * @memberof signalservice.ManifestRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ManifestRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ManifestRecord.Identifier = (function() {

            /**
             * Properties of an Identifier.
             * @memberof signalservice.ManifestRecord
             * @interface IIdentifier
             * @property {Uint8Array|null} [raw] Identifier raw
             * @property {signalservice.ManifestRecord.Identifier.Type|null} [type] Identifier type
             */

            /**
             * Constructs a new Identifier.
             * @memberof signalservice.ManifestRecord
             * @classdesc Represents an Identifier.
             * @implements IIdentifier
             * @constructor
             * @param {signalservice.ManifestRecord.IIdentifier=} [properties] Properties to set
             */
            function Identifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Identifier raw.
             * @member {Uint8Array} raw
             * @memberof signalservice.ManifestRecord.Identifier
             * @instance
             */
            Identifier.prototype.raw = $util.newBuffer([]);

            /**
             * Identifier type.
             * @member {signalservice.ManifestRecord.Identifier.Type} type
             * @memberof signalservice.ManifestRecord.Identifier
             * @instance
             */
            Identifier.prototype.type = 0;

            /**
             * Encodes the specified Identifier message. Does not implicitly {@link signalservice.ManifestRecord.Identifier.verify|verify} messages.
             * @function encode
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {signalservice.ManifestRecord.IIdentifier} message Identifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Identifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.ManifestRecord.Identifier.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.raw != null && Object.hasOwnProperty.call(message, "raw"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.raw);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Identifier message, length delimited. Does not implicitly {@link signalservice.ManifestRecord.Identifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {signalservice.ManifestRecord.IIdentifier} message Identifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Identifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Identifier message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.ManifestRecord.Identifier} Identifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Identifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ManifestRecord.Identifier();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.raw = reader.bytes();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Identifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.ManifestRecord.Identifier} Identifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Identifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates an Identifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.ManifestRecord.Identifier} Identifier
             */
            Identifier.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.ManifestRecord.Identifier)
                    return object;
                var message = new $root.signalservice.ManifestRecord.Identifier();
                if (object.raw != null)
                    if (typeof object.raw === "string")
                        $util.base64.decode(object.raw, message.raw = $util.newBuffer($util.base64.length(object.raw)), 0);
                    else if (object.raw.length)
                        message.raw = object.raw;
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "CONTACT":
                case 1:
                    message.type = 1;
                    break;
                case "GROUPV1":
                case 2:
                    message.type = 2;
                    break;
                case "GROUPV2":
                case 3:
                    message.type = 3;
                    break;
                case "ACCOUNT":
                case 4:
                    message.type = 4;
                    break;
                case "STORY_DISTRIBUTION_LIST":
                case 5:
                    message.type = 5;
                    break;
                case "STICKER_PACK":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an Identifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.ManifestRecord.Identifier
             * @static
             * @param {signalservice.ManifestRecord.Identifier} message Identifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Identifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.raw = "";
                    else {
                        object.raw = [];
                        if (options.bytes !== Array)
                            object.raw = $util.newBuffer(object.raw);
                    }
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.raw != null && message.hasOwnProperty("raw"))
                    object.raw = options.bytes === String ? $util.base64.encode(message.raw, 0, message.raw.length) : options.bytes === Array ? Array.prototype.slice.call(message.raw) : message.raw;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.ManifestRecord.Identifier.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Identifier to JSON.
             * @function toJSON
             * @memberof signalservice.ManifestRecord.Identifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Identifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.ManifestRecord.Identifier.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CONTACT=1 CONTACT value
             * @property {number} GROUPV1=2 GROUPV1 value
             * @property {number} GROUPV2=3 GROUPV2 value
             * @property {number} ACCOUNT=4 ACCOUNT value
             * @property {number} STORY_DISTRIBUTION_LIST=5 STORY_DISTRIBUTION_LIST value
             * @property {number} STICKER_PACK=6 STICKER_PACK value
             */
            Identifier.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CONTACT"] = 1;
                values[valuesById[2] = "GROUPV1"] = 2;
                values[valuesById[3] = "GROUPV2"] = 3;
                values[valuesById[4] = "ACCOUNT"] = 4;
                values[valuesById[5] = "STORY_DISTRIBUTION_LIST"] = 5;
                values[valuesById[6] = "STICKER_PACK"] = 6;
                return values;
            })();

            return Identifier;
        })();

        return ManifestRecord;
    })();

    signalservice.StorageRecord = (function() {

        /**
         * Properties of a StorageRecord.
         * @memberof signalservice
         * @interface IStorageRecord
         * @property {signalservice.IContactRecord|null} [contact] StorageRecord contact
         * @property {signalservice.IGroupV1Record|null} [groupV1] StorageRecord groupV1
         * @property {signalservice.IGroupV2Record|null} [groupV2] StorageRecord groupV2
         * @property {signalservice.IAccountRecord|null} [account] StorageRecord account
         * @property {signalservice.IStoryDistributionListRecord|null} [storyDistributionList] StorageRecord storyDistributionList
         * @property {signalservice.IStickerPackRecord|null} [stickerPack] StorageRecord stickerPack
         */

        /**
         * Constructs a new StorageRecord.
         * @memberof signalservice
         * @classdesc Represents a StorageRecord.
         * @implements IStorageRecord
         * @constructor
         * @param {signalservice.IStorageRecord=} [properties] Properties to set
         */
        function StorageRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StorageRecord contact.
         * @member {signalservice.IContactRecord|null|undefined} contact
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.contact = null;

        /**
         * StorageRecord groupV1.
         * @member {signalservice.IGroupV1Record|null|undefined} groupV1
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.groupV1 = null;

        /**
         * StorageRecord groupV2.
         * @member {signalservice.IGroupV2Record|null|undefined} groupV2
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.groupV2 = null;

        /**
         * StorageRecord account.
         * @member {signalservice.IAccountRecord|null|undefined} account
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.account = null;

        /**
         * StorageRecord storyDistributionList.
         * @member {signalservice.IStoryDistributionListRecord|null|undefined} storyDistributionList
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.storyDistributionList = null;

        /**
         * StorageRecord stickerPack.
         * @member {signalservice.IStickerPackRecord|null|undefined} stickerPack
         * @memberof signalservice.StorageRecord
         * @instance
         */
        StorageRecord.prototype.stickerPack = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * StorageRecord record.
         * @member {"contact"|"groupV1"|"groupV2"|"account"|"storyDistributionList"|"stickerPack"|undefined} record
         * @memberof signalservice.StorageRecord
         * @instance
         */
        Object.defineProperty(StorageRecord.prototype, "record", {
            get: $util.oneOfGetter($oneOfFields = ["contact", "groupV1", "groupV2", "account", "storyDistributionList", "stickerPack"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified StorageRecord message. Does not implicitly {@link signalservice.StorageRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StorageRecord
         * @static
         * @param {signalservice.IStorageRecord} message StorageRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StorageRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                $root.signalservice.ContactRecord.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.groupV1 != null && Object.hasOwnProperty.call(message, "groupV1"))
                $root.signalservice.GroupV1Record.encode(message.groupV1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.groupV2 != null && Object.hasOwnProperty.call(message, "groupV2"))
                $root.signalservice.GroupV2Record.encode(message.groupV2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                $root.signalservice.AccountRecord.encode(message.account, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.storyDistributionList != null && Object.hasOwnProperty.call(message, "storyDistributionList"))
                $root.signalservice.StoryDistributionListRecord.encode(message.storyDistributionList, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.stickerPack != null && Object.hasOwnProperty.call(message, "stickerPack"))
                $root.signalservice.StickerPackRecord.encode(message.stickerPack, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StorageRecord message, length delimited. Does not implicitly {@link signalservice.StorageRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StorageRecord
         * @static
         * @param {signalservice.IStorageRecord} message StorageRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StorageRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StorageRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StorageRecord} StorageRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StorageRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contact = $root.signalservice.ContactRecord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.groupV1 = $root.signalservice.GroupV1Record.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.groupV2 = $root.signalservice.GroupV2Record.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.account = $root.signalservice.AccountRecord.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.storyDistributionList = $root.signalservice.StoryDistributionListRecord.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.stickerPack = $root.signalservice.StickerPackRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StorageRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StorageRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StorageRecord} StorageRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StorageRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StorageRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StorageRecord} StorageRecord
         */
        StorageRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StorageRecord)
                return object;
            var message = new $root.signalservice.StorageRecord();
            if (object.contact != null) {
                if (typeof object.contact !== "object")
                    throw TypeError(".signalservice.StorageRecord.contact: object expected");
                message.contact = $root.signalservice.ContactRecord.fromObject(object.contact);
            }
            if (object.groupV1 != null) {
                if (typeof object.groupV1 !== "object")
                    throw TypeError(".signalservice.StorageRecord.groupV1: object expected");
                message.groupV1 = $root.signalservice.GroupV1Record.fromObject(object.groupV1);
            }
            if (object.groupV2 != null) {
                if (typeof object.groupV2 !== "object")
                    throw TypeError(".signalservice.StorageRecord.groupV2: object expected");
                message.groupV2 = $root.signalservice.GroupV2Record.fromObject(object.groupV2);
            }
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".signalservice.StorageRecord.account: object expected");
                message.account = $root.signalservice.AccountRecord.fromObject(object.account);
            }
            if (object.storyDistributionList != null) {
                if (typeof object.storyDistributionList !== "object")
                    throw TypeError(".signalservice.StorageRecord.storyDistributionList: object expected");
                message.storyDistributionList = $root.signalservice.StoryDistributionListRecord.fromObject(object.storyDistributionList);
            }
            if (object.stickerPack != null) {
                if (typeof object.stickerPack !== "object")
                    throw TypeError(".signalservice.StorageRecord.stickerPack: object expected");
                message.stickerPack = $root.signalservice.StickerPackRecord.fromObject(object.stickerPack);
            }
            return message;
        };

        /**
         * Creates a plain object from a StorageRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StorageRecord
         * @static
         * @param {signalservice.StorageRecord} message StorageRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StorageRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.contact != null && message.hasOwnProperty("contact")) {
                object.contact = $root.signalservice.ContactRecord.toObject(message.contact, options);
                if (options.oneofs)
                    object.record = "contact";
            }
            if (message.groupV1 != null && message.hasOwnProperty("groupV1")) {
                object.groupV1 = $root.signalservice.GroupV1Record.toObject(message.groupV1, options);
                if (options.oneofs)
                    object.record = "groupV1";
            }
            if (message.groupV2 != null && message.hasOwnProperty("groupV2")) {
                object.groupV2 = $root.signalservice.GroupV2Record.toObject(message.groupV2, options);
                if (options.oneofs)
                    object.record = "groupV2";
            }
            if (message.account != null && message.hasOwnProperty("account")) {
                object.account = $root.signalservice.AccountRecord.toObject(message.account, options);
                if (options.oneofs)
                    object.record = "account";
            }
            if (message.storyDistributionList != null && message.hasOwnProperty("storyDistributionList")) {
                object.storyDistributionList = $root.signalservice.StoryDistributionListRecord.toObject(message.storyDistributionList, options);
                if (options.oneofs)
                    object.record = "storyDistributionList";
            }
            if (message.stickerPack != null && message.hasOwnProperty("stickerPack")) {
                object.stickerPack = $root.signalservice.StickerPackRecord.toObject(message.stickerPack, options);
                if (options.oneofs)
                    object.record = "stickerPack";
            }
            return object;
        };

        /**
         * Converts this StorageRecord to JSON.
         * @function toJSON
         * @memberof signalservice.StorageRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StorageRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StorageRecord;
    })();

    signalservice.ContactRecord = (function() {

        /**
         * Properties of a ContactRecord.
         * @memberof signalservice
         * @interface IContactRecord
         * @property {string|null} [serviceUuid] ContactRecord serviceUuid
         * @property {string|null} [serviceE164] ContactRecord serviceE164
         * @property {string|null} [pni] ContactRecord pni
         * @property {Uint8Array|null} [profileKey] ContactRecord profileKey
         * @property {Uint8Array|null} [identityKey] ContactRecord identityKey
         * @property {signalservice.ContactRecord.IdentityState|null} [identityState] ContactRecord identityState
         * @property {string|null} [givenName] ContactRecord givenName
         * @property {string|null} [familyName] ContactRecord familyName
         * @property {string|null} [username] ContactRecord username
         * @property {boolean|null} [blocked] ContactRecord blocked
         * @property {boolean|null} [whitelisted] ContactRecord whitelisted
         * @property {boolean|null} [archived] ContactRecord archived
         * @property {boolean|null} [markedUnread] ContactRecord markedUnread
         * @property {Long|null} [mutedUntilTimestamp] ContactRecord mutedUntilTimestamp
         * @property {boolean|null} [hideStory] ContactRecord hideStory
         */

        /**
         * Constructs a new ContactRecord.
         * @memberof signalservice
         * @classdesc Represents a ContactRecord.
         * @implements IContactRecord
         * @constructor
         * @param {signalservice.IContactRecord=} [properties] Properties to set
         */
        function ContactRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactRecord serviceUuid.
         * @member {string} serviceUuid
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.serviceUuid = "";

        /**
         * ContactRecord serviceE164.
         * @member {string} serviceE164
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.serviceE164 = "";

        /**
         * ContactRecord pni.
         * @member {string} pni
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.pni = "";

        /**
         * ContactRecord profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.profileKey = $util.newBuffer([]);

        /**
         * ContactRecord identityKey.
         * @member {Uint8Array} identityKey
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.identityKey = $util.newBuffer([]);

        /**
         * ContactRecord identityState.
         * @member {signalservice.ContactRecord.IdentityState} identityState
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.identityState = 0;

        /**
         * ContactRecord givenName.
         * @member {string} givenName
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.givenName = "";

        /**
         * ContactRecord familyName.
         * @member {string} familyName
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.familyName = "";

        /**
         * ContactRecord username.
         * @member {string} username
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.username = "";

        /**
         * ContactRecord blocked.
         * @member {boolean} blocked
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.blocked = false;

        /**
         * ContactRecord whitelisted.
         * @member {boolean} whitelisted
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.whitelisted = false;

        /**
         * ContactRecord archived.
         * @member {boolean} archived
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.archived = false;

        /**
         * ContactRecord markedUnread.
         * @member {boolean} markedUnread
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.markedUnread = false;

        /**
         * ContactRecord mutedUntilTimestamp.
         * @member {Long} mutedUntilTimestamp
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.mutedUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ContactRecord hideStory.
         * @member {boolean} hideStory
         * @memberof signalservice.ContactRecord
         * @instance
         */
        ContactRecord.prototype.hideStory = false;

        /**
         * Encodes the specified ContactRecord message. Does not implicitly {@link signalservice.ContactRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ContactRecord
         * @static
         * @param {signalservice.IContactRecord} message ContactRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ContactRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.serviceUuid != null && Object.hasOwnProperty.call(message, "serviceUuid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceUuid);
            if (message.serviceE164 != null && Object.hasOwnProperty.call(message, "serviceE164"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.serviceE164);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.profileKey);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identityKey);
            if (message.identityState != null && Object.hasOwnProperty.call(message, "identityState"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.identityState);
            if (message.givenName != null && Object.hasOwnProperty.call(message, "givenName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.givenName);
            if (message.familyName != null && Object.hasOwnProperty.call(message, "familyName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.familyName);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.username);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.blocked);
            if (message.whitelisted != null && Object.hasOwnProperty.call(message, "whitelisted"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.whitelisted);
            if (message.archived != null && Object.hasOwnProperty.call(message, "archived"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.archived);
            if (message.markedUnread != null && Object.hasOwnProperty.call(message, "markedUnread"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.markedUnread);
            if (message.mutedUntilTimestamp != null && Object.hasOwnProperty.call(message, "mutedUntilTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.mutedUntilTimestamp);
            if (message.hideStory != null && Object.hasOwnProperty.call(message, "hideStory"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.hideStory);
            if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.pni);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ContactRecord message, length delimited. Does not implicitly {@link signalservice.ContactRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ContactRecord
         * @static
         * @param {signalservice.IContactRecord} message ContactRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ContactRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ContactRecord} ContactRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ContactRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceUuid = reader.string();
                    break;
                case 2:
                    message.serviceE164 = reader.string();
                    break;
                case 15:
                    message.pni = reader.string();
                    break;
                case 3:
                    message.profileKey = reader.bytes();
                    break;
                case 4:
                    message.identityKey = reader.bytes();
                    break;
                case 5:
                    message.identityState = reader.int32();
                    break;
                case 6:
                    message.givenName = reader.string();
                    break;
                case 7:
                    message.familyName = reader.string();
                    break;
                case 8:
                    message.username = reader.string();
                    break;
                case 9:
                    message.blocked = reader.bool();
                    break;
                case 10:
                    message.whitelisted = reader.bool();
                    break;
                case 11:
                    message.archived = reader.bool();
                    break;
                case 12:
                    message.markedUnread = reader.bool();
                    break;
                case 13:
                    message.mutedUntilTimestamp = reader.uint64();
                    break;
                case 14:
                    message.hideStory = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ContactRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ContactRecord} ContactRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ContactRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ContactRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ContactRecord} ContactRecord
         */
        ContactRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ContactRecord)
                return object;
            var message = new $root.signalservice.ContactRecord();
            if (object.serviceUuid != null)
                message.serviceUuid = String(object.serviceUuid);
            if (object.serviceE164 != null)
                message.serviceE164 = String(object.serviceE164);
            if (object.pni != null)
                message.pni = String(object.pni);
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            switch (object.identityState) {
            case "DEFAULT":
            case 0:
                message.identityState = 0;
                break;
            case "VERIFIED":
            case 1:
                message.identityState = 1;
                break;
            case "UNVERIFIED":
            case 2:
                message.identityState = 2;
                break;
            }
            if (object.givenName != null)
                message.givenName = String(object.givenName);
            if (object.familyName != null)
                message.familyName = String(object.familyName);
            if (object.username != null)
                message.username = String(object.username);
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.whitelisted != null)
                message.whitelisted = Boolean(object.whitelisted);
            if (object.archived != null)
                message.archived = Boolean(object.archived);
            if (object.markedUnread != null)
                message.markedUnread = Boolean(object.markedUnread);
            if (object.mutedUntilTimestamp != null)
                if ($util.Long)
                    (message.mutedUntilTimestamp = $util.Long.fromValue(object.mutedUntilTimestamp)).unsigned = true;
                else if (typeof object.mutedUntilTimestamp === "string")
                    message.mutedUntilTimestamp = parseInt(object.mutedUntilTimestamp, 10);
                else if (typeof object.mutedUntilTimestamp === "number")
                    message.mutedUntilTimestamp = object.mutedUntilTimestamp;
                else if (typeof object.mutedUntilTimestamp === "object")
                    message.mutedUntilTimestamp = new $util.LongBits(object.mutedUntilTimestamp.low >>> 0, object.mutedUntilTimestamp.high >>> 0).toNumber(true);
            if (object.hideStory != null)
                message.hideStory = Boolean(object.hideStory);
            return message;
        };

        /**
         * Creates a plain object from a ContactRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ContactRecord
         * @static
         * @param {signalservice.ContactRecord} message ContactRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serviceUuid = "";
                object.serviceE164 = "";
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                object.identityState = options.enums === String ? "DEFAULT" : 0;
                object.givenName = "";
                object.familyName = "";
                object.username = "";
                object.blocked = false;
                object.whitelisted = false;
                object.archived = false;
                object.markedUnread = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.mutedUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mutedUntilTimestamp = options.longs === String ? "0" : 0;
                object.hideStory = false;
                object.pni = "";
            }
            if (message.serviceUuid != null && message.hasOwnProperty("serviceUuid"))
                object.serviceUuid = message.serviceUuid;
            if (message.serviceE164 != null && message.hasOwnProperty("serviceE164"))
                object.serviceE164 = message.serviceE164;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.identityState != null && message.hasOwnProperty("identityState"))
                object.identityState = options.enums === String ? $root.signalservice.ContactRecord.IdentityState[message.identityState] : message.identityState;
            if (message.givenName != null && message.hasOwnProperty("givenName"))
                object.givenName = message.givenName;
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                object.familyName = message.familyName;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.whitelisted != null && message.hasOwnProperty("whitelisted"))
                object.whitelisted = message.whitelisted;
            if (message.archived != null && message.hasOwnProperty("archived"))
                object.archived = message.archived;
            if (message.markedUnread != null && message.hasOwnProperty("markedUnread"))
                object.markedUnread = message.markedUnread;
            if (message.mutedUntilTimestamp != null && message.hasOwnProperty("mutedUntilTimestamp"))
                if (typeof message.mutedUntilTimestamp === "number")
                    object.mutedUntilTimestamp = options.longs === String ? String(message.mutedUntilTimestamp) : message.mutedUntilTimestamp;
                else
                    object.mutedUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mutedUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.mutedUntilTimestamp.low >>> 0, message.mutedUntilTimestamp.high >>> 0).toNumber(true) : message.mutedUntilTimestamp;
            if (message.hideStory != null && message.hasOwnProperty("hideStory"))
                object.hideStory = message.hideStory;
            if (message.pni != null && message.hasOwnProperty("pni"))
                object.pni = message.pni;
            return object;
        };

        /**
         * Converts this ContactRecord to JSON.
         * @function toJSON
         * @memberof signalservice.ContactRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * IdentityState enum.
         * @name signalservice.ContactRecord.IdentityState
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} VERIFIED=1 VERIFIED value
         * @property {number} UNVERIFIED=2 UNVERIFIED value
         */
        ContactRecord.IdentityState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "VERIFIED"] = 1;
            values[valuesById[2] = "UNVERIFIED"] = 2;
            return values;
        })();

        return ContactRecord;
    })();

    signalservice.GroupV1Record = (function() {

        /**
         * Properties of a GroupV1Record.
         * @memberof signalservice
         * @interface IGroupV1Record
         * @property {Uint8Array|null} [id] GroupV1Record id
         * @property {boolean|null} [blocked] GroupV1Record blocked
         * @property {boolean|null} [whitelisted] GroupV1Record whitelisted
         * @property {boolean|null} [archived] GroupV1Record archived
         * @property {boolean|null} [markedUnread] GroupV1Record markedUnread
         * @property {Long|null} [mutedUntilTimestamp] GroupV1Record mutedUntilTimestamp
         */

        /**
         * Constructs a new GroupV1Record.
         * @memberof signalservice
         * @classdesc Represents a GroupV1Record.
         * @implements IGroupV1Record
         * @constructor
         * @param {signalservice.IGroupV1Record=} [properties] Properties to set
         */
        function GroupV1Record(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupV1Record id.
         * @member {Uint8Array} id
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.id = $util.newBuffer([]);

        /**
         * GroupV1Record blocked.
         * @member {boolean} blocked
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.blocked = false;

        /**
         * GroupV1Record whitelisted.
         * @member {boolean} whitelisted
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.whitelisted = false;

        /**
         * GroupV1Record archived.
         * @member {boolean} archived
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.archived = false;

        /**
         * GroupV1Record markedUnread.
         * @member {boolean} markedUnread
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.markedUnread = false;

        /**
         * GroupV1Record mutedUntilTimestamp.
         * @member {Long} mutedUntilTimestamp
         * @memberof signalservice.GroupV1Record
         * @instance
         */
        GroupV1Record.prototype.mutedUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified GroupV1Record message. Does not implicitly {@link signalservice.GroupV1Record.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {signalservice.IGroupV1Record} message GroupV1Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupV1Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupV1Record.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.blocked);
            if (message.whitelisted != null && Object.hasOwnProperty.call(message, "whitelisted"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.whitelisted);
            if (message.archived != null && Object.hasOwnProperty.call(message, "archived"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.archived);
            if (message.markedUnread != null && Object.hasOwnProperty.call(message, "markedUnread"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.markedUnread);
            if (message.mutedUntilTimestamp != null && Object.hasOwnProperty.call(message, "mutedUntilTimestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.mutedUntilTimestamp);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupV1Record message, length delimited. Does not implicitly {@link signalservice.GroupV1Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {signalservice.IGroupV1Record} message GroupV1Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupV1Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupV1Record message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupV1Record} GroupV1Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupV1Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupV1Record();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                case 3:
                    message.whitelisted = reader.bool();
                    break;
                case 4:
                    message.archived = reader.bool();
                    break;
                case 5:
                    message.markedUnread = reader.bool();
                    break;
                case 6:
                    message.mutedUntilTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupV1Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupV1Record} GroupV1Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupV1Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupV1Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupV1Record} GroupV1Record
         */
        GroupV1Record.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupV1Record)
                return object;
            var message = new $root.signalservice.GroupV1Record();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.whitelisted != null)
                message.whitelisted = Boolean(object.whitelisted);
            if (object.archived != null)
                message.archived = Boolean(object.archived);
            if (object.markedUnread != null)
                message.markedUnread = Boolean(object.markedUnread);
            if (object.mutedUntilTimestamp != null)
                if ($util.Long)
                    (message.mutedUntilTimestamp = $util.Long.fromValue(object.mutedUntilTimestamp)).unsigned = true;
                else if (typeof object.mutedUntilTimestamp === "string")
                    message.mutedUntilTimestamp = parseInt(object.mutedUntilTimestamp, 10);
                else if (typeof object.mutedUntilTimestamp === "number")
                    message.mutedUntilTimestamp = object.mutedUntilTimestamp;
                else if (typeof object.mutedUntilTimestamp === "object")
                    message.mutedUntilTimestamp = new $util.LongBits(object.mutedUntilTimestamp.low >>> 0, object.mutedUntilTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a GroupV1Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupV1Record
         * @static
         * @param {signalservice.GroupV1Record} message GroupV1Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupV1Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.blocked = false;
                object.whitelisted = false;
                object.archived = false;
                object.markedUnread = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.mutedUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mutedUntilTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.whitelisted != null && message.hasOwnProperty("whitelisted"))
                object.whitelisted = message.whitelisted;
            if (message.archived != null && message.hasOwnProperty("archived"))
                object.archived = message.archived;
            if (message.markedUnread != null && message.hasOwnProperty("markedUnread"))
                object.markedUnread = message.markedUnread;
            if (message.mutedUntilTimestamp != null && message.hasOwnProperty("mutedUntilTimestamp"))
                if (typeof message.mutedUntilTimestamp === "number")
                    object.mutedUntilTimestamp = options.longs === String ? String(message.mutedUntilTimestamp) : message.mutedUntilTimestamp;
                else
                    object.mutedUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mutedUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.mutedUntilTimestamp.low >>> 0, message.mutedUntilTimestamp.high >>> 0).toNumber(true) : message.mutedUntilTimestamp;
            return object;
        };

        /**
         * Converts this GroupV1Record to JSON.
         * @function toJSON
         * @memberof signalservice.GroupV1Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupV1Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupV1Record;
    })();

    signalservice.GroupV2Record = (function() {

        /**
         * Properties of a GroupV2Record.
         * @memberof signalservice
         * @interface IGroupV2Record
         * @property {Uint8Array|null} [masterKey] GroupV2Record masterKey
         * @property {boolean|null} [blocked] GroupV2Record blocked
         * @property {boolean|null} [whitelisted] GroupV2Record whitelisted
         * @property {boolean|null} [archived] GroupV2Record archived
         * @property {boolean|null} [markedUnread] GroupV2Record markedUnread
         * @property {Long|null} [mutedUntilTimestamp] GroupV2Record mutedUntilTimestamp
         * @property {boolean|null} [dontNotifyForMentionsIfMuted] GroupV2Record dontNotifyForMentionsIfMuted
         * @property {boolean|null} [hideStory] GroupV2Record hideStory
         */

        /**
         * Constructs a new GroupV2Record.
         * @memberof signalservice
         * @classdesc Represents a GroupV2Record.
         * @implements IGroupV2Record
         * @constructor
         * @param {signalservice.IGroupV2Record=} [properties] Properties to set
         */
        function GroupV2Record(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupV2Record masterKey.
         * @member {Uint8Array} masterKey
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.masterKey = $util.newBuffer([]);

        /**
         * GroupV2Record blocked.
         * @member {boolean} blocked
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.blocked = false;

        /**
         * GroupV2Record whitelisted.
         * @member {boolean} whitelisted
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.whitelisted = false;

        /**
         * GroupV2Record archived.
         * @member {boolean} archived
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.archived = false;

        /**
         * GroupV2Record markedUnread.
         * @member {boolean} markedUnread
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.markedUnread = false;

        /**
         * GroupV2Record mutedUntilTimestamp.
         * @member {Long} mutedUntilTimestamp
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.mutedUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GroupV2Record dontNotifyForMentionsIfMuted.
         * @member {boolean} dontNotifyForMentionsIfMuted
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.dontNotifyForMentionsIfMuted = false;

        /**
         * GroupV2Record hideStory.
         * @member {boolean} hideStory
         * @memberof signalservice.GroupV2Record
         * @instance
         */
        GroupV2Record.prototype.hideStory = false;

        /**
         * Encodes the specified GroupV2Record message. Does not implicitly {@link signalservice.GroupV2Record.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {signalservice.IGroupV2Record} message GroupV2Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupV2Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.GroupV2Record.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.masterKey != null && Object.hasOwnProperty.call(message, "masterKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterKey);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.blocked);
            if (message.whitelisted != null && Object.hasOwnProperty.call(message, "whitelisted"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.whitelisted);
            if (message.archived != null && Object.hasOwnProperty.call(message, "archived"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.archived);
            if (message.markedUnread != null && Object.hasOwnProperty.call(message, "markedUnread"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.markedUnread);
            if (message.mutedUntilTimestamp != null && Object.hasOwnProperty.call(message, "mutedUntilTimestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.mutedUntilTimestamp);
            if (message.dontNotifyForMentionsIfMuted != null && Object.hasOwnProperty.call(message, "dontNotifyForMentionsIfMuted"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.dontNotifyForMentionsIfMuted);
            if (message.hideStory != null && Object.hasOwnProperty.call(message, "hideStory"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hideStory);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupV2Record message, length delimited. Does not implicitly {@link signalservice.GroupV2Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {signalservice.IGroupV2Record} message GroupV2Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupV2Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupV2Record message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupV2Record} GroupV2Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupV2Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupV2Record();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.masterKey = reader.bytes();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                case 3:
                    message.whitelisted = reader.bool();
                    break;
                case 4:
                    message.archived = reader.bool();
                    break;
                case 5:
                    message.markedUnread = reader.bool();
                    break;
                case 6:
                    message.mutedUntilTimestamp = reader.uint64();
                    break;
                case 7:
                    message.dontNotifyForMentionsIfMuted = reader.bool();
                    break;
                case 8:
                    message.hideStory = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupV2Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupV2Record} GroupV2Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupV2Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a GroupV2Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupV2Record} GroupV2Record
         */
        GroupV2Record.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupV2Record)
                return object;
            var message = new $root.signalservice.GroupV2Record();
            if (object.masterKey != null)
                if (typeof object.masterKey === "string")
                    $util.base64.decode(object.masterKey, message.masterKey = $util.newBuffer($util.base64.length(object.masterKey)), 0);
                else if (object.masterKey.length)
                    message.masterKey = object.masterKey;
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.whitelisted != null)
                message.whitelisted = Boolean(object.whitelisted);
            if (object.archived != null)
                message.archived = Boolean(object.archived);
            if (object.markedUnread != null)
                message.markedUnread = Boolean(object.markedUnread);
            if (object.mutedUntilTimestamp != null)
                if ($util.Long)
                    (message.mutedUntilTimestamp = $util.Long.fromValue(object.mutedUntilTimestamp)).unsigned = true;
                else if (typeof object.mutedUntilTimestamp === "string")
                    message.mutedUntilTimestamp = parseInt(object.mutedUntilTimestamp, 10);
                else if (typeof object.mutedUntilTimestamp === "number")
                    message.mutedUntilTimestamp = object.mutedUntilTimestamp;
                else if (typeof object.mutedUntilTimestamp === "object")
                    message.mutedUntilTimestamp = new $util.LongBits(object.mutedUntilTimestamp.low >>> 0, object.mutedUntilTimestamp.high >>> 0).toNumber(true);
            if (object.dontNotifyForMentionsIfMuted != null)
                message.dontNotifyForMentionsIfMuted = Boolean(object.dontNotifyForMentionsIfMuted);
            if (object.hideStory != null)
                message.hideStory = Boolean(object.hideStory);
            return message;
        };

        /**
         * Creates a plain object from a GroupV2Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupV2Record
         * @static
         * @param {signalservice.GroupV2Record} message GroupV2Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupV2Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.masterKey = "";
                else {
                    object.masterKey = [];
                    if (options.bytes !== Array)
                        object.masterKey = $util.newBuffer(object.masterKey);
                }
                object.blocked = false;
                object.whitelisted = false;
                object.archived = false;
                object.markedUnread = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.mutedUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mutedUntilTimestamp = options.longs === String ? "0" : 0;
                object.dontNotifyForMentionsIfMuted = false;
                object.hideStory = false;
            }
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                object.masterKey = options.bytes === String ? $util.base64.encode(message.masterKey, 0, message.masterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterKey) : message.masterKey;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.whitelisted != null && message.hasOwnProperty("whitelisted"))
                object.whitelisted = message.whitelisted;
            if (message.archived != null && message.hasOwnProperty("archived"))
                object.archived = message.archived;
            if (message.markedUnread != null && message.hasOwnProperty("markedUnread"))
                object.markedUnread = message.markedUnread;
            if (message.mutedUntilTimestamp != null && message.hasOwnProperty("mutedUntilTimestamp"))
                if (typeof message.mutedUntilTimestamp === "number")
                    object.mutedUntilTimestamp = options.longs === String ? String(message.mutedUntilTimestamp) : message.mutedUntilTimestamp;
                else
                    object.mutedUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mutedUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.mutedUntilTimestamp.low >>> 0, message.mutedUntilTimestamp.high >>> 0).toNumber(true) : message.mutedUntilTimestamp;
            if (message.dontNotifyForMentionsIfMuted != null && message.hasOwnProperty("dontNotifyForMentionsIfMuted"))
                object.dontNotifyForMentionsIfMuted = message.dontNotifyForMentionsIfMuted;
            if (message.hideStory != null && message.hasOwnProperty("hideStory"))
                object.hideStory = message.hideStory;
            return object;
        };

        /**
         * Converts this GroupV2Record to JSON.
         * @function toJSON
         * @memberof signalservice.GroupV2Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupV2Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupV2Record;
    })();

    signalservice.AccountRecord = (function() {

        /**
         * Properties of an AccountRecord.
         * @memberof signalservice
         * @interface IAccountRecord
         * @property {Uint8Array|null} [profileKey] AccountRecord profileKey
         * @property {string|null} [givenName] AccountRecord givenName
         * @property {string|null} [familyName] AccountRecord familyName
         * @property {string|null} [avatarUrl] AccountRecord avatarUrl
         * @property {boolean|null} [noteToSelfArchived] AccountRecord noteToSelfArchived
         * @property {boolean|null} [readReceipts] AccountRecord readReceipts
         * @property {boolean|null} [sealedSenderIndicators] AccountRecord sealedSenderIndicators
         * @property {boolean|null} [typingIndicators] AccountRecord typingIndicators
         * @property {boolean|null} [proxiedLinkPreviews] AccountRecord proxiedLinkPreviews
         * @property {boolean|null} [noteToSelfMarkedUnread] AccountRecord noteToSelfMarkedUnread
         * @property {boolean|null} [linkPreviews] AccountRecord linkPreviews
         * @property {signalservice.AccountRecord.PhoneNumberSharingMode|null} [phoneNumberSharingMode] AccountRecord phoneNumberSharingMode
         * @property {boolean|null} [notDiscoverableByPhoneNumber] AccountRecord notDiscoverableByPhoneNumber
         * @property {Array.<signalservice.AccountRecord.IPinnedConversation>|null} [pinnedConversations] AccountRecord pinnedConversations
         * @property {boolean|null} [preferContactAvatars] AccountRecord preferContactAvatars
         * @property {number|null} [universalExpireTimer] AccountRecord universalExpireTimer
         * @property {boolean|null} [primarySendsSms] AccountRecord primarySendsSms
         * @property {string|null} [e164] AccountRecord e164
         * @property {Array.<string>|null} [preferredReactionEmoji] AccountRecord preferredReactionEmoji
         * @property {Uint8Array|null} [subscriberId] AccountRecord subscriberId
         * @property {string|null} [subscriberCurrencyCode] AccountRecord subscriberCurrencyCode
         * @property {boolean|null} [displayBadgesOnProfile] AccountRecord displayBadgesOnProfile
         * @property {boolean|null} [keepMutedChatsArchived] AccountRecord keepMutedChatsArchived
         */

        /**
         * Constructs a new AccountRecord.
         * @memberof signalservice
         * @classdesc Represents an AccountRecord.
         * @implements IAccountRecord
         * @constructor
         * @param {signalservice.IAccountRecord=} [properties] Properties to set
         */
        function AccountRecord(properties) {
            this.pinnedConversations = [];
            this.preferredReactionEmoji = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountRecord profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.profileKey = $util.newBuffer([]);

        /**
         * AccountRecord givenName.
         * @member {string} givenName
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.givenName = "";

        /**
         * AccountRecord familyName.
         * @member {string} familyName
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.familyName = "";

        /**
         * AccountRecord avatarUrl.
         * @member {string} avatarUrl
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.avatarUrl = "";

        /**
         * AccountRecord noteToSelfArchived.
         * @member {boolean} noteToSelfArchived
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.noteToSelfArchived = false;

        /**
         * AccountRecord readReceipts.
         * @member {boolean} readReceipts
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.readReceipts = false;

        /**
         * AccountRecord sealedSenderIndicators.
         * @member {boolean} sealedSenderIndicators
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.sealedSenderIndicators = false;

        /**
         * AccountRecord typingIndicators.
         * @member {boolean} typingIndicators
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.typingIndicators = false;

        /**
         * AccountRecord proxiedLinkPreviews.
         * @member {boolean} proxiedLinkPreviews
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.proxiedLinkPreviews = false;

        /**
         * AccountRecord noteToSelfMarkedUnread.
         * @member {boolean} noteToSelfMarkedUnread
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.noteToSelfMarkedUnread = false;

        /**
         * AccountRecord linkPreviews.
         * @member {boolean} linkPreviews
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.linkPreviews = false;

        /**
         * AccountRecord phoneNumberSharingMode.
         * @member {signalservice.AccountRecord.PhoneNumberSharingMode} phoneNumberSharingMode
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.phoneNumberSharingMode = 0;

        /**
         * AccountRecord notDiscoverableByPhoneNumber.
         * @member {boolean} notDiscoverableByPhoneNumber
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.notDiscoverableByPhoneNumber = false;

        /**
         * AccountRecord pinnedConversations.
         * @member {Array.<signalservice.AccountRecord.IPinnedConversation>} pinnedConversations
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.pinnedConversations = $util.emptyArray;

        /**
         * AccountRecord preferContactAvatars.
         * @member {boolean} preferContactAvatars
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.preferContactAvatars = false;

        /**
         * AccountRecord universalExpireTimer.
         * @member {number} universalExpireTimer
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.universalExpireTimer = 0;

        /**
         * AccountRecord primarySendsSms.
         * @member {boolean} primarySendsSms
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.primarySendsSms = false;

        /**
         * AccountRecord e164.
         * @member {string} e164
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.e164 = "";

        /**
         * AccountRecord preferredReactionEmoji.
         * @member {Array.<string>} preferredReactionEmoji
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.preferredReactionEmoji = $util.emptyArray;

        /**
         * AccountRecord subscriberId.
         * @member {Uint8Array} subscriberId
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.subscriberId = $util.newBuffer([]);

        /**
         * AccountRecord subscriberCurrencyCode.
         * @member {string} subscriberCurrencyCode
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.subscriberCurrencyCode = "";

        /**
         * AccountRecord displayBadgesOnProfile.
         * @member {boolean} displayBadgesOnProfile
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.displayBadgesOnProfile = false;

        /**
         * AccountRecord keepMutedChatsArchived.
         * @member {boolean} keepMutedChatsArchived
         * @memberof signalservice.AccountRecord
         * @instance
         */
        AccountRecord.prototype.keepMutedChatsArchived = false;

        /**
         * Encodes the specified AccountRecord message. Does not implicitly {@link signalservice.AccountRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.AccountRecord
         * @static
         * @param {signalservice.IAccountRecord} message AccountRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.AccountRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.profileKey);
            if (message.givenName != null && Object.hasOwnProperty.call(message, "givenName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.givenName);
            if (message.familyName != null && Object.hasOwnProperty.call(message, "familyName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.familyName);
            if (message.avatarUrl != null && Object.hasOwnProperty.call(message, "avatarUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarUrl);
            if (message.noteToSelfArchived != null && Object.hasOwnProperty.call(message, "noteToSelfArchived"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.noteToSelfArchived);
            if (message.readReceipts != null && Object.hasOwnProperty.call(message, "readReceipts"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.readReceipts);
            if (message.sealedSenderIndicators != null && Object.hasOwnProperty.call(message, "sealedSenderIndicators"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.sealedSenderIndicators);
            if (message.typingIndicators != null && Object.hasOwnProperty.call(message, "typingIndicators"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.typingIndicators);
            if (message.proxiedLinkPreviews != null && Object.hasOwnProperty.call(message, "proxiedLinkPreviews"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.proxiedLinkPreviews);
            if (message.noteToSelfMarkedUnread != null && Object.hasOwnProperty.call(message, "noteToSelfMarkedUnread"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.noteToSelfMarkedUnread);
            if (message.linkPreviews != null && Object.hasOwnProperty.call(message, "linkPreviews"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.linkPreviews);
            if (message.phoneNumberSharingMode != null && Object.hasOwnProperty.call(message, "phoneNumberSharingMode"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.phoneNumberSharingMode);
            if (message.notDiscoverableByPhoneNumber != null && Object.hasOwnProperty.call(message, "notDiscoverableByPhoneNumber"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.notDiscoverableByPhoneNumber);
            if (message.pinnedConversations != null && message.pinnedConversations.length)
                for (var i = 0; i < message.pinnedConversations.length; ++i)
                    $root.signalservice.AccountRecord.PinnedConversation.encode(message.pinnedConversations[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.preferContactAvatars != null && Object.hasOwnProperty.call(message, "preferContactAvatars"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.preferContactAvatars);
            if (message.universalExpireTimer != null && Object.hasOwnProperty.call(message, "universalExpireTimer"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.universalExpireTimer);
            if (message.primarySendsSms != null && Object.hasOwnProperty.call(message, "primarySendsSms"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.primarySendsSms);
            if (message.e164 != null && Object.hasOwnProperty.call(message, "e164"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.e164);
            if (message.preferredReactionEmoji != null && message.preferredReactionEmoji.length)
                for (var i = 0; i < message.preferredReactionEmoji.length; ++i)
                    writer.uint32(/* id 20, wireType 2 =*/162).string(message.preferredReactionEmoji[i]);
            if (message.subscriberId != null && Object.hasOwnProperty.call(message, "subscriberId"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.subscriberId);
            if (message.subscriberCurrencyCode != null && Object.hasOwnProperty.call(message, "subscriberCurrencyCode"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.subscriberCurrencyCode);
            if (message.displayBadgesOnProfile != null && Object.hasOwnProperty.call(message, "displayBadgesOnProfile"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.displayBadgesOnProfile);
            if (message.keepMutedChatsArchived != null && Object.hasOwnProperty.call(message, "keepMutedChatsArchived"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.keepMutedChatsArchived);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified AccountRecord message, length delimited. Does not implicitly {@link signalservice.AccountRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.AccountRecord
         * @static
         * @param {signalservice.IAccountRecord} message AccountRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.AccountRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.AccountRecord} AccountRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AccountRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.profileKey = reader.bytes();
                    break;
                case 2:
                    message.givenName = reader.string();
                    break;
                case 3:
                    message.familyName = reader.string();
                    break;
                case 4:
                    message.avatarUrl = reader.string();
                    break;
                case 5:
                    message.noteToSelfArchived = reader.bool();
                    break;
                case 6:
                    message.readReceipts = reader.bool();
                    break;
                case 7:
                    message.sealedSenderIndicators = reader.bool();
                    break;
                case 8:
                    message.typingIndicators = reader.bool();
                    break;
                case 9:
                    message.proxiedLinkPreviews = reader.bool();
                    break;
                case 10:
                    message.noteToSelfMarkedUnread = reader.bool();
                    break;
                case 11:
                    message.linkPreviews = reader.bool();
                    break;
                case 12:
                    message.phoneNumberSharingMode = reader.int32();
                    break;
                case 13:
                    message.notDiscoverableByPhoneNumber = reader.bool();
                    break;
                case 14:
                    if (!(message.pinnedConversations && message.pinnedConversations.length))
                        message.pinnedConversations = [];
                    message.pinnedConversations.push($root.signalservice.AccountRecord.PinnedConversation.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.preferContactAvatars = reader.bool();
                    break;
                case 17:
                    message.universalExpireTimer = reader.uint32();
                    break;
                case 18:
                    message.primarySendsSms = reader.bool();
                    break;
                case 19:
                    message.e164 = reader.string();
                    break;
                case 20:
                    if (!(message.preferredReactionEmoji && message.preferredReactionEmoji.length))
                        message.preferredReactionEmoji = [];
                    message.preferredReactionEmoji.push(reader.string());
                    break;
                case 21:
                    message.subscriberId = reader.bytes();
                    break;
                case 22:
                    message.subscriberCurrencyCode = reader.string();
                    break;
                case 23:
                    message.displayBadgesOnProfile = reader.bool();
                    break;
                case 25:
                    message.keepMutedChatsArchived = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.AccountRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.AccountRecord} AccountRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an AccountRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.AccountRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.AccountRecord} AccountRecord
         */
        AccountRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.AccountRecord)
                return object;
            var message = new $root.signalservice.AccountRecord();
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length)
                    message.profileKey = object.profileKey;
            if (object.givenName != null)
                message.givenName = String(object.givenName);
            if (object.familyName != null)
                message.familyName = String(object.familyName);
            if (object.avatarUrl != null)
                message.avatarUrl = String(object.avatarUrl);
            if (object.noteToSelfArchived != null)
                message.noteToSelfArchived = Boolean(object.noteToSelfArchived);
            if (object.readReceipts != null)
                message.readReceipts = Boolean(object.readReceipts);
            if (object.sealedSenderIndicators != null)
                message.sealedSenderIndicators = Boolean(object.sealedSenderIndicators);
            if (object.typingIndicators != null)
                message.typingIndicators = Boolean(object.typingIndicators);
            if (object.proxiedLinkPreviews != null)
                message.proxiedLinkPreviews = Boolean(object.proxiedLinkPreviews);
            if (object.noteToSelfMarkedUnread != null)
                message.noteToSelfMarkedUnread = Boolean(object.noteToSelfMarkedUnread);
            if (object.linkPreviews != null)
                message.linkPreviews = Boolean(object.linkPreviews);
            switch (object.phoneNumberSharingMode) {
            case "EVERYBODY":
            case 0:
                message.phoneNumberSharingMode = 0;
                break;
            case "CONTACTS_ONLY":
            case 1:
                message.phoneNumberSharingMode = 1;
                break;
            case "NOBODY":
            case 2:
                message.phoneNumberSharingMode = 2;
                break;
            }
            if (object.notDiscoverableByPhoneNumber != null)
                message.notDiscoverableByPhoneNumber = Boolean(object.notDiscoverableByPhoneNumber);
            if (object.pinnedConversations) {
                if (!Array.isArray(object.pinnedConversations))
                    throw TypeError(".signalservice.AccountRecord.pinnedConversations: array expected");
                message.pinnedConversations = [];
                for (var i = 0; i < object.pinnedConversations.length; ++i) {
                    if (typeof object.pinnedConversations[i] !== "object")
                        throw TypeError(".signalservice.AccountRecord.pinnedConversations: object expected");
                    message.pinnedConversations[i] = $root.signalservice.AccountRecord.PinnedConversation.fromObject(object.pinnedConversations[i]);
                }
            }
            if (object.preferContactAvatars != null)
                message.preferContactAvatars = Boolean(object.preferContactAvatars);
            if (object.universalExpireTimer != null)
                message.universalExpireTimer = object.universalExpireTimer >>> 0;
            if (object.primarySendsSms != null)
                message.primarySendsSms = Boolean(object.primarySendsSms);
            if (object.e164 != null)
                message.e164 = String(object.e164);
            if (object.preferredReactionEmoji) {
                if (!Array.isArray(object.preferredReactionEmoji))
                    throw TypeError(".signalservice.AccountRecord.preferredReactionEmoji: array expected");
                message.preferredReactionEmoji = [];
                for (var i = 0; i < object.preferredReactionEmoji.length; ++i)
                    message.preferredReactionEmoji[i] = String(object.preferredReactionEmoji[i]);
            }
            if (object.subscriberId != null)
                if (typeof object.subscriberId === "string")
                    $util.base64.decode(object.subscriberId, message.subscriberId = $util.newBuffer($util.base64.length(object.subscriberId)), 0);
                else if (object.subscriberId.length)
                    message.subscriberId = object.subscriberId;
            if (object.subscriberCurrencyCode != null)
                message.subscriberCurrencyCode = String(object.subscriberCurrencyCode);
            if (object.displayBadgesOnProfile != null)
                message.displayBadgesOnProfile = Boolean(object.displayBadgesOnProfile);
            if (object.keepMutedChatsArchived != null)
                message.keepMutedChatsArchived = Boolean(object.keepMutedChatsArchived);
            return message;
        };

        /**
         * Creates a plain object from an AccountRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.AccountRecord
         * @static
         * @param {signalservice.AccountRecord} message AccountRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pinnedConversations = [];
                object.preferredReactionEmoji = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.givenName = "";
                object.familyName = "";
                object.avatarUrl = "";
                object.noteToSelfArchived = false;
                object.readReceipts = false;
                object.sealedSenderIndicators = false;
                object.typingIndicators = false;
                object.proxiedLinkPreviews = false;
                object.noteToSelfMarkedUnread = false;
                object.linkPreviews = false;
                object.phoneNumberSharingMode = options.enums === String ? "EVERYBODY" : 0;
                object.notDiscoverableByPhoneNumber = false;
                object.preferContactAvatars = false;
                object.universalExpireTimer = 0;
                object.primarySendsSms = false;
                object.e164 = "";
                if (options.bytes === String)
                    object.subscriberId = "";
                else {
                    object.subscriberId = [];
                    if (options.bytes !== Array)
                        object.subscriberId = $util.newBuffer(object.subscriberId);
                }
                object.subscriberCurrencyCode = "";
                object.displayBadgesOnProfile = false;
                object.keepMutedChatsArchived = false;
            }
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.givenName != null && message.hasOwnProperty("givenName"))
                object.givenName = message.givenName;
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                object.familyName = message.familyName;
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                object.avatarUrl = message.avatarUrl;
            if (message.noteToSelfArchived != null && message.hasOwnProperty("noteToSelfArchived"))
                object.noteToSelfArchived = message.noteToSelfArchived;
            if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                object.readReceipts = message.readReceipts;
            if (message.sealedSenderIndicators != null && message.hasOwnProperty("sealedSenderIndicators"))
                object.sealedSenderIndicators = message.sealedSenderIndicators;
            if (message.typingIndicators != null && message.hasOwnProperty("typingIndicators"))
                object.typingIndicators = message.typingIndicators;
            if (message.proxiedLinkPreviews != null && message.hasOwnProperty("proxiedLinkPreviews"))
                object.proxiedLinkPreviews = message.proxiedLinkPreviews;
            if (message.noteToSelfMarkedUnread != null && message.hasOwnProperty("noteToSelfMarkedUnread"))
                object.noteToSelfMarkedUnread = message.noteToSelfMarkedUnread;
            if (message.linkPreviews != null && message.hasOwnProperty("linkPreviews"))
                object.linkPreviews = message.linkPreviews;
            if (message.phoneNumberSharingMode != null && message.hasOwnProperty("phoneNumberSharingMode"))
                object.phoneNumberSharingMode = options.enums === String ? $root.signalservice.AccountRecord.PhoneNumberSharingMode[message.phoneNumberSharingMode] : message.phoneNumberSharingMode;
            if (message.notDiscoverableByPhoneNumber != null && message.hasOwnProperty("notDiscoverableByPhoneNumber"))
                object.notDiscoverableByPhoneNumber = message.notDiscoverableByPhoneNumber;
            if (message.pinnedConversations && message.pinnedConversations.length) {
                object.pinnedConversations = [];
                for (var j = 0; j < message.pinnedConversations.length; ++j)
                    object.pinnedConversations[j] = $root.signalservice.AccountRecord.PinnedConversation.toObject(message.pinnedConversations[j], options);
            }
            if (message.preferContactAvatars != null && message.hasOwnProperty("preferContactAvatars"))
                object.preferContactAvatars = message.preferContactAvatars;
            if (message.universalExpireTimer != null && message.hasOwnProperty("universalExpireTimer"))
                object.universalExpireTimer = message.universalExpireTimer;
            if (message.primarySendsSms != null && message.hasOwnProperty("primarySendsSms"))
                object.primarySendsSms = message.primarySendsSms;
            if (message.e164 != null && message.hasOwnProperty("e164"))
                object.e164 = message.e164;
            if (message.preferredReactionEmoji && message.preferredReactionEmoji.length) {
                object.preferredReactionEmoji = [];
                for (var j = 0; j < message.preferredReactionEmoji.length; ++j)
                    object.preferredReactionEmoji[j] = message.preferredReactionEmoji[j];
            }
            if (message.subscriberId != null && message.hasOwnProperty("subscriberId"))
                object.subscriberId = options.bytes === String ? $util.base64.encode(message.subscriberId, 0, message.subscriberId.length) : options.bytes === Array ? Array.prototype.slice.call(message.subscriberId) : message.subscriberId;
            if (message.subscriberCurrencyCode != null && message.hasOwnProperty("subscriberCurrencyCode"))
                object.subscriberCurrencyCode = message.subscriberCurrencyCode;
            if (message.displayBadgesOnProfile != null && message.hasOwnProperty("displayBadgesOnProfile"))
                object.displayBadgesOnProfile = message.displayBadgesOnProfile;
            if (message.keepMutedChatsArchived != null && message.hasOwnProperty("keepMutedChatsArchived"))
                object.keepMutedChatsArchived = message.keepMutedChatsArchived;
            return object;
        };

        /**
         * Converts this AccountRecord to JSON.
         * @function toJSON
         * @memberof signalservice.AccountRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PhoneNumberSharingMode enum.
         * @name signalservice.AccountRecord.PhoneNumberSharingMode
         * @enum {number}
         * @property {number} EVERYBODY=0 EVERYBODY value
         * @property {number} CONTACTS_ONLY=1 CONTACTS_ONLY value
         * @property {number} NOBODY=2 NOBODY value
         */
        AccountRecord.PhoneNumberSharingMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EVERYBODY"] = 0;
            values[valuesById[1] = "CONTACTS_ONLY"] = 1;
            values[valuesById[2] = "NOBODY"] = 2;
            return values;
        })();

        AccountRecord.PinnedConversation = (function() {

            /**
             * Properties of a PinnedConversation.
             * @memberof signalservice.AccountRecord
             * @interface IPinnedConversation
             * @property {signalservice.AccountRecord.PinnedConversation.IContact|null} [contact] PinnedConversation contact
             * @property {Uint8Array|null} [legacyGroupId] PinnedConversation legacyGroupId
             * @property {Uint8Array|null} [groupMasterKey] PinnedConversation groupMasterKey
             */

            /**
             * Constructs a new PinnedConversation.
             * @memberof signalservice.AccountRecord
             * @classdesc Represents a PinnedConversation.
             * @implements IPinnedConversation
             * @constructor
             * @param {signalservice.AccountRecord.IPinnedConversation=} [properties] Properties to set
             */
            function PinnedConversation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PinnedConversation contact.
             * @member {signalservice.AccountRecord.PinnedConversation.IContact|null|undefined} contact
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @instance
             */
            PinnedConversation.prototype.contact = null;

            /**
             * PinnedConversation legacyGroupId.
             * @member {Uint8Array|null|undefined} legacyGroupId
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @instance
             */
            PinnedConversation.prototype.legacyGroupId = null;

            /**
             * PinnedConversation groupMasterKey.
             * @member {Uint8Array|null|undefined} groupMasterKey
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @instance
             */
            PinnedConversation.prototype.groupMasterKey = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PinnedConversation identifier.
             * @member {"contact"|"legacyGroupId"|"groupMasterKey"|undefined} identifier
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @instance
             */
            Object.defineProperty(PinnedConversation.prototype, "identifier", {
                get: $util.oneOfGetter($oneOfFields = ["contact", "legacyGroupId", "groupMasterKey"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Encodes the specified PinnedConversation message. Does not implicitly {@link signalservice.AccountRecord.PinnedConversation.verify|verify} messages.
             * @function encode
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {signalservice.AccountRecord.IPinnedConversation} message PinnedConversation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PinnedConversation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.AccountRecord.PinnedConversation.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.signalservice.AccountRecord.PinnedConversation.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.legacyGroupId != null && Object.hasOwnProperty.call(message, "legacyGroupId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.legacyGroupId);
                if (message.groupMasterKey != null && Object.hasOwnProperty.call(message, "groupMasterKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.groupMasterKey);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified PinnedConversation message, length delimited. Does not implicitly {@link signalservice.AccountRecord.PinnedConversation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {signalservice.AccountRecord.IPinnedConversation} message PinnedConversation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PinnedConversation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PinnedConversation message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.AccountRecord.PinnedConversation} PinnedConversation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PinnedConversation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AccountRecord.PinnedConversation();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contact = $root.signalservice.AccountRecord.PinnedConversation.Contact.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.legacyGroupId = reader.bytes();
                        break;
                    case 4:
                        message.groupMasterKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PinnedConversation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.AccountRecord.PinnedConversation} PinnedConversation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PinnedConversation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a PinnedConversation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.AccountRecord.PinnedConversation} PinnedConversation
             */
            PinnedConversation.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.AccountRecord.PinnedConversation)
                    return object;
                var message = new $root.signalservice.AccountRecord.PinnedConversation();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".signalservice.AccountRecord.PinnedConversation.contact: object expected");
                    message.contact = $root.signalservice.AccountRecord.PinnedConversation.Contact.fromObject(object.contact);
                }
                if (object.legacyGroupId != null)
                    if (typeof object.legacyGroupId === "string")
                        $util.base64.decode(object.legacyGroupId, message.legacyGroupId = $util.newBuffer($util.base64.length(object.legacyGroupId)), 0);
                    else if (object.legacyGroupId.length)
                        message.legacyGroupId = object.legacyGroupId;
                if (object.groupMasterKey != null)
                    if (typeof object.groupMasterKey === "string")
                        $util.base64.decode(object.groupMasterKey, message.groupMasterKey = $util.newBuffer($util.base64.length(object.groupMasterKey)), 0);
                    else if (object.groupMasterKey.length)
                        message.groupMasterKey = object.groupMasterKey;
                return message;
            };

            /**
             * Creates a plain object from a PinnedConversation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @static
             * @param {signalservice.AccountRecord.PinnedConversation} message PinnedConversation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PinnedConversation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    object.contact = $root.signalservice.AccountRecord.PinnedConversation.Contact.toObject(message.contact, options);
                    if (options.oneofs)
                        object.identifier = "contact";
                }
                if (message.legacyGroupId != null && message.hasOwnProperty("legacyGroupId")) {
                    object.legacyGroupId = options.bytes === String ? $util.base64.encode(message.legacyGroupId, 0, message.legacyGroupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.legacyGroupId) : message.legacyGroupId;
                    if (options.oneofs)
                        object.identifier = "legacyGroupId";
                }
                if (message.groupMasterKey != null && message.hasOwnProperty("groupMasterKey")) {
                    object.groupMasterKey = options.bytes === String ? $util.base64.encode(message.groupMasterKey, 0, message.groupMasterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupMasterKey) : message.groupMasterKey;
                    if (options.oneofs)
                        object.identifier = "groupMasterKey";
                }
                return object;
            };

            /**
             * Converts this PinnedConversation to JSON.
             * @function toJSON
             * @memberof signalservice.AccountRecord.PinnedConversation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PinnedConversation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PinnedConversation.Contact = (function() {

                /**
                 * Properties of a Contact.
                 * @memberof signalservice.AccountRecord.PinnedConversation
                 * @interface IContact
                 * @property {string|null} [uuid] Contact uuid
                 * @property {string|null} [e164] Contact e164
                 */

                /**
                 * Constructs a new Contact.
                 * @memberof signalservice.AccountRecord.PinnedConversation
                 * @classdesc Represents a Contact.
                 * @implements IContact
                 * @constructor
                 * @param {signalservice.AccountRecord.PinnedConversation.IContact=} [properties] Properties to set
                 */
                function Contact(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Contact uuid.
                 * @member {string} uuid
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @instance
                 */
                Contact.prototype.uuid = "";

                /**
                 * Contact e164.
                 * @member {string} e164
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @instance
                 */
                Contact.prototype.e164 = "";

                /**
                 * Encodes the specified Contact message. Does not implicitly {@link signalservice.AccountRecord.PinnedConversation.Contact.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {signalservice.AccountRecord.PinnedConversation.IContact} message Contact message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Contact.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signalservice.AccountRecord.PinnedConversation.Contact.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);
                    if (message.e164 != null && Object.hasOwnProperty.call(message, "e164"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.e164);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Contact message, length delimited. Does not implicitly {@link signalservice.AccountRecord.PinnedConversation.Contact.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {signalservice.AccountRecord.PinnedConversation.IContact} message Contact message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Contact.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Contact message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.AccountRecord.PinnedConversation.Contact} Contact
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Contact.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AccountRecord.PinnedConversation.Contact();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uuid = reader.string();
                            break;
                        case 2:
                            message.e164 = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Contact message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.AccountRecord.PinnedConversation.Contact} Contact
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Contact.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a Contact message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.AccountRecord.PinnedConversation.Contact} Contact
                 */
                Contact.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.AccountRecord.PinnedConversation.Contact)
                        return object;
                    var message = new $root.signalservice.AccountRecord.PinnedConversation.Contact();
                    if (object.uuid != null)
                        message.uuid = String(object.uuid);
                    if (object.e164 != null)
                        message.e164 = String(object.e164);
                    return message;
                };

                /**
                 * Creates a plain object from a Contact message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @static
                 * @param {signalservice.AccountRecord.PinnedConversation.Contact} message Contact
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Contact.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.uuid = "";
                        object.e164 = "";
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = message.uuid;
                    if (message.e164 != null && message.hasOwnProperty("e164"))
                        object.e164 = message.e164;
                    return object;
                };

                /**
                 * Converts this Contact to JSON.
                 * @function toJSON
                 * @memberof signalservice.AccountRecord.PinnedConversation.Contact
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Contact.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Contact;
            })();

            return PinnedConversation;
        })();

        return AccountRecord;
    })();

    signalservice.StoryDistributionListRecord = (function() {

        /**
         * Properties of a StoryDistributionListRecord.
         * @memberof signalservice
         * @interface IStoryDistributionListRecord
         * @property {Uint8Array|null} [identifier] StoryDistributionListRecord identifier
         * @property {string|null} [name] StoryDistributionListRecord name
         * @property {Array.<string>|null} [recipientUuids] StoryDistributionListRecord recipientUuids
         * @property {Long|null} [deletedAtTimestamp] StoryDistributionListRecord deletedAtTimestamp
         * @property {boolean|null} [allowsReplies] StoryDistributionListRecord allowsReplies
         * @property {boolean|null} [isBlockList] StoryDistributionListRecord isBlockList
         */

        /**
         * Constructs a new StoryDistributionListRecord.
         * @memberof signalservice
         * @classdesc Represents a StoryDistributionListRecord.
         * @implements IStoryDistributionListRecord
         * @constructor
         * @param {signalservice.IStoryDistributionListRecord=} [properties] Properties to set
         */
        function StoryDistributionListRecord(properties) {
            this.recipientUuids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StoryDistributionListRecord identifier.
         * @member {Uint8Array} identifier
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.identifier = $util.newBuffer([]);

        /**
         * StoryDistributionListRecord name.
         * @member {string} name
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.name = "";

        /**
         * StoryDistributionListRecord recipientUuids.
         * @member {Array.<string>} recipientUuids
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.recipientUuids = $util.emptyArray;

        /**
         * StoryDistributionListRecord deletedAtTimestamp.
         * @member {Long} deletedAtTimestamp
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.deletedAtTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StoryDistributionListRecord allowsReplies.
         * @member {boolean} allowsReplies
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.allowsReplies = false;

        /**
         * StoryDistributionListRecord isBlockList.
         * @member {boolean} isBlockList
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         */
        StoryDistributionListRecord.prototype.isBlockList = false;

        /**
         * Encodes the specified StoryDistributionListRecord message. Does not implicitly {@link signalservice.StoryDistributionListRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {signalservice.IStoryDistributionListRecord} message StoryDistributionListRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryDistributionListRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StoryDistributionListRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.identifier);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.recipientUuids != null && message.recipientUuids.length)
                for (var i = 0; i < message.recipientUuids.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientUuids[i]);
            if (message.deletedAtTimestamp != null && Object.hasOwnProperty.call(message, "deletedAtTimestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.deletedAtTimestamp);
            if (message.allowsReplies != null && Object.hasOwnProperty.call(message, "allowsReplies"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.allowsReplies);
            if (message.isBlockList != null && Object.hasOwnProperty.call(message, "isBlockList"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isBlockList);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StoryDistributionListRecord message, length delimited. Does not implicitly {@link signalservice.StoryDistributionListRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {signalservice.IStoryDistributionListRecord} message StoryDistributionListRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryDistributionListRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StoryDistributionListRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StoryDistributionListRecord} StoryDistributionListRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryDistributionListRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StoryDistributionListRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identifier = reader.bytes();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.recipientUuids && message.recipientUuids.length))
                        message.recipientUuids = [];
                    message.recipientUuids.push(reader.string());
                    break;
                case 4:
                    message.deletedAtTimestamp = reader.uint64();
                    break;
                case 5:
                    message.allowsReplies = reader.bool();
                    break;
                case 6:
                    message.isBlockList = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StoryDistributionListRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StoryDistributionListRecord} StoryDistributionListRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryDistributionListRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StoryDistributionListRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StoryDistributionListRecord} StoryDistributionListRecord
         */
        StoryDistributionListRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StoryDistributionListRecord)
                return object;
            var message = new $root.signalservice.StoryDistributionListRecord();
            if (object.identifier != null)
                if (typeof object.identifier === "string")
                    $util.base64.decode(object.identifier, message.identifier = $util.newBuffer($util.base64.length(object.identifier)), 0);
                else if (object.identifier.length)
                    message.identifier = object.identifier;
            if (object.name != null)
                message.name = String(object.name);
            if (object.recipientUuids) {
                if (!Array.isArray(object.recipientUuids))
                    throw TypeError(".signalservice.StoryDistributionListRecord.recipientUuids: array expected");
                message.recipientUuids = [];
                for (var i = 0; i < object.recipientUuids.length; ++i)
                    message.recipientUuids[i] = String(object.recipientUuids[i]);
            }
            if (object.deletedAtTimestamp != null)
                if ($util.Long)
                    (message.deletedAtTimestamp = $util.Long.fromValue(object.deletedAtTimestamp)).unsigned = true;
                else if (typeof object.deletedAtTimestamp === "string")
                    message.deletedAtTimestamp = parseInt(object.deletedAtTimestamp, 10);
                else if (typeof object.deletedAtTimestamp === "number")
                    message.deletedAtTimestamp = object.deletedAtTimestamp;
                else if (typeof object.deletedAtTimestamp === "object")
                    message.deletedAtTimestamp = new $util.LongBits(object.deletedAtTimestamp.low >>> 0, object.deletedAtTimestamp.high >>> 0).toNumber(true);
            if (object.allowsReplies != null)
                message.allowsReplies = Boolean(object.allowsReplies);
            if (object.isBlockList != null)
                message.isBlockList = Boolean(object.isBlockList);
            return message;
        };

        /**
         * Creates a plain object from a StoryDistributionListRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StoryDistributionListRecord
         * @static
         * @param {signalservice.StoryDistributionListRecord} message StoryDistributionListRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StoryDistributionListRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recipientUuids = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.identifier = "";
                else {
                    object.identifier = [];
                    if (options.bytes !== Array)
                        object.identifier = $util.newBuffer(object.identifier);
                }
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.deletedAtTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deletedAtTimestamp = options.longs === String ? "0" : 0;
                object.allowsReplies = false;
                object.isBlockList = false;
            }
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                object.identifier = options.bytes === String ? $util.base64.encode(message.identifier, 0, message.identifier.length) : options.bytes === Array ? Array.prototype.slice.call(message.identifier) : message.identifier;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.recipientUuids && message.recipientUuids.length) {
                object.recipientUuids = [];
                for (var j = 0; j < message.recipientUuids.length; ++j)
                    object.recipientUuids[j] = message.recipientUuids[j];
            }
            if (message.deletedAtTimestamp != null && message.hasOwnProperty("deletedAtTimestamp"))
                if (typeof message.deletedAtTimestamp === "number")
                    object.deletedAtTimestamp = options.longs === String ? String(message.deletedAtTimestamp) : message.deletedAtTimestamp;
                else
                    object.deletedAtTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.deletedAtTimestamp) : options.longs === Number ? new $util.LongBits(message.deletedAtTimestamp.low >>> 0, message.deletedAtTimestamp.high >>> 0).toNumber(true) : message.deletedAtTimestamp;
            if (message.allowsReplies != null && message.hasOwnProperty("allowsReplies"))
                object.allowsReplies = message.allowsReplies;
            if (message.isBlockList != null && message.hasOwnProperty("isBlockList"))
                object.isBlockList = message.isBlockList;
            return object;
        };

        /**
         * Converts this StoryDistributionListRecord to JSON.
         * @function toJSON
         * @memberof signalservice.StoryDistributionListRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StoryDistributionListRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StoryDistributionListRecord;
    })();

    signalservice.StickerPackRecord = (function() {

        /**
         * Properties of a StickerPackRecord.
         * @memberof signalservice
         * @interface IStickerPackRecord
         * @property {Uint8Array|null} [packId] StickerPackRecord packId
         * @property {Uint8Array|null} [packKey] StickerPackRecord packKey
         * @property {number|null} [position] StickerPackRecord position
         * @property {Long|null} [deletedAtTimestamp] StickerPackRecord deletedAtTimestamp
         */

        /**
         * Constructs a new StickerPackRecord.
         * @memberof signalservice
         * @classdesc Represents a StickerPackRecord.
         * @implements IStickerPackRecord
         * @constructor
         * @param {signalservice.IStickerPackRecord=} [properties] Properties to set
         */
        function StickerPackRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StickerPackRecord packId.
         * @member {Uint8Array} packId
         * @memberof signalservice.StickerPackRecord
         * @instance
         */
        StickerPackRecord.prototype.packId = $util.newBuffer([]);

        /**
         * StickerPackRecord packKey.
         * @member {Uint8Array} packKey
         * @memberof signalservice.StickerPackRecord
         * @instance
         */
        StickerPackRecord.prototype.packKey = $util.newBuffer([]);

        /**
         * StickerPackRecord position.
         * @member {number} position
         * @memberof signalservice.StickerPackRecord
         * @instance
         */
        StickerPackRecord.prototype.position = 0;

        /**
         * StickerPackRecord deletedAtTimestamp.
         * @member {Long} deletedAtTimestamp
         * @memberof signalservice.StickerPackRecord
         * @instance
         */
        StickerPackRecord.prototype.deletedAtTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified StickerPackRecord message. Does not implicitly {@link signalservice.StickerPackRecord.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {signalservice.IStickerPackRecord} message StickerPackRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerPackRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StickerPackRecord.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.packId != null && Object.hasOwnProperty.call(message, "packId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.packId);
            if (message.packKey != null && Object.hasOwnProperty.call(message, "packKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packKey);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.position);
            if (message.deletedAtTimestamp != null && Object.hasOwnProperty.call(message, "deletedAtTimestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.deletedAtTimestamp);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StickerPackRecord message, length delimited. Does not implicitly {@link signalservice.StickerPackRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {signalservice.IStickerPackRecord} message StickerPackRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerPackRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StickerPackRecord message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StickerPackRecord} StickerPackRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerPackRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StickerPackRecord();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packId = reader.bytes();
                    break;
                case 2:
                    message.packKey = reader.bytes();
                    break;
                case 3:
                    message.position = reader.uint32();
                    break;
                case 4:
                    message.deletedAtTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StickerPackRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StickerPackRecord} StickerPackRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerPackRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StickerPackRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StickerPackRecord} StickerPackRecord
         */
        StickerPackRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StickerPackRecord)
                return object;
            var message = new $root.signalservice.StickerPackRecord();
            if (object.packId != null)
                if (typeof object.packId === "string")
                    $util.base64.decode(object.packId, message.packId = $util.newBuffer($util.base64.length(object.packId)), 0);
                else if (object.packId.length)
                    message.packId = object.packId;
            if (object.packKey != null)
                if (typeof object.packKey === "string")
                    $util.base64.decode(object.packKey, message.packKey = $util.newBuffer($util.base64.length(object.packKey)), 0);
                else if (object.packKey.length)
                    message.packKey = object.packKey;
            if (object.position != null)
                message.position = object.position >>> 0;
            if (object.deletedAtTimestamp != null)
                if ($util.Long)
                    (message.deletedAtTimestamp = $util.Long.fromValue(object.deletedAtTimestamp)).unsigned = true;
                else if (typeof object.deletedAtTimestamp === "string")
                    message.deletedAtTimestamp = parseInt(object.deletedAtTimestamp, 10);
                else if (typeof object.deletedAtTimestamp === "number")
                    message.deletedAtTimestamp = object.deletedAtTimestamp;
                else if (typeof object.deletedAtTimestamp === "object")
                    message.deletedAtTimestamp = new $util.LongBits(object.deletedAtTimestamp.low >>> 0, object.deletedAtTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a StickerPackRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StickerPackRecord
         * @static
         * @param {signalservice.StickerPackRecord} message StickerPackRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StickerPackRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.packId = "";
                else {
                    object.packId = [];
                    if (options.bytes !== Array)
                        object.packId = $util.newBuffer(object.packId);
                }
                if (options.bytes === String)
                    object.packKey = "";
                else {
                    object.packKey = [];
                    if (options.bytes !== Array)
                        object.packKey = $util.newBuffer(object.packKey);
                }
                object.position = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.deletedAtTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deletedAtTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.packId != null && message.hasOwnProperty("packId"))
                object.packId = options.bytes === String ? $util.base64.encode(message.packId, 0, message.packId.length) : options.bytes === Array ? Array.prototype.slice.call(message.packId) : message.packId;
            if (message.packKey != null && message.hasOwnProperty("packKey"))
                object.packKey = options.bytes === String ? $util.base64.encode(message.packKey, 0, message.packKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.packKey) : message.packKey;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.deletedAtTimestamp != null && message.hasOwnProperty("deletedAtTimestamp"))
                if (typeof message.deletedAtTimestamp === "number")
                    object.deletedAtTimestamp = options.longs === String ? String(message.deletedAtTimestamp) : message.deletedAtTimestamp;
                else
                    object.deletedAtTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.deletedAtTimestamp) : options.longs === Number ? new $util.LongBits(message.deletedAtTimestamp.low >>> 0, message.deletedAtTimestamp.high >>> 0).toNumber(true) : message.deletedAtTimestamp;
            return object;
        };

        /**
         * Converts this StickerPackRecord to JSON.
         * @function toJSON
         * @memberof signalservice.StickerPackRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StickerPackRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StickerPackRecord;
    })();

    signalservice.StickerPack = (function() {

        /**
         * Properties of a StickerPack.
         * @memberof signalservice
         * @interface IStickerPack
         * @property {string|null} [title] StickerPack title
         * @property {string|null} [author] StickerPack author
         * @property {signalservice.StickerPack.ISticker|null} [cover] StickerPack cover
         * @property {Array.<signalservice.StickerPack.ISticker>|null} [stickers] StickerPack stickers
         */

        /**
         * Constructs a new StickerPack.
         * @memberof signalservice
         * @classdesc Represents a StickerPack.
         * @implements IStickerPack
         * @constructor
         * @param {signalservice.IStickerPack=} [properties] Properties to set
         */
        function StickerPack(properties) {
            this.stickers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StickerPack title.
         * @member {string} title
         * @memberof signalservice.StickerPack
         * @instance
         */
        StickerPack.prototype.title = "";

        /**
         * StickerPack author.
         * @member {string} author
         * @memberof signalservice.StickerPack
         * @instance
         */
        StickerPack.prototype.author = "";

        /**
         * StickerPack cover.
         * @member {signalservice.StickerPack.ISticker|null|undefined} cover
         * @memberof signalservice.StickerPack
         * @instance
         */
        StickerPack.prototype.cover = null;

        /**
         * StickerPack stickers.
         * @member {Array.<signalservice.StickerPack.ISticker>} stickers
         * @memberof signalservice.StickerPack
         * @instance
         */
        StickerPack.prototype.stickers = $util.emptyArray;

        /**
         * Encodes the specified StickerPack message. Does not implicitly {@link signalservice.StickerPack.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StickerPack
         * @static
         * @param {signalservice.IStickerPack} message StickerPack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerPack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.StickerPack.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.author);
            if (message.cover != null && Object.hasOwnProperty.call(message, "cover"))
                $root.signalservice.StickerPack.Sticker.encode(message.cover, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stickers != null && message.stickers.length)
                for (var i = 0; i < message.stickers.length; ++i)
                    $root.signalservice.StickerPack.Sticker.encode(message.stickers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified StickerPack message, length delimited. Does not implicitly {@link signalservice.StickerPack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StickerPack
         * @static
         * @param {signalservice.IStickerPack} message StickerPack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerPack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StickerPack message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StickerPack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StickerPack} StickerPack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerPack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StickerPack();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.author = reader.string();
                    break;
                case 3:
                    message.cover = $root.signalservice.StickerPack.Sticker.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.stickers && message.stickers.length))
                        message.stickers = [];
                    message.stickers.push($root.signalservice.StickerPack.Sticker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StickerPack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StickerPack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StickerPack} StickerPack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerPack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a StickerPack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StickerPack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StickerPack} StickerPack
         */
        StickerPack.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StickerPack)
                return object;
            var message = new $root.signalservice.StickerPack();
            if (object.title != null)
                message.title = String(object.title);
            if (object.author != null)
                message.author = String(object.author);
            if (object.cover != null) {
                if (typeof object.cover !== "object")
                    throw TypeError(".signalservice.StickerPack.cover: object expected");
                message.cover = $root.signalservice.StickerPack.Sticker.fromObject(object.cover);
            }
            if (object.stickers) {
                if (!Array.isArray(object.stickers))
                    throw TypeError(".signalservice.StickerPack.stickers: array expected");
                message.stickers = [];
                for (var i = 0; i < object.stickers.length; ++i) {
                    if (typeof object.stickers[i] !== "object")
                        throw TypeError(".signalservice.StickerPack.stickers: object expected");
                    message.stickers[i] = $root.signalservice.StickerPack.Sticker.fromObject(object.stickers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StickerPack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StickerPack
         * @static
         * @param {signalservice.StickerPack} message StickerPack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StickerPack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.stickers = [];
            if (options.defaults) {
                object.title = "";
                object.author = "";
                object.cover = null;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = message.author;
            if (message.cover != null && message.hasOwnProperty("cover"))
                object.cover = $root.signalservice.StickerPack.Sticker.toObject(message.cover, options);
            if (message.stickers && message.stickers.length) {
                object.stickers = [];
                for (var j = 0; j < message.stickers.length; ++j)
                    object.stickers[j] = $root.signalservice.StickerPack.Sticker.toObject(message.stickers[j], options);
            }
            return object;
        };

        /**
         * Converts this StickerPack to JSON.
         * @function toJSON
         * @memberof signalservice.StickerPack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StickerPack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        StickerPack.Sticker = (function() {

            /**
             * Properties of a Sticker.
             * @memberof signalservice.StickerPack
             * @interface ISticker
             * @property {number|null} [id] Sticker id
             * @property {string|null} [emoji] Sticker emoji
             */

            /**
             * Constructs a new Sticker.
             * @memberof signalservice.StickerPack
             * @classdesc Represents a Sticker.
             * @implements ISticker
             * @constructor
             * @param {signalservice.StickerPack.ISticker=} [properties] Properties to set
             */
            function Sticker(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sticker id.
             * @member {number} id
             * @memberof signalservice.StickerPack.Sticker
             * @instance
             */
            Sticker.prototype.id = 0;

            /**
             * Sticker emoji.
             * @member {string} emoji
             * @memberof signalservice.StickerPack.Sticker
             * @instance
             */
            Sticker.prototype.emoji = "";

            /**
             * Encodes the specified Sticker message. Does not implicitly {@link signalservice.StickerPack.Sticker.verify|verify} messages.
             * @function encode
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {signalservice.StickerPack.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.StickerPack.Sticker.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.emoji);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Sticker message, length delimited. Does not implicitly {@link signalservice.StickerPack.Sticker.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {signalservice.StickerPack.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.StickerPack.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StickerPack.Sticker();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.emoji = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.StickerPack.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Sticker message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.StickerPack.Sticker} Sticker
             */
            Sticker.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.StickerPack.Sticker)
                    return object;
                var message = new $root.signalservice.StickerPack.Sticker();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.emoji != null)
                    message.emoji = String(object.emoji);
                return message;
            };

            /**
             * Creates a plain object from a Sticker message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.StickerPack.Sticker
             * @static
             * @param {signalservice.StickerPack.Sticker} message Sticker
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sticker.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.emoji = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    object.emoji = message.emoji;
                return object;
            };

            /**
             * Converts this Sticker to JSON.
             * @function toJSON
             * @memberof signalservice.StickerPack.Sticker
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sticker.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sticker;
        })();

        return StickerPack;
    })();

    signalservice.WebSocketRequestMessage = (function() {

        /**
         * Properties of a WebSocketRequestMessage.
         * @memberof signalservice
         * @interface IWebSocketRequestMessage
         * @property {string|null} [verb] WebSocketRequestMessage verb
         * @property {string|null} [path] WebSocketRequestMessage path
         * @property {Uint8Array|null} [body] WebSocketRequestMessage body
         * @property {Array.<string>|null} [headers] WebSocketRequestMessage headers
         * @property {Long|null} [id] WebSocketRequestMessage id
         */

        /**
         * Constructs a new WebSocketRequestMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketRequestMessage.
         * @implements IWebSocketRequestMessage
         * @constructor
         * @param {signalservice.IWebSocketRequestMessage=} [properties] Properties to set
         */
        function WebSocketRequestMessage(properties) {
            this.headers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketRequestMessage verb.
         * @member {string} verb
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.verb = "";

        /**
         * WebSocketRequestMessage path.
         * @member {string} path
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.path = "";

        /**
         * WebSocketRequestMessage body.
         * @member {Uint8Array} body
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.body = $util.newBuffer([]);

        /**
         * WebSocketRequestMessage headers.
         * @member {Array.<string>} headers
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.headers = $util.emptyArray;

        /**
         * WebSocketRequestMessage id.
         * @member {Long} id
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified WebSocketRequestMessage message. Does not implicitly {@link signalservice.WebSocketRequestMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.IWebSocketRequestMessage} message WebSocketRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketRequestMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.WebSocketRequestMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.verb != null && Object.hasOwnProperty.call(message, "verb"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.verb);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.body);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.id);
            if (message.headers != null && message.headers.length)
                for (var i = 0; i < message.headers.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.headers[i]);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified WebSocketRequestMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketRequestMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.IWebSocketRequestMessage} message WebSocketRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketRequestMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketRequestMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketRequestMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.verb = reader.string();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                case 5:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push(reader.string());
                    break;
                case 4:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketRequestMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketRequestMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a WebSocketRequestMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         */
        WebSocketRequestMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketRequestMessage)
                return object;
            var message = new $root.signalservice.WebSocketRequestMessage();
            if (object.verb != null)
                message.verb = String(object.verb);
            if (object.path != null)
                message.path = String(object.path);
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            if (object.headers) {
                if (!Array.isArray(object.headers))
                    throw TypeError(".signalservice.WebSocketRequestMessage.headers: array expected");
                message.headers = [];
                for (var i = 0; i < object.headers.length; ++i)
                    message.headers[i] = String(object.headers[i]);
            }
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a WebSocketRequestMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.WebSocketRequestMessage} message WebSocketRequestMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketRequestMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.headers = [];
            if (options.defaults) {
                object.verb = "";
                object.path = "";
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            }
            if (message.verb != null && message.hasOwnProperty("verb"))
                object.verb = message.verb;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.headers && message.headers.length) {
                object.headers = [];
                for (var j = 0; j < message.headers.length; ++j)
                    object.headers[j] = message.headers[j];
            }
            return object;
        };

        /**
         * Converts this WebSocketRequestMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketRequestMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebSocketRequestMessage;
    })();

    signalservice.WebSocketResponseMessage = (function() {

        /**
         * Properties of a WebSocketResponseMessage.
         * @memberof signalservice
         * @interface IWebSocketResponseMessage
         * @property {Long|null} [id] WebSocketResponseMessage id
         * @property {number|null} [status] WebSocketResponseMessage status
         * @property {string|null} [message] WebSocketResponseMessage message
         * @property {Array.<string>|null} [headers] WebSocketResponseMessage headers
         * @property {Uint8Array|null} [body] WebSocketResponseMessage body
         */

        /**
         * Constructs a new WebSocketResponseMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketResponseMessage.
         * @implements IWebSocketResponseMessage
         * @constructor
         * @param {signalservice.IWebSocketResponseMessage=} [properties] Properties to set
         */
        function WebSocketResponseMessage(properties) {
            this.headers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketResponseMessage id.
         * @member {Long} id
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebSocketResponseMessage status.
         * @member {number} status
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.status = 0;

        /**
         * WebSocketResponseMessage message.
         * @member {string} message
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.message = "";

        /**
         * WebSocketResponseMessage headers.
         * @member {Array.<string>} headers
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.headers = $util.emptyArray;

        /**
         * WebSocketResponseMessage body.
         * @member {Uint8Array} body
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.body = $util.newBuffer([]);

        /**
         * Encodes the specified WebSocketResponseMessage message. Does not implicitly {@link signalservice.WebSocketResponseMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.IWebSocketResponseMessage} message WebSocketResponseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketResponseMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.WebSocketResponseMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.status);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.body);
            if (message.headers != null && message.headers.length)
                for (var i = 0; i < message.headers.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.headers[i]);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified WebSocketResponseMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketResponseMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.IWebSocketResponseMessage} message WebSocketResponseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketResponseMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketResponseMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketResponseMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.status = reader.uint32();
                    break;
                case 3:
                    message.message = reader.string();
                    break;
                case 5:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push(reader.string());
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketResponseMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketResponseMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a WebSocketResponseMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         */
        WebSocketResponseMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketResponseMessage)
                return object;
            var message = new $root.signalservice.WebSocketResponseMessage();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.status != null)
                message.status = object.status >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            if (object.headers) {
                if (!Array.isArray(object.headers))
                    throw TypeError(".signalservice.WebSocketResponseMessage.headers: array expected");
                message.headers = [];
                for (var i = 0; i < object.headers.length; ++i)
                    message.headers[i] = String(object.headers[i]);
            }
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a WebSocketResponseMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.WebSocketResponseMessage} message WebSocketResponseMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketResponseMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.headers = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.status = 0;
                object.message = "";
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            if (message.headers && message.headers.length) {
                object.headers = [];
                for (var j = 0; j < message.headers.length; ++j)
                    object.headers[j] = message.headers[j];
            }
            return object;
        };

        /**
         * Converts this WebSocketResponseMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketResponseMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebSocketResponseMessage;
    })();

    signalservice.WebSocketMessage = (function() {

        /**
         * Properties of a WebSocketMessage.
         * @memberof signalservice
         * @interface IWebSocketMessage
         * @property {signalservice.WebSocketMessage.Type|null} [type] WebSocketMessage type
         * @property {signalservice.IWebSocketRequestMessage|null} [request] WebSocketMessage request
         * @property {signalservice.IWebSocketResponseMessage|null} [response] WebSocketMessage response
         */

        /**
         * Constructs a new WebSocketMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketMessage.
         * @implements IWebSocketMessage
         * @constructor
         * @param {signalservice.IWebSocketMessage=} [properties] Properties to set
         */
        function WebSocketMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketMessage type.
         * @member {signalservice.WebSocketMessage.Type} type
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.type = 0;

        /**
         * WebSocketMessage request.
         * @member {signalservice.IWebSocketRequestMessage|null|undefined} request
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.request = null;

        /**
         * WebSocketMessage response.
         * @member {signalservice.IWebSocketResponseMessage|null|undefined} response
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.response = null;

        /**
         * Encodes the specified WebSocketMessage message. Does not implicitly {@link signalservice.WebSocketMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.IWebSocketMessage} message WebSocketMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.WebSocketMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                $root.signalservice.WebSocketRequestMessage.encode(message.request, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                $root.signalservice.WebSocketResponseMessage.encode(message.response, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified WebSocketMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.IWebSocketMessage} message WebSocketMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.request = $root.signalservice.WebSocketRequestMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = $root.signalservice.WebSocketResponseMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a WebSocketMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         */
        WebSocketMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketMessage)
                return object;
            var message = new $root.signalservice.WebSocketMessage();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "REQUEST":
            case 1:
                message.type = 1;
                break;
            case "RESPONSE":
            case 2:
                message.type = 2;
                break;
            }
            if (object.request != null) {
                if (typeof object.request !== "object")
                    throw TypeError(".signalservice.WebSocketMessage.request: object expected");
                message.request = $root.signalservice.WebSocketRequestMessage.fromObject(object.request);
            }
            if (object.response != null) {
                if (typeof object.response !== "object")
                    throw TypeError(".signalservice.WebSocketMessage.response: object expected");
                message.response = $root.signalservice.WebSocketResponseMessage.fromObject(object.response);
            }
            return message;
        };

        /**
         * Creates a plain object from a WebSocketMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.WebSocketMessage} message WebSocketMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.request = null;
                object.response = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.WebSocketMessage.Type[message.type] : message.type;
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = $root.signalservice.WebSocketRequestMessage.toObject(message.request, options);
            if (message.response != null && message.hasOwnProperty("response"))
                object.response = $root.signalservice.WebSocketResponseMessage.toObject(message.response, options);
            return object;
        };

        /**
         * Converts this WebSocketMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name signalservice.WebSocketMessage.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REQUEST=1 REQUEST value
         * @property {number} RESPONSE=2 RESPONSE value
         */
        WebSocketMessage.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REQUEST"] = 1;
            values[valuesById[2] = "RESPONSE"] = 2;
            return values;
        })();

        return WebSocketMessage;
    })();

    signalservice.ServerCertificate = (function() {

        /**
         * Properties of a ServerCertificate.
         * @memberof signalservice
         * @interface IServerCertificate
         * @property {Uint8Array|null} [certificate] ServerCertificate certificate
         * @property {Uint8Array|null} [signature] ServerCertificate signature
         */

        /**
         * Constructs a new ServerCertificate.
         * @memberof signalservice
         * @classdesc Represents a ServerCertificate.
         * @implements IServerCertificate
         * @constructor
         * @param {signalservice.IServerCertificate=} [properties] Properties to set
         */
        function ServerCertificate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerCertificate certificate.
         * @member {Uint8Array} certificate
         * @memberof signalservice.ServerCertificate
         * @instance
         */
        ServerCertificate.prototype.certificate = $util.newBuffer([]);

        /**
         * ServerCertificate signature.
         * @member {Uint8Array} signature
         * @memberof signalservice.ServerCertificate
         * @instance
         */
        ServerCertificate.prototype.signature = $util.newBuffer([]);

        /**
         * Encodes the specified ServerCertificate message. Does not implicitly {@link signalservice.ServerCertificate.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {signalservice.IServerCertificate} message ServerCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerCertificate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.ServerCertificate.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified ServerCertificate message, length delimited. Does not implicitly {@link signalservice.ServerCertificate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {signalservice.IServerCertificate} message ServerCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerCertificate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerCertificate message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ServerCertificate} ServerCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerCertificate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ServerCertificate();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerCertificate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ServerCertificate} ServerCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerCertificate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a ServerCertificate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ServerCertificate} ServerCertificate
         */
        ServerCertificate.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ServerCertificate)
                return object;
            var message = new $root.signalservice.ServerCertificate();
            if (object.certificate != null)
                if (typeof object.certificate === "string")
                    $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                else if (object.certificate.length)
                    message.certificate = object.certificate;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a ServerCertificate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ServerCertificate
         * @static
         * @param {signalservice.ServerCertificate} message ServerCertificate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerCertificate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.certificate = "";
                else {
                    object.certificate = [];
                    if (options.bytes !== Array)
                        object.certificate = $util.newBuffer(object.certificate);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this ServerCertificate to JSON.
         * @function toJSON
         * @memberof signalservice.ServerCertificate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerCertificate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ServerCertificate.Certificate = (function() {

            /**
             * Properties of a Certificate.
             * @memberof signalservice.ServerCertificate
             * @interface ICertificate
             * @property {number|null} [id] Certificate id
             * @property {Uint8Array|null} [key] Certificate key
             */

            /**
             * Constructs a new Certificate.
             * @memberof signalservice.ServerCertificate
             * @classdesc Represents a Certificate.
             * @implements ICertificate
             * @constructor
             * @param {signalservice.ServerCertificate.ICertificate=} [properties] Properties to set
             */
            function Certificate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Certificate id.
             * @member {number} id
             * @memberof signalservice.ServerCertificate.Certificate
             * @instance
             */
            Certificate.prototype.id = 0;

            /**
             * Certificate key.
             * @member {Uint8Array} key
             * @memberof signalservice.ServerCertificate.Certificate
             * @instance
             */
            Certificate.prototype.key = $util.newBuffer([]);

            /**
             * Encodes the specified Certificate message. Does not implicitly {@link signalservice.ServerCertificate.Certificate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {signalservice.ServerCertificate.ICertificate} message Certificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Certificate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.ServerCertificate.Certificate.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Certificate message, length delimited. Does not implicitly {@link signalservice.ServerCertificate.Certificate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {signalservice.ServerCertificate.ICertificate} message Certificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Certificate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Certificate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.ServerCertificate.Certificate} Certificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Certificate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ServerCertificate.Certificate();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Certificate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.ServerCertificate.Certificate} Certificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Certificate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Certificate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.ServerCertificate.Certificate} Certificate
             */
            Certificate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.ServerCertificate.Certificate)
                    return object;
                var message = new $root.signalservice.ServerCertificate.Certificate();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                return message;
            };

            /**
             * Creates a plain object from a Certificate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.ServerCertificate.Certificate
             * @static
             * @param {signalservice.ServerCertificate.Certificate} message Certificate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Certificate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };

            /**
             * Converts this Certificate to JSON.
             * @function toJSON
             * @memberof signalservice.ServerCertificate.Certificate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Certificate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Certificate;
        })();

        return ServerCertificate;
    })();

    signalservice.SenderCertificate = (function() {

        /**
         * Properties of a SenderCertificate.
         * @memberof signalservice
         * @interface ISenderCertificate
         * @property {Uint8Array|null} [certificate] SenderCertificate certificate
         * @property {Uint8Array|null} [signature] SenderCertificate signature
         */

        /**
         * Constructs a new SenderCertificate.
         * @memberof signalservice
         * @classdesc Represents a SenderCertificate.
         * @implements ISenderCertificate
         * @constructor
         * @param {signalservice.ISenderCertificate=} [properties] Properties to set
         */
        function SenderCertificate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderCertificate certificate.
         * @member {Uint8Array} certificate
         * @memberof signalservice.SenderCertificate
         * @instance
         */
        SenderCertificate.prototype.certificate = $util.newBuffer([]);

        /**
         * SenderCertificate signature.
         * @member {Uint8Array} signature
         * @memberof signalservice.SenderCertificate
         * @instance
         */
        SenderCertificate.prototype.signature = $util.newBuffer([]);

        /**
         * Encodes the specified SenderCertificate message. Does not implicitly {@link signalservice.SenderCertificate.verify|verify} messages.
         * @function encode
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {signalservice.ISenderCertificate} message SenderCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderCertificate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.SenderCertificate.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified SenderCertificate message, length delimited. Does not implicitly {@link signalservice.SenderCertificate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {signalservice.ISenderCertificate} message SenderCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderCertificate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderCertificate message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.SenderCertificate} SenderCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderCertificate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SenderCertificate();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderCertificate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.SenderCertificate} SenderCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderCertificate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates a SenderCertificate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.SenderCertificate} SenderCertificate
         */
        SenderCertificate.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.SenderCertificate)
                return object;
            var message = new $root.signalservice.SenderCertificate();
            if (object.certificate != null)
                if (typeof object.certificate === "string")
                    $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                else if (object.certificate.length)
                    message.certificate = object.certificate;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a SenderCertificate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.SenderCertificate
         * @static
         * @param {signalservice.SenderCertificate} message SenderCertificate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderCertificate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.certificate = "";
                else {
                    object.certificate = [];
                    if (options.bytes !== Array)
                        object.certificate = $util.newBuffer(object.certificate);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this SenderCertificate to JSON.
         * @function toJSON
         * @memberof signalservice.SenderCertificate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderCertificate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SenderCertificate.Certificate = (function() {

            /**
             * Properties of a Certificate.
             * @memberof signalservice.SenderCertificate
             * @interface ICertificate
             * @property {string|null} [senderE164] Certificate senderE164
             * @property {string|null} [senderUuid] Certificate senderUuid
             * @property {number|null} [senderDevice] Certificate senderDevice
             * @property {Long|null} [expires] Certificate expires
             * @property {Uint8Array|null} [identityKey] Certificate identityKey
             * @property {signalservice.IServerCertificate|null} [signer] Certificate signer
             */

            /**
             * Constructs a new Certificate.
             * @memberof signalservice.SenderCertificate
             * @classdesc Represents a Certificate.
             * @implements ICertificate
             * @constructor
             * @param {signalservice.SenderCertificate.ICertificate=} [properties] Properties to set
             */
            function Certificate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Certificate senderE164.
             * @member {string} senderE164
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.senderE164 = "";

            /**
             * Certificate senderUuid.
             * @member {string} senderUuid
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.senderUuid = "";

            /**
             * Certificate senderDevice.
             * @member {number} senderDevice
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.senderDevice = 0;

            /**
             * Certificate expires.
             * @member {Long} expires
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.expires = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Certificate identityKey.
             * @member {Uint8Array} identityKey
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.identityKey = $util.newBuffer([]);

            /**
             * Certificate signer.
             * @member {signalservice.IServerCertificate|null|undefined} signer
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             */
            Certificate.prototype.signer = null;

            /**
             * Encodes the specified Certificate message. Does not implicitly {@link signalservice.SenderCertificate.Certificate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {signalservice.SenderCertificate.ICertificate} message Certificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Certificate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.SenderCertificate.Certificate.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.senderE164 != null && Object.hasOwnProperty.call(message, "senderE164"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderE164);
                if (message.senderDevice != null && Object.hasOwnProperty.call(message, "senderDevice"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.senderDevice);
                if (message.expires != null && Object.hasOwnProperty.call(message, "expires"))
                    writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.expires);
                if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identityKey);
                if (message.signer != null && Object.hasOwnProperty.call(message, "signer"))
                    $root.signalservice.ServerCertificate.encode(message.signer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.senderUuid != null && Object.hasOwnProperty.call(message, "senderUuid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderUuid);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Certificate message, length delimited. Does not implicitly {@link signalservice.SenderCertificate.Certificate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {signalservice.SenderCertificate.ICertificate} message Certificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Certificate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Certificate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SenderCertificate.Certificate} Certificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Certificate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SenderCertificate.Certificate();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.senderE164 = reader.string();
                        break;
                    case 6:
                        message.senderUuid = reader.string();
                        break;
                    case 2:
                        message.senderDevice = reader.uint32();
                        break;
                    case 3:
                        message.expires = reader.fixed64();
                        break;
                    case 4:
                        message.identityKey = reader.bytes();
                        break;
                    case 5:
                        message.signer = $root.signalservice.ServerCertificate.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Certificate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SenderCertificate.Certificate} Certificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Certificate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Certificate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SenderCertificate.Certificate} Certificate
             */
            Certificate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SenderCertificate.Certificate)
                    return object;
                var message = new $root.signalservice.SenderCertificate.Certificate();
                if (object.senderE164 != null)
                    message.senderE164 = String(object.senderE164);
                if (object.senderUuid != null)
                    message.senderUuid = String(object.senderUuid);
                if (object.senderDevice != null)
                    message.senderDevice = object.senderDevice >>> 0;
                if (object.expires != null)
                    if ($util.Long)
                        (message.expires = $util.Long.fromValue(object.expires)).unsigned = false;
                    else if (typeof object.expires === "string")
                        message.expires = parseInt(object.expires, 10);
                    else if (typeof object.expires === "number")
                        message.expires = object.expires;
                    else if (typeof object.expires === "object")
                        message.expires = new $util.LongBits(object.expires.low >>> 0, object.expires.high >>> 0).toNumber();
                if (object.identityKey != null)
                    if (typeof object.identityKey === "string")
                        $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                    else if (object.identityKey.length)
                        message.identityKey = object.identityKey;
                if (object.signer != null) {
                    if (typeof object.signer !== "object")
                        throw TypeError(".signalservice.SenderCertificate.Certificate.signer: object expected");
                    message.signer = $root.signalservice.ServerCertificate.fromObject(object.signer);
                }
                return message;
            };

            /**
             * Creates a plain object from a Certificate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SenderCertificate.Certificate
             * @static
             * @param {signalservice.SenderCertificate.Certificate} message Certificate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Certificate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.senderE164 = "";
                    object.senderDevice = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expires = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expires = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.identityKey = "";
                    else {
                        object.identityKey = [];
                        if (options.bytes !== Array)
                            object.identityKey = $util.newBuffer(object.identityKey);
                    }
                    object.signer = null;
                    object.senderUuid = "";
                }
                if (message.senderE164 != null && message.hasOwnProperty("senderE164"))
                    object.senderE164 = message.senderE164;
                if (message.senderDevice != null && message.hasOwnProperty("senderDevice"))
                    object.senderDevice = message.senderDevice;
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (typeof message.expires === "number")
                        object.expires = options.longs === String ? String(message.expires) : message.expires;
                    else
                        object.expires = options.longs === String ? $util.Long.prototype.toString.call(message.expires) : options.longs === Number ? new $util.LongBits(message.expires.low >>> 0, message.expires.high >>> 0).toNumber() : message.expires;
                if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                    object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
                if (message.signer != null && message.hasOwnProperty("signer"))
                    object.signer = $root.signalservice.ServerCertificate.toObject(message.signer, options);
                if (message.senderUuid != null && message.hasOwnProperty("senderUuid"))
                    object.senderUuid = message.senderUuid;
                return object;
            };

            /**
             * Converts this Certificate to JSON.
             * @function toJSON
             * @memberof signalservice.SenderCertificate.Certificate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Certificate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Certificate;
        })();

        return SenderCertificate;
    })();

    signalservice.UnidentifiedSenderMessage = (function() {

        /**
         * Properties of an UnidentifiedSenderMessage.
         * @memberof signalservice
         * @interface IUnidentifiedSenderMessage
         * @property {Uint8Array|null} [ephemeralPublic] UnidentifiedSenderMessage ephemeralPublic
         * @property {Uint8Array|null} [encryptedStatic] UnidentifiedSenderMessage encryptedStatic
         * @property {Uint8Array|null} [encryptedMessage] UnidentifiedSenderMessage encryptedMessage
         */

        /**
         * Constructs a new UnidentifiedSenderMessage.
         * @memberof signalservice
         * @classdesc Represents an UnidentifiedSenderMessage.
         * @implements IUnidentifiedSenderMessage
         * @constructor
         * @param {signalservice.IUnidentifiedSenderMessage=} [properties] Properties to set
         */
        function UnidentifiedSenderMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnidentifiedSenderMessage ephemeralPublic.
         * @member {Uint8Array} ephemeralPublic
         * @memberof signalservice.UnidentifiedSenderMessage
         * @instance
         */
        UnidentifiedSenderMessage.prototype.ephemeralPublic = $util.newBuffer([]);

        /**
         * UnidentifiedSenderMessage encryptedStatic.
         * @member {Uint8Array} encryptedStatic
         * @memberof signalservice.UnidentifiedSenderMessage
         * @instance
         */
        UnidentifiedSenderMessage.prototype.encryptedStatic = $util.newBuffer([]);

        /**
         * UnidentifiedSenderMessage encryptedMessage.
         * @member {Uint8Array} encryptedMessage
         * @memberof signalservice.UnidentifiedSenderMessage
         * @instance
         */
        UnidentifiedSenderMessage.prototype.encryptedMessage = $util.newBuffer([]);

        /**
         * Encodes the specified UnidentifiedSenderMessage message. Does not implicitly {@link signalservice.UnidentifiedSenderMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {signalservice.IUnidentifiedSenderMessage} message UnidentifiedSenderMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnidentifiedSenderMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            var fullyUnknown = [];
            if (message.__unknownFields)
                for (var i = 0; i < message.__unknownFields.length; ++i)
                    try {
                        var known = $root.signalservice.UnidentifiedSenderMessage.decode(message.__unknownFields[i]);
                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                        message = Object.assign(known, message);
                    } catch (_) {
                    }
            if (message.ephemeralPublic != null && Object.hasOwnProperty.call(message, "ephemeralPublic"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeralPublic);
            if (message.encryptedStatic != null && Object.hasOwnProperty.call(message, "encryptedStatic"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedStatic);
            if (message.encryptedMessage != null && Object.hasOwnProperty.call(message, "encryptedMessage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedMessage);
            for (var i = 0; i < fullyUnknown.length; ++i)
                writer.__unknownField(fullyUnknown[i]);
            return writer;
        };

        /**
         * Encodes the specified UnidentifiedSenderMessage message, length delimited. Does not implicitly {@link signalservice.UnidentifiedSenderMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {signalservice.IUnidentifiedSenderMessage} message UnidentifiedSenderMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnidentifiedSenderMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnidentifiedSenderMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.UnidentifiedSenderMessage} UnidentifiedSenderMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnidentifiedSenderMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.UnidentifiedSenderMessage();
            while (reader.pos < end) {
                var unknownStartPos = reader.pos;
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ephemeralPublic = reader.bytes();
                    break;
                case 2:
                    message.encryptedStatic = reader.bytes();
                    break;
                case 3:
                    message.encryptedMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    if (!message.__unknownFields)
                        message.__unknownFields = [];
                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnidentifiedSenderMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.UnidentifiedSenderMessage} UnidentifiedSenderMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnidentifiedSenderMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Creates an UnidentifiedSenderMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.UnidentifiedSenderMessage} UnidentifiedSenderMessage
         */
        UnidentifiedSenderMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.UnidentifiedSenderMessage)
                return object;
            var message = new $root.signalservice.UnidentifiedSenderMessage();
            if (object.ephemeralPublic != null)
                if (typeof object.ephemeralPublic === "string")
                    $util.base64.decode(object.ephemeralPublic, message.ephemeralPublic = $util.newBuffer($util.base64.length(object.ephemeralPublic)), 0);
                else if (object.ephemeralPublic.length)
                    message.ephemeralPublic = object.ephemeralPublic;
            if (object.encryptedStatic != null)
                if (typeof object.encryptedStatic === "string")
                    $util.base64.decode(object.encryptedStatic, message.encryptedStatic = $util.newBuffer($util.base64.length(object.encryptedStatic)), 0);
                else if (object.encryptedStatic.length)
                    message.encryptedStatic = object.encryptedStatic;
            if (object.encryptedMessage != null)
                if (typeof object.encryptedMessage === "string")
                    $util.base64.decode(object.encryptedMessage, message.encryptedMessage = $util.newBuffer($util.base64.length(object.encryptedMessage)), 0);
                else if (object.encryptedMessage.length)
                    message.encryptedMessage = object.encryptedMessage;
            return message;
        };

        /**
         * Creates a plain object from an UnidentifiedSenderMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.UnidentifiedSenderMessage
         * @static
         * @param {signalservice.UnidentifiedSenderMessage} message UnidentifiedSenderMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnidentifiedSenderMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeralPublic = "";
                else {
                    object.ephemeralPublic = [];
                    if (options.bytes !== Array)
                        object.ephemeralPublic = $util.newBuffer(object.ephemeralPublic);
                }
                if (options.bytes === String)
                    object.encryptedStatic = "";
                else {
                    object.encryptedStatic = [];
                    if (options.bytes !== Array)
                        object.encryptedStatic = $util.newBuffer(object.encryptedStatic);
                }
                if (options.bytes === String)
                    object.encryptedMessage = "";
                else {
                    object.encryptedMessage = [];
                    if (options.bytes !== Array)
                        object.encryptedMessage = $util.newBuffer(object.encryptedMessage);
                }
            }
            if (message.ephemeralPublic != null && message.hasOwnProperty("ephemeralPublic"))
                object.ephemeralPublic = options.bytes === String ? $util.base64.encode(message.ephemeralPublic, 0, message.ephemeralPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralPublic) : message.ephemeralPublic;
            if (message.encryptedStatic != null && message.hasOwnProperty("encryptedStatic"))
                object.encryptedStatic = options.bytes === String ? $util.base64.encode(message.encryptedStatic, 0, message.encryptedStatic.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedStatic) : message.encryptedStatic;
            if (message.encryptedMessage != null && message.hasOwnProperty("encryptedMessage"))
                object.encryptedMessage = options.bytes === String ? $util.base64.encode(message.encryptedMessage, 0, message.encryptedMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedMessage) : message.encryptedMessage;
            return object;
        };

        /**
         * Converts this UnidentifiedSenderMessage to JSON.
         * @function toJSON
         * @memberof signalservice.UnidentifiedSenderMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnidentifiedSenderMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        UnidentifiedSenderMessage.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof signalservice.UnidentifiedSenderMessage
             * @interface IMessage
             * @property {signalservice.UnidentifiedSenderMessage.Message.Type|null} [type] Message type
             * @property {signalservice.ISenderCertificate|null} [senderCertificate] Message senderCertificate
             * @property {Uint8Array|null} [content] Message content
             * @property {signalservice.UnidentifiedSenderMessage.Message.ContentHint|null} [contentHint] Message contentHint
             * @property {Uint8Array|null} [groupId] Message groupId
             */

            /**
             * Constructs a new Message.
             * @memberof signalservice.UnidentifiedSenderMessage
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {signalservice.UnidentifiedSenderMessage.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Message type.
             * @member {signalservice.UnidentifiedSenderMessage.Message.Type} type
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             */
            Message.prototype.type = 1;

            /**
             * Message senderCertificate.
             * @member {signalservice.ISenderCertificate|null|undefined} senderCertificate
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             */
            Message.prototype.senderCertificate = null;

            /**
             * Message content.
             * @member {Uint8Array} content
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             */
            Message.prototype.content = $util.newBuffer([]);

            /**
             * Message contentHint.
             * @member {signalservice.UnidentifiedSenderMessage.Message.ContentHint} contentHint
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             */
            Message.prototype.contentHint = 0;

            /**
             * Message groupId.
             * @member {Uint8Array} groupId
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             */
            Message.prototype.groupId = $util.newBuffer([]);

            /**
             * Encodes the specified Message message. Does not implicitly {@link signalservice.UnidentifiedSenderMessage.Message.verify|verify} messages.
             * @function encode
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {signalservice.UnidentifiedSenderMessage.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                var fullyUnknown = [];
                if (message.__unknownFields)
                    for (var i = 0; i < message.__unknownFields.length; ++i)
                        try {
                            var known = $root.signalservice.UnidentifiedSenderMessage.Message.decode(message.__unknownFields[i]);
                            fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                            message = Object.assign(known, message);
                        } catch (_) {
                        }
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.senderCertificate != null && Object.hasOwnProperty.call(message, "senderCertificate"))
                    $root.signalservice.SenderCertificate.encode(message.senderCertificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.content);
                if (message.contentHint != null && Object.hasOwnProperty.call(message, "contentHint"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentHint);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.groupId);
                for (var i = 0; i < fullyUnknown.length; ++i)
                    writer.__unknownField(fullyUnknown[i]);
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link signalservice.UnidentifiedSenderMessage.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {signalservice.UnidentifiedSenderMessage.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.UnidentifiedSenderMessage.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.UnidentifiedSenderMessage.Message();
                while (reader.pos < end) {
                    var unknownStartPos = reader.pos;
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.senderCertificate = $root.signalservice.SenderCertificate.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.content = reader.bytes();
                        break;
                    case 4:
                        message.contentHint = reader.int32();
                        break;
                    case 5:
                        message.groupId = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        if (!message.__unknownFields)
                            message.__unknownFields = [];
                        message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.UnidentifiedSenderMessage.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.UnidentifiedSenderMessage.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.UnidentifiedSenderMessage.Message)
                    return object;
                var message = new $root.signalservice.UnidentifiedSenderMessage.Message();
                switch (object.type) {
                case "PREKEY_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "MESSAGE":
                case 2:
                    message.type = 2;
                    break;
                case "SENDERKEY_MESSAGE":
                case 7:
                    message.type = 7;
                    break;
                case "PLAINTEXT_CONTENT":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.senderCertificate != null) {
                    if (typeof object.senderCertificate !== "object")
                        throw TypeError(".signalservice.UnidentifiedSenderMessage.Message.senderCertificate: object expected");
                    message.senderCertificate = $root.signalservice.SenderCertificate.fromObject(object.senderCertificate);
                }
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length)
                        message.content = object.content;
                switch (object.contentHint) {
                case "DEFAULT":
                case 0:
                    message.contentHint = 0;
                    break;
                case "RESENDABLE":
                case 1:
                    message.contentHint = 1;
                    break;
                case "IMPLICIT":
                case 2:
                    message.contentHint = 2;
                    break;
                }
                if (object.groupId != null)
                    if (typeof object.groupId === "string")
                        $util.base64.decode(object.groupId, message.groupId = $util.newBuffer($util.base64.length(object.groupId)), 0);
                    else if (object.groupId.length)
                        message.groupId = object.groupId;
                return message;
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @static
             * @param {signalservice.UnidentifiedSenderMessage.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "PREKEY_MESSAGE" : 1;
                    object.senderCertificate = null;
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                    object.contentHint = options.enums === String ? "DEFAULT" : 0;
                    if (options.bytes === String)
                        object.groupId = "";
                    else {
                        object.groupId = [];
                        if (options.bytes !== Array)
                            object.groupId = $util.newBuffer(object.groupId);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.UnidentifiedSenderMessage.Message.Type[message.type] : message.type;
                if (message.senderCertificate != null && message.hasOwnProperty("senderCertificate"))
                    object.senderCertificate = $root.signalservice.SenderCertificate.toObject(message.senderCertificate, options);
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (message.contentHint != null && message.hasOwnProperty("contentHint"))
                    object.contentHint = options.enums === String ? $root.signalservice.UnidentifiedSenderMessage.Message.ContentHint[message.contentHint] : message.contentHint;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = options.bytes === String ? $util.base64.encode(message.groupId, 0, message.groupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupId) : message.groupId;
                return object;
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof signalservice.UnidentifiedSenderMessage.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name signalservice.UnidentifiedSenderMessage.Message.Type
             * @enum {number}
             * @property {number} PREKEY_MESSAGE=1 PREKEY_MESSAGE value
             * @property {number} MESSAGE=2 MESSAGE value
             * @property {number} SENDERKEY_MESSAGE=7 SENDERKEY_MESSAGE value
             * @property {number} PLAINTEXT_CONTENT=8 PLAINTEXT_CONTENT value
             */
            Message.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "PREKEY_MESSAGE"] = 1;
                values[valuesById[2] = "MESSAGE"] = 2;
                values[valuesById[7] = "SENDERKEY_MESSAGE"] = 7;
                values[valuesById[8] = "PLAINTEXT_CONTENT"] = 8;
                return values;
            })();

            /**
             * ContentHint enum.
             * @name signalservice.UnidentifiedSenderMessage.Message.ContentHint
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} RESENDABLE=1 RESENDABLE value
             * @property {number} IMPLICIT=2 IMPLICIT value
             */
            Message.ContentHint = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "RESENDABLE"] = 1;
                values[valuesById[2] = "IMPLICIT"] = 2;
                return values;
            })();

            return Message;
        })();

        return UnidentifiedSenderMessage;
    })();

    return signalservice;
})();

$root.signal = (function() {

    /**
     * Namespace signal.
     * @exports signal
     * @namespace
     */
    var signal = {};

    signal.proto = (function() {

        /**
         * Namespace proto.
         * @memberof signal
         * @namespace
         */
        var proto = {};

        proto.storage = (function() {

            /**
             * Namespace storage.
             * @memberof signal.proto
             * @namespace
             */
            var storage = {};

            storage.SessionStructure = (function() {

                /**
                 * Properties of a SessionStructure.
                 * @memberof signal.proto.storage
                 * @interface ISessionStructure
                 * @property {number|null} [sessionVersion] SessionStructure sessionVersion
                 * @property {Uint8Array|null} [localIdentityPublic] SessionStructure localIdentityPublic
                 * @property {Uint8Array|null} [remoteIdentityPublic] SessionStructure remoteIdentityPublic
                 * @property {Uint8Array|null} [rootKey] SessionStructure rootKey
                 * @property {number|null} [previousCounter] SessionStructure previousCounter
                 * @property {signal.proto.storage.SessionStructure.IChain|null} [senderChain] SessionStructure senderChain
                 * @property {Array.<signal.proto.storage.SessionStructure.IChain>|null} [receiverChains] SessionStructure receiverChains
                 * @property {signal.proto.storage.SessionStructure.IPendingPreKey|null} [pendingPreKey] SessionStructure pendingPreKey
                 * @property {number|null} [remoteRegistrationId] SessionStructure remoteRegistrationId
                 * @property {number|null} [localRegistrationId] SessionStructure localRegistrationId
                 * @property {boolean|null} [needsRefresh] SessionStructure needsRefresh
                 * @property {Uint8Array|null} [aliceBaseKey] SessionStructure aliceBaseKey
                 */

                /**
                 * Constructs a new SessionStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a SessionStructure.
                 * @implements ISessionStructure
                 * @constructor
                 * @param {signal.proto.storage.ISessionStructure=} [properties] Properties to set
                 */
                function SessionStructure(properties) {
                    this.receiverChains = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionStructure sessionVersion.
                 * @member {number} sessionVersion
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.sessionVersion = 0;

                /**
                 * SessionStructure localIdentityPublic.
                 * @member {Uint8Array} localIdentityPublic
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.localIdentityPublic = $util.newBuffer([]);

                /**
                 * SessionStructure remoteIdentityPublic.
                 * @member {Uint8Array} remoteIdentityPublic
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.remoteIdentityPublic = $util.newBuffer([]);

                /**
                 * SessionStructure rootKey.
                 * @member {Uint8Array} rootKey
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.rootKey = $util.newBuffer([]);

                /**
                 * SessionStructure previousCounter.
                 * @member {number} previousCounter
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.previousCounter = 0;

                /**
                 * SessionStructure senderChain.
                 * @member {signal.proto.storage.SessionStructure.IChain|null|undefined} senderChain
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.senderChain = null;

                /**
                 * SessionStructure receiverChains.
                 * @member {Array.<signal.proto.storage.SessionStructure.IChain>} receiverChains
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.receiverChains = $util.emptyArray;

                /**
                 * SessionStructure pendingPreKey.
                 * @member {signal.proto.storage.SessionStructure.IPendingPreKey|null|undefined} pendingPreKey
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.pendingPreKey = null;

                /**
                 * SessionStructure remoteRegistrationId.
                 * @member {number} remoteRegistrationId
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.remoteRegistrationId = 0;

                /**
                 * SessionStructure localRegistrationId.
                 * @member {number} localRegistrationId
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.localRegistrationId = 0;

                /**
                 * SessionStructure needsRefresh.
                 * @member {boolean} needsRefresh
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.needsRefresh = false;

                /**
                 * SessionStructure aliceBaseKey.
                 * @member {Uint8Array} aliceBaseKey
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 */
                SessionStructure.prototype.aliceBaseKey = $util.newBuffer([]);

                /**
                 * Encodes the specified SessionStructure message. Does not implicitly {@link signal.proto.storage.SessionStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {signal.proto.storage.ISessionStructure} message SessionStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.SessionStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.sessionVersion != null && Object.hasOwnProperty.call(message, "sessionVersion"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sessionVersion);
                    if (message.localIdentityPublic != null && Object.hasOwnProperty.call(message, "localIdentityPublic"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.localIdentityPublic);
                    if (message.remoteIdentityPublic != null && Object.hasOwnProperty.call(message, "remoteIdentityPublic"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.remoteIdentityPublic);
                    if (message.rootKey != null && Object.hasOwnProperty.call(message, "rootKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rootKey);
                    if (message.previousCounter != null && Object.hasOwnProperty.call(message, "previousCounter"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.previousCounter);
                    if (message.senderChain != null && Object.hasOwnProperty.call(message, "senderChain"))
                        $root.signal.proto.storage.SessionStructure.Chain.encode(message.senderChain, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.receiverChains != null && message.receiverChains.length)
                        for (var i = 0; i < message.receiverChains.length; ++i)
                            $root.signal.proto.storage.SessionStructure.Chain.encode(message.receiverChains[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.pendingPreKey != null && Object.hasOwnProperty.call(message, "pendingPreKey"))
                        $root.signal.proto.storage.SessionStructure.PendingPreKey.encode(message.pendingPreKey, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.remoteRegistrationId != null && Object.hasOwnProperty.call(message, "remoteRegistrationId"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteRegistrationId);
                    if (message.localRegistrationId != null && Object.hasOwnProperty.call(message, "localRegistrationId"))
                        writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.localRegistrationId);
                    if (message.needsRefresh != null && Object.hasOwnProperty.call(message, "needsRefresh"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.needsRefresh);
                    if (message.aliceBaseKey != null && Object.hasOwnProperty.call(message, "aliceBaseKey"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.aliceBaseKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SessionStructure message, length delimited. Does not implicitly {@link signal.proto.storage.SessionStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {signal.proto.storage.ISessionStructure} message SessionStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.SessionStructure} SessionStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SessionStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sessionVersion = reader.uint32();
                            break;
                        case 2:
                            message.localIdentityPublic = reader.bytes();
                            break;
                        case 3:
                            message.remoteIdentityPublic = reader.bytes();
                            break;
                        case 4:
                            message.rootKey = reader.bytes();
                            break;
                        case 5:
                            message.previousCounter = reader.uint32();
                            break;
                        case 6:
                            message.senderChain = $root.signal.proto.storage.SessionStructure.Chain.decode(reader, reader.uint32());
                            break;
                        case 7:
                            if (!(message.receiverChains && message.receiverChains.length))
                                message.receiverChains = [];
                            message.receiverChains.push($root.signal.proto.storage.SessionStructure.Chain.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            message.pendingPreKey = $root.signal.proto.storage.SessionStructure.PendingPreKey.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.remoteRegistrationId = reader.uint32();
                            break;
                        case 11:
                            message.localRegistrationId = reader.uint32();
                            break;
                        case 12:
                            message.needsRefresh = reader.bool();
                            break;
                        case 13:
                            message.aliceBaseKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.SessionStructure} SessionStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a SessionStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.SessionStructure} SessionStructure
                 */
                SessionStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.SessionStructure)
                        return object;
                    var message = new $root.signal.proto.storage.SessionStructure();
                    if (object.sessionVersion != null)
                        message.sessionVersion = object.sessionVersion >>> 0;
                    if (object.localIdentityPublic != null)
                        if (typeof object.localIdentityPublic === "string")
                            $util.base64.decode(object.localIdentityPublic, message.localIdentityPublic = $util.newBuffer($util.base64.length(object.localIdentityPublic)), 0);
                        else if (object.localIdentityPublic.length)
                            message.localIdentityPublic = object.localIdentityPublic;
                    if (object.remoteIdentityPublic != null)
                        if (typeof object.remoteIdentityPublic === "string")
                            $util.base64.decode(object.remoteIdentityPublic, message.remoteIdentityPublic = $util.newBuffer($util.base64.length(object.remoteIdentityPublic)), 0);
                        else if (object.remoteIdentityPublic.length)
                            message.remoteIdentityPublic = object.remoteIdentityPublic;
                    if (object.rootKey != null)
                        if (typeof object.rootKey === "string")
                            $util.base64.decode(object.rootKey, message.rootKey = $util.newBuffer($util.base64.length(object.rootKey)), 0);
                        else if (object.rootKey.length)
                            message.rootKey = object.rootKey;
                    if (object.previousCounter != null)
                        message.previousCounter = object.previousCounter >>> 0;
                    if (object.senderChain != null) {
                        if (typeof object.senderChain !== "object")
                            throw TypeError(".signal.proto.storage.SessionStructure.senderChain: object expected");
                        message.senderChain = $root.signal.proto.storage.SessionStructure.Chain.fromObject(object.senderChain);
                    }
                    if (object.receiverChains) {
                        if (!Array.isArray(object.receiverChains))
                            throw TypeError(".signal.proto.storage.SessionStructure.receiverChains: array expected");
                        message.receiverChains = [];
                        for (var i = 0; i < object.receiverChains.length; ++i) {
                            if (typeof object.receiverChains[i] !== "object")
                                throw TypeError(".signal.proto.storage.SessionStructure.receiverChains: object expected");
                            message.receiverChains[i] = $root.signal.proto.storage.SessionStructure.Chain.fromObject(object.receiverChains[i]);
                        }
                    }
                    if (object.pendingPreKey != null) {
                        if (typeof object.pendingPreKey !== "object")
                            throw TypeError(".signal.proto.storage.SessionStructure.pendingPreKey: object expected");
                        message.pendingPreKey = $root.signal.proto.storage.SessionStructure.PendingPreKey.fromObject(object.pendingPreKey);
                    }
                    if (object.remoteRegistrationId != null)
                        message.remoteRegistrationId = object.remoteRegistrationId >>> 0;
                    if (object.localRegistrationId != null)
                        message.localRegistrationId = object.localRegistrationId >>> 0;
                    if (object.needsRefresh != null)
                        message.needsRefresh = Boolean(object.needsRefresh);
                    if (object.aliceBaseKey != null)
                        if (typeof object.aliceBaseKey === "string")
                            $util.base64.decode(object.aliceBaseKey, message.aliceBaseKey = $util.newBuffer($util.base64.length(object.aliceBaseKey)), 0);
                        else if (object.aliceBaseKey.length)
                            message.aliceBaseKey = object.aliceBaseKey;
                    return message;
                };

                /**
                 * Creates a plain object from a SessionStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.SessionStructure
                 * @static
                 * @param {signal.proto.storage.SessionStructure} message SessionStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.receiverChains = [];
                    if (options.defaults) {
                        object.sessionVersion = 0;
                        if (options.bytes === String)
                            object.localIdentityPublic = "";
                        else {
                            object.localIdentityPublic = [];
                            if (options.bytes !== Array)
                                object.localIdentityPublic = $util.newBuffer(object.localIdentityPublic);
                        }
                        if (options.bytes === String)
                            object.remoteIdentityPublic = "";
                        else {
                            object.remoteIdentityPublic = [];
                            if (options.bytes !== Array)
                                object.remoteIdentityPublic = $util.newBuffer(object.remoteIdentityPublic);
                        }
                        if (options.bytes === String)
                            object.rootKey = "";
                        else {
                            object.rootKey = [];
                            if (options.bytes !== Array)
                                object.rootKey = $util.newBuffer(object.rootKey);
                        }
                        object.previousCounter = 0;
                        object.senderChain = null;
                        object.pendingPreKey = null;
                        object.remoteRegistrationId = 0;
                        object.localRegistrationId = 0;
                        object.needsRefresh = false;
                        if (options.bytes === String)
                            object.aliceBaseKey = "";
                        else {
                            object.aliceBaseKey = [];
                            if (options.bytes !== Array)
                                object.aliceBaseKey = $util.newBuffer(object.aliceBaseKey);
                        }
                    }
                    if (message.sessionVersion != null && message.hasOwnProperty("sessionVersion"))
                        object.sessionVersion = message.sessionVersion;
                    if (message.localIdentityPublic != null && message.hasOwnProperty("localIdentityPublic"))
                        object.localIdentityPublic = options.bytes === String ? $util.base64.encode(message.localIdentityPublic, 0, message.localIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityPublic) : message.localIdentityPublic;
                    if (message.remoteIdentityPublic != null && message.hasOwnProperty("remoteIdentityPublic"))
                        object.remoteIdentityPublic = options.bytes === String ? $util.base64.encode(message.remoteIdentityPublic, 0, message.remoteIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.remoteIdentityPublic) : message.remoteIdentityPublic;
                    if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                        object.rootKey = options.bytes === String ? $util.base64.encode(message.rootKey, 0, message.rootKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootKey) : message.rootKey;
                    if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                        object.previousCounter = message.previousCounter;
                    if (message.senderChain != null && message.hasOwnProperty("senderChain"))
                        object.senderChain = $root.signal.proto.storage.SessionStructure.Chain.toObject(message.senderChain, options);
                    if (message.receiverChains && message.receiverChains.length) {
                        object.receiverChains = [];
                        for (var j = 0; j < message.receiverChains.length; ++j)
                            object.receiverChains[j] = $root.signal.proto.storage.SessionStructure.Chain.toObject(message.receiverChains[j], options);
                    }
                    if (message.pendingPreKey != null && message.hasOwnProperty("pendingPreKey"))
                        object.pendingPreKey = $root.signal.proto.storage.SessionStructure.PendingPreKey.toObject(message.pendingPreKey, options);
                    if (message.remoteRegistrationId != null && message.hasOwnProperty("remoteRegistrationId"))
                        object.remoteRegistrationId = message.remoteRegistrationId;
                    if (message.localRegistrationId != null && message.hasOwnProperty("localRegistrationId"))
                        object.localRegistrationId = message.localRegistrationId;
                    if (message.needsRefresh != null && message.hasOwnProperty("needsRefresh"))
                        object.needsRefresh = message.needsRefresh;
                    if (message.aliceBaseKey != null && message.hasOwnProperty("aliceBaseKey"))
                        object.aliceBaseKey = options.bytes === String ? $util.base64.encode(message.aliceBaseKey, 0, message.aliceBaseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.aliceBaseKey) : message.aliceBaseKey;
                    return object;
                };

                /**
                 * Converts this SessionStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.SessionStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                SessionStructure.Chain = (function() {

                    /**
                     * Properties of a Chain.
                     * @memberof signal.proto.storage.SessionStructure
                     * @interface IChain
                     * @property {Uint8Array|null} [senderRatchetKey] Chain senderRatchetKey
                     * @property {Uint8Array|null} [senderRatchetKeyPrivate] Chain senderRatchetKeyPrivate
                     * @property {signal.proto.storage.SessionStructure.Chain.IChainKey|null} [chainKey] Chain chainKey
                     * @property {Array.<signal.proto.storage.SessionStructure.Chain.IMessageKey>|null} [messageKeys] Chain messageKeys
                     */

                    /**
                     * Constructs a new Chain.
                     * @memberof signal.proto.storage.SessionStructure
                     * @classdesc Represents a Chain.
                     * @implements IChain
                     * @constructor
                     * @param {signal.proto.storage.SessionStructure.IChain=} [properties] Properties to set
                     */
                    function Chain(properties) {
                        this.messageKeys = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Chain senderRatchetKey.
                     * @member {Uint8Array} senderRatchetKey
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @instance
                     */
                    Chain.prototype.senderRatchetKey = $util.newBuffer([]);

                    /**
                     * Chain senderRatchetKeyPrivate.
                     * @member {Uint8Array} senderRatchetKeyPrivate
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @instance
                     */
                    Chain.prototype.senderRatchetKeyPrivate = $util.newBuffer([]);

                    /**
                     * Chain chainKey.
                     * @member {signal.proto.storage.SessionStructure.Chain.IChainKey|null|undefined} chainKey
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @instance
                     */
                    Chain.prototype.chainKey = null;

                    /**
                     * Chain messageKeys.
                     * @member {Array.<signal.proto.storage.SessionStructure.Chain.IMessageKey>} messageKeys
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @instance
                     */
                    Chain.prototype.messageKeys = $util.emptyArray;

                    /**
                     * Encodes the specified Chain message. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.verify|verify} messages.
                     * @function encode
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {signal.proto.storage.SessionStructure.IChain} message Chain message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Chain.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        var fullyUnknown = [];
                        if (message.__unknownFields)
                            for (var i = 0; i < message.__unknownFields.length; ++i)
                                try {
                                    var known = $root.signal.proto.storage.SessionStructure.Chain.decode(message.__unknownFields[i]);
                                    fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                    message = Object.assign(known, message);
                                } catch (_) {
                                }
                        if (message.senderRatchetKey != null && Object.hasOwnProperty.call(message, "senderRatchetKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.senderRatchetKey);
                        if (message.senderRatchetKeyPrivate != null && Object.hasOwnProperty.call(message, "senderRatchetKeyPrivate"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderRatchetKeyPrivate);
                        if (message.chainKey != null && Object.hasOwnProperty.call(message, "chainKey"))
                            $root.signal.proto.storage.SessionStructure.Chain.ChainKey.encode(message.chainKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.messageKeys != null && message.messageKeys.length)
                            for (var i = 0; i < message.messageKeys.length; ++i)
                                $root.signal.proto.storage.SessionStructure.Chain.MessageKey.encode(message.messageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        for (var i = 0; i < fullyUnknown.length; ++i)
                            writer.__unknownField(fullyUnknown[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Chain message, length delimited. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {signal.proto.storage.SessionStructure.IChain} message Chain message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Chain.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Chain message from the specified reader or buffer.
                     * @function decode
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signal.proto.storage.SessionStructure.Chain} Chain
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Chain.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SessionStructure.Chain();
                        while (reader.pos < end) {
                            var unknownStartPos = reader.pos;
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.senderRatchetKey = reader.bytes();
                                break;
                            case 2:
                                message.senderRatchetKeyPrivate = reader.bytes();
                                break;
                            case 3:
                                message.chainKey = $root.signal.proto.storage.SessionStructure.Chain.ChainKey.decode(reader, reader.uint32());
                                break;
                            case 4:
                                if (!(message.messageKeys && message.messageKeys.length))
                                    message.messageKeys = [];
                                message.messageKeys.push($root.signal.proto.storage.SessionStructure.Chain.MessageKey.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                if (!message.__unknownFields)
                                    message.__unknownFields = [];
                                message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Chain message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signal.proto.storage.SessionStructure.Chain} Chain
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Chain.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Creates a Chain message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signal.proto.storage.SessionStructure.Chain} Chain
                     */
                    Chain.fromObject = function fromObject(object) {
                        if (object instanceof $root.signal.proto.storage.SessionStructure.Chain)
                            return object;
                        var message = new $root.signal.proto.storage.SessionStructure.Chain();
                        if (object.senderRatchetKey != null)
                            if (typeof object.senderRatchetKey === "string")
                                $util.base64.decode(object.senderRatchetKey, message.senderRatchetKey = $util.newBuffer($util.base64.length(object.senderRatchetKey)), 0);
                            else if (object.senderRatchetKey.length)
                                message.senderRatchetKey = object.senderRatchetKey;
                        if (object.senderRatchetKeyPrivate != null)
                            if (typeof object.senderRatchetKeyPrivate === "string")
                                $util.base64.decode(object.senderRatchetKeyPrivate, message.senderRatchetKeyPrivate = $util.newBuffer($util.base64.length(object.senderRatchetKeyPrivate)), 0);
                            else if (object.senderRatchetKeyPrivate.length)
                                message.senderRatchetKeyPrivate = object.senderRatchetKeyPrivate;
                        if (object.chainKey != null) {
                            if (typeof object.chainKey !== "object")
                                throw TypeError(".signal.proto.storage.SessionStructure.Chain.chainKey: object expected");
                            message.chainKey = $root.signal.proto.storage.SessionStructure.Chain.ChainKey.fromObject(object.chainKey);
                        }
                        if (object.messageKeys) {
                            if (!Array.isArray(object.messageKeys))
                                throw TypeError(".signal.proto.storage.SessionStructure.Chain.messageKeys: array expected");
                            message.messageKeys = [];
                            for (var i = 0; i < object.messageKeys.length; ++i) {
                                if (typeof object.messageKeys[i] !== "object")
                                    throw TypeError(".signal.proto.storage.SessionStructure.Chain.messageKeys: object expected");
                                message.messageKeys[i] = $root.signal.proto.storage.SessionStructure.Chain.MessageKey.fromObject(object.messageKeys[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Chain message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @static
                     * @param {signal.proto.storage.SessionStructure.Chain} message Chain
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Chain.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.messageKeys = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.senderRatchetKey = "";
                            else {
                                object.senderRatchetKey = [];
                                if (options.bytes !== Array)
                                    object.senderRatchetKey = $util.newBuffer(object.senderRatchetKey);
                            }
                            if (options.bytes === String)
                                object.senderRatchetKeyPrivate = "";
                            else {
                                object.senderRatchetKeyPrivate = [];
                                if (options.bytes !== Array)
                                    object.senderRatchetKeyPrivate = $util.newBuffer(object.senderRatchetKeyPrivate);
                            }
                            object.chainKey = null;
                        }
                        if (message.senderRatchetKey != null && message.hasOwnProperty("senderRatchetKey"))
                            object.senderRatchetKey = options.bytes === String ? $util.base64.encode(message.senderRatchetKey, 0, message.senderRatchetKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKey) : message.senderRatchetKey;
                        if (message.senderRatchetKeyPrivate != null && message.hasOwnProperty("senderRatchetKeyPrivate"))
                            object.senderRatchetKeyPrivate = options.bytes === String ? $util.base64.encode(message.senderRatchetKeyPrivate, 0, message.senderRatchetKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKeyPrivate) : message.senderRatchetKeyPrivate;
                        if (message.chainKey != null && message.hasOwnProperty("chainKey"))
                            object.chainKey = $root.signal.proto.storage.SessionStructure.Chain.ChainKey.toObject(message.chainKey, options);
                        if (message.messageKeys && message.messageKeys.length) {
                            object.messageKeys = [];
                            for (var j = 0; j < message.messageKeys.length; ++j)
                                object.messageKeys[j] = $root.signal.proto.storage.SessionStructure.Chain.MessageKey.toObject(message.messageKeys[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Chain to JSON.
                     * @function toJSON
                     * @memberof signal.proto.storage.SessionStructure.Chain
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Chain.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Chain.ChainKey = (function() {

                        /**
                         * Properties of a ChainKey.
                         * @memberof signal.proto.storage.SessionStructure.Chain
                         * @interface IChainKey
                         * @property {number|null} [index] ChainKey index
                         * @property {Uint8Array|null} [key] ChainKey key
                         */

                        /**
                         * Constructs a new ChainKey.
                         * @memberof signal.proto.storage.SessionStructure.Chain
                         * @classdesc Represents a ChainKey.
                         * @implements IChainKey
                         * @constructor
                         * @param {signal.proto.storage.SessionStructure.Chain.IChainKey=} [properties] Properties to set
                         */
                        function ChainKey(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ChainKey index.
                         * @member {number} index
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @instance
                         */
                        ChainKey.prototype.index = 0;

                        /**
                         * ChainKey key.
                         * @member {Uint8Array} key
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @instance
                         */
                        ChainKey.prototype.key = $util.newBuffer([]);

                        /**
                         * Encodes the specified ChainKey message. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.ChainKey.verify|verify} messages.
                         * @function encode
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.IChainKey} message ChainKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChainKey.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            var fullyUnknown = [];
                            if (message.__unknownFields)
                                for (var i = 0; i < message.__unknownFields.length; ++i)
                                    try {
                                        var known = $root.signal.proto.storage.SessionStructure.Chain.ChainKey.decode(message.__unknownFields[i]);
                                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                        message = Object.assign(known, message);
                                    } catch (_) {
                                    }
                            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                            for (var i = 0; i < fullyUnknown.length; ++i)
                                writer.__unknownField(fullyUnknown[i]);
                            return writer;
                        };

                        /**
                         * Encodes the specified ChainKey message, length delimited. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.ChainKey.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.IChainKey} message ChainKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChainKey.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ChainKey message from the specified reader or buffer.
                         * @function decode
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {signal.proto.storage.SessionStructure.Chain.ChainKey} ChainKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChainKey.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SessionStructure.Chain.ChainKey();
                            while (reader.pos < end) {
                                var unknownStartPos = reader.pos;
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.index = reader.uint32();
                                    break;
                                case 2:
                                    message.key = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    if (!message.__unknownFields)
                                        message.__unknownFields = [];
                                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ChainKey message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {signal.proto.storage.SessionStructure.Chain.ChainKey} ChainKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChainKey.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Creates a ChainKey message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {signal.proto.storage.SessionStructure.Chain.ChainKey} ChainKey
                         */
                        ChainKey.fromObject = function fromObject(object) {
                            if (object instanceof $root.signal.proto.storage.SessionStructure.Chain.ChainKey)
                                return object;
                            var message = new $root.signal.proto.storage.SessionStructure.Chain.ChainKey();
                            if (object.index != null)
                                message.index = object.index >>> 0;
                            if (object.key != null)
                                if (typeof object.key === "string")
                                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                                else if (object.key.length)
                                    message.key = object.key;
                            return message;
                        };

                        /**
                         * Creates a plain object from a ChainKey message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.ChainKey} message ChainKey
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ChainKey.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.index = 0;
                                if (options.bytes === String)
                                    object.key = "";
                                else {
                                    object.key = [];
                                    if (options.bytes !== Array)
                                        object.key = $util.newBuffer(object.key);
                                }
                            }
                            if (message.index != null && message.hasOwnProperty("index"))
                                object.index = message.index;
                            if (message.key != null && message.hasOwnProperty("key"))
                                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                            return object;
                        };

                        /**
                         * Converts this ChainKey to JSON.
                         * @function toJSON
                         * @memberof signal.proto.storage.SessionStructure.Chain.ChainKey
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ChainKey.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return ChainKey;
                    })();

                    Chain.MessageKey = (function() {

                        /**
                         * Properties of a MessageKey.
                         * @memberof signal.proto.storage.SessionStructure.Chain
                         * @interface IMessageKey
                         * @property {number|null} [index] MessageKey index
                         * @property {Uint8Array|null} [cipherKey] MessageKey cipherKey
                         * @property {Uint8Array|null} [macKey] MessageKey macKey
                         * @property {Uint8Array|null} [iv] MessageKey iv
                         */

                        /**
                         * Constructs a new MessageKey.
                         * @memberof signal.proto.storage.SessionStructure.Chain
                         * @classdesc Represents a MessageKey.
                         * @implements IMessageKey
                         * @constructor
                         * @param {signal.proto.storage.SessionStructure.Chain.IMessageKey=} [properties] Properties to set
                         */
                        function MessageKey(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * MessageKey index.
                         * @member {number} index
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @instance
                         */
                        MessageKey.prototype.index = 0;

                        /**
                         * MessageKey cipherKey.
                         * @member {Uint8Array} cipherKey
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @instance
                         */
                        MessageKey.prototype.cipherKey = $util.newBuffer([]);

                        /**
                         * MessageKey macKey.
                         * @member {Uint8Array} macKey
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @instance
                         */
                        MessageKey.prototype.macKey = $util.newBuffer([]);

                        /**
                         * MessageKey iv.
                         * @member {Uint8Array} iv
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @instance
                         */
                        MessageKey.prototype.iv = $util.newBuffer([]);

                        /**
                         * Encodes the specified MessageKey message. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.MessageKey.verify|verify} messages.
                         * @function encode
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.IMessageKey} message MessageKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageKey.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            var fullyUnknown = [];
                            if (message.__unknownFields)
                                for (var i = 0; i < message.__unknownFields.length; ++i)
                                    try {
                                        var known = $root.signal.proto.storage.SessionStructure.Chain.MessageKey.decode(message.__unknownFields[i]);
                                        fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                        message = Object.assign(known, message);
                                    } catch (_) {
                                    }
                            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                            if (message.cipherKey != null && Object.hasOwnProperty.call(message, "cipherKey"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cipherKey);
                            if (message.macKey != null && Object.hasOwnProperty.call(message, "macKey"))
                                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.macKey);
                            if (message.iv != null && Object.hasOwnProperty.call(message, "iv"))
                                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.iv);
                            for (var i = 0; i < fullyUnknown.length; ++i)
                                writer.__unknownField(fullyUnknown[i]);
                            return writer;
                        };

                        /**
                         * Encodes the specified MessageKey message, length delimited. Does not implicitly {@link signal.proto.storage.SessionStructure.Chain.MessageKey.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.IMessageKey} message MessageKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MessageKey.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a MessageKey message from the specified reader or buffer.
                         * @function decode
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {signal.proto.storage.SessionStructure.Chain.MessageKey} MessageKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageKey.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SessionStructure.Chain.MessageKey();
                            while (reader.pos < end) {
                                var unknownStartPos = reader.pos;
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.index = reader.uint32();
                                    break;
                                case 2:
                                    message.cipherKey = reader.bytes();
                                    break;
                                case 3:
                                    message.macKey = reader.bytes();
                                    break;
                                case 4:
                                    message.iv = reader.bytes();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    if (!message.__unknownFields)
                                        message.__unknownFields = [];
                                    message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a MessageKey message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {signal.proto.storage.SessionStructure.Chain.MessageKey} MessageKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MessageKey.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Creates a MessageKey message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {signal.proto.storage.SessionStructure.Chain.MessageKey} MessageKey
                         */
                        MessageKey.fromObject = function fromObject(object) {
                            if (object instanceof $root.signal.proto.storage.SessionStructure.Chain.MessageKey)
                                return object;
                            var message = new $root.signal.proto.storage.SessionStructure.Chain.MessageKey();
                            if (object.index != null)
                                message.index = object.index >>> 0;
                            if (object.cipherKey != null)
                                if (typeof object.cipherKey === "string")
                                    $util.base64.decode(object.cipherKey, message.cipherKey = $util.newBuffer($util.base64.length(object.cipherKey)), 0);
                                else if (object.cipherKey.length)
                                    message.cipherKey = object.cipherKey;
                            if (object.macKey != null)
                                if (typeof object.macKey === "string")
                                    $util.base64.decode(object.macKey, message.macKey = $util.newBuffer($util.base64.length(object.macKey)), 0);
                                else if (object.macKey.length)
                                    message.macKey = object.macKey;
                            if (object.iv != null)
                                if (typeof object.iv === "string")
                                    $util.base64.decode(object.iv, message.iv = $util.newBuffer($util.base64.length(object.iv)), 0);
                                else if (object.iv.length)
                                    message.iv = object.iv;
                            return message;
                        };

                        /**
                         * Creates a plain object from a MessageKey message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @static
                         * @param {signal.proto.storage.SessionStructure.Chain.MessageKey} message MessageKey
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        MessageKey.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.index = 0;
                                if (options.bytes === String)
                                    object.cipherKey = "";
                                else {
                                    object.cipherKey = [];
                                    if (options.bytes !== Array)
                                        object.cipherKey = $util.newBuffer(object.cipherKey);
                                }
                                if (options.bytes === String)
                                    object.macKey = "";
                                else {
                                    object.macKey = [];
                                    if (options.bytes !== Array)
                                        object.macKey = $util.newBuffer(object.macKey);
                                }
                                if (options.bytes === String)
                                    object.iv = "";
                                else {
                                    object.iv = [];
                                    if (options.bytes !== Array)
                                        object.iv = $util.newBuffer(object.iv);
                                }
                            }
                            if (message.index != null && message.hasOwnProperty("index"))
                                object.index = message.index;
                            if (message.cipherKey != null && message.hasOwnProperty("cipherKey"))
                                object.cipherKey = options.bytes === String ? $util.base64.encode(message.cipherKey, 0, message.cipherKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.cipherKey) : message.cipherKey;
                            if (message.macKey != null && message.hasOwnProperty("macKey"))
                                object.macKey = options.bytes === String ? $util.base64.encode(message.macKey, 0, message.macKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.macKey) : message.macKey;
                            if (message.iv != null && message.hasOwnProperty("iv"))
                                object.iv = options.bytes === String ? $util.base64.encode(message.iv, 0, message.iv.length) : options.bytes === Array ? Array.prototype.slice.call(message.iv) : message.iv;
                            return object;
                        };

                        /**
                         * Converts this MessageKey to JSON.
                         * @function toJSON
                         * @memberof signal.proto.storage.SessionStructure.Chain.MessageKey
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        MessageKey.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return MessageKey;
                    })();

                    return Chain;
                })();

                SessionStructure.PendingPreKey = (function() {

                    /**
                     * Properties of a PendingPreKey.
                     * @memberof signal.proto.storage.SessionStructure
                     * @interface IPendingPreKey
                     * @property {number|null} [preKeyId] PendingPreKey preKeyId
                     * @property {number|null} [signedPreKeyId] PendingPreKey signedPreKeyId
                     * @property {Uint8Array|null} [baseKey] PendingPreKey baseKey
                     */

                    /**
                     * Constructs a new PendingPreKey.
                     * @memberof signal.proto.storage.SessionStructure
                     * @classdesc Represents a PendingPreKey.
                     * @implements IPendingPreKey
                     * @constructor
                     * @param {signal.proto.storage.SessionStructure.IPendingPreKey=} [properties] Properties to set
                     */
                    function PendingPreKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PendingPreKey preKeyId.
                     * @member {number} preKeyId
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @instance
                     */
                    PendingPreKey.prototype.preKeyId = 0;

                    /**
                     * PendingPreKey signedPreKeyId.
                     * @member {number} signedPreKeyId
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @instance
                     */
                    PendingPreKey.prototype.signedPreKeyId = 0;

                    /**
                     * PendingPreKey baseKey.
                     * @member {Uint8Array} baseKey
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @instance
                     */
                    PendingPreKey.prototype.baseKey = $util.newBuffer([]);

                    /**
                     * Encodes the specified PendingPreKey message. Does not implicitly {@link signal.proto.storage.SessionStructure.PendingPreKey.verify|verify} messages.
                     * @function encode
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {signal.proto.storage.SessionStructure.IPendingPreKey} message PendingPreKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PendingPreKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        var fullyUnknown = [];
                        if (message.__unknownFields)
                            for (var i = 0; i < message.__unknownFields.length; ++i)
                                try {
                                    var known = $root.signal.proto.storage.SessionStructure.PendingPreKey.decode(message.__unknownFields[i]);
                                    fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                    message = Object.assign(known, message);
                                } catch (_) {
                                }
                        if (message.preKeyId != null && Object.hasOwnProperty.call(message, "preKeyId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.preKeyId);
                        if (message.baseKey != null && Object.hasOwnProperty.call(message, "baseKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);
                        if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.signedPreKeyId);
                        for (var i = 0; i < fullyUnknown.length; ++i)
                            writer.__unknownField(fullyUnknown[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified PendingPreKey message, length delimited. Does not implicitly {@link signal.proto.storage.SessionStructure.PendingPreKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {signal.proto.storage.SessionStructure.IPendingPreKey} message PendingPreKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PendingPreKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PendingPreKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signal.proto.storage.SessionStructure.PendingPreKey} PendingPreKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PendingPreKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SessionStructure.PendingPreKey();
                        while (reader.pos < end) {
                            var unknownStartPos = reader.pos;
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.preKeyId = reader.uint32();
                                break;
                            case 3:
                                message.signedPreKeyId = reader.int32();
                                break;
                            case 2:
                                message.baseKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                if (!message.__unknownFields)
                                    message.__unknownFields = [];
                                message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PendingPreKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signal.proto.storage.SessionStructure.PendingPreKey} PendingPreKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PendingPreKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Creates a PendingPreKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signal.proto.storage.SessionStructure.PendingPreKey} PendingPreKey
                     */
                    PendingPreKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.signal.proto.storage.SessionStructure.PendingPreKey)
                            return object;
                        var message = new $root.signal.proto.storage.SessionStructure.PendingPreKey();
                        if (object.preKeyId != null)
                            message.preKeyId = object.preKeyId >>> 0;
                        if (object.signedPreKeyId != null)
                            message.signedPreKeyId = object.signedPreKeyId | 0;
                        if (object.baseKey != null)
                            if (typeof object.baseKey === "string")
                                $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);
                            else if (object.baseKey.length)
                                message.baseKey = object.baseKey;
                        return message;
                    };

                    /**
                     * Creates a plain object from a PendingPreKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @static
                     * @param {signal.proto.storage.SessionStructure.PendingPreKey} message PendingPreKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PendingPreKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.preKeyId = 0;
                            if (options.bytes === String)
                                object.baseKey = "";
                            else {
                                object.baseKey = [];
                                if (options.bytes !== Array)
                                    object.baseKey = $util.newBuffer(object.baseKey);
                            }
                            object.signedPreKeyId = 0;
                        }
                        if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                            object.preKeyId = message.preKeyId;
                        if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                            object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;
                        if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                            object.signedPreKeyId = message.signedPreKeyId;
                        return object;
                    };

                    /**
                     * Converts this PendingPreKey to JSON.
                     * @function toJSON
                     * @memberof signal.proto.storage.SessionStructure.PendingPreKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PendingPreKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PendingPreKey;
                })();

                return SessionStructure;
            })();

            storage.RecordStructure = (function() {

                /**
                 * Properties of a RecordStructure.
                 * @memberof signal.proto.storage
                 * @interface IRecordStructure
                 * @property {signal.proto.storage.ISessionStructure|null} [currentSession] RecordStructure currentSession
                 * @property {Array.<signal.proto.storage.ISessionStructure>|null} [previousSessions] RecordStructure previousSessions
                 */

                /**
                 * Constructs a new RecordStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a RecordStructure.
                 * @implements IRecordStructure
                 * @constructor
                 * @param {signal.proto.storage.IRecordStructure=} [properties] Properties to set
                 */
                function RecordStructure(properties) {
                    this.previousSessions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RecordStructure currentSession.
                 * @member {signal.proto.storage.ISessionStructure|null|undefined} currentSession
                 * @memberof signal.proto.storage.RecordStructure
                 * @instance
                 */
                RecordStructure.prototype.currentSession = null;

                /**
                 * RecordStructure previousSessions.
                 * @member {Array.<signal.proto.storage.ISessionStructure>} previousSessions
                 * @memberof signal.proto.storage.RecordStructure
                 * @instance
                 */
                RecordStructure.prototype.previousSessions = $util.emptyArray;

                /**
                 * Encodes the specified RecordStructure message. Does not implicitly {@link signal.proto.storage.RecordStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {signal.proto.storage.IRecordStructure} message RecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RecordStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.RecordStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.currentSession != null && Object.hasOwnProperty.call(message, "currentSession"))
                        $root.signal.proto.storage.SessionStructure.encode(message.currentSession, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.previousSessions != null && message.previousSessions.length)
                        for (var i = 0; i < message.previousSessions.length; ++i)
                            $root.signal.proto.storage.SessionStructure.encode(message.previousSessions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified RecordStructure message, length delimited. Does not implicitly {@link signal.proto.storage.RecordStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {signal.proto.storage.IRecordStructure} message RecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RecordStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.RecordStructure} RecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RecordStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.RecordStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.currentSession = $root.signal.proto.storage.SessionStructure.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.previousSessions && message.previousSessions.length))
                                message.previousSessions = [];
                            message.previousSessions.push($root.signal.proto.storage.SessionStructure.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RecordStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.RecordStructure} RecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RecordStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a RecordStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.RecordStructure} RecordStructure
                 */
                RecordStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.RecordStructure)
                        return object;
                    var message = new $root.signal.proto.storage.RecordStructure();
                    if (object.currentSession != null) {
                        if (typeof object.currentSession !== "object")
                            throw TypeError(".signal.proto.storage.RecordStructure.currentSession: object expected");
                        message.currentSession = $root.signal.proto.storage.SessionStructure.fromObject(object.currentSession);
                    }
                    if (object.previousSessions) {
                        if (!Array.isArray(object.previousSessions))
                            throw TypeError(".signal.proto.storage.RecordStructure.previousSessions: array expected");
                        message.previousSessions = [];
                        for (var i = 0; i < object.previousSessions.length; ++i) {
                            if (typeof object.previousSessions[i] !== "object")
                                throw TypeError(".signal.proto.storage.RecordStructure.previousSessions: object expected");
                            message.previousSessions[i] = $root.signal.proto.storage.SessionStructure.fromObject(object.previousSessions[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RecordStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.RecordStructure
                 * @static
                 * @param {signal.proto.storage.RecordStructure} message RecordStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RecordStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.previousSessions = [];
                    if (options.defaults)
                        object.currentSession = null;
                    if (message.currentSession != null && message.hasOwnProperty("currentSession"))
                        object.currentSession = $root.signal.proto.storage.SessionStructure.toObject(message.currentSession, options);
                    if (message.previousSessions && message.previousSessions.length) {
                        object.previousSessions = [];
                        for (var j = 0; j < message.previousSessions.length; ++j)
                            object.previousSessions[j] = $root.signal.proto.storage.SessionStructure.toObject(message.previousSessions[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this RecordStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.RecordStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RecordStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RecordStructure;
            })();

            storage.PreKeyRecordStructure = (function() {

                /**
                 * Properties of a PreKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @interface IPreKeyRecordStructure
                 * @property {number|null} [id] PreKeyRecordStructure id
                 * @property {Uint8Array|null} [publicKey] PreKeyRecordStructure publicKey
                 * @property {Uint8Array|null} [privateKey] PreKeyRecordStructure privateKey
                 */

                /**
                 * Constructs a new PreKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a PreKeyRecordStructure.
                 * @implements IPreKeyRecordStructure
                 * @constructor
                 * @param {signal.proto.storage.IPreKeyRecordStructure=} [properties] Properties to set
                 */
                function PreKeyRecordStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PreKeyRecordStructure id.
                 * @member {number} id
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @instance
                 */
                PreKeyRecordStructure.prototype.id = 0;

                /**
                 * PreKeyRecordStructure publicKey.
                 * @member {Uint8Array} publicKey
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @instance
                 */
                PreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

                /**
                 * PreKeyRecordStructure privateKey.
                 * @member {Uint8Array} privateKey
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @instance
                 */
                PreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

                /**
                 * Encodes the specified PreKeyRecordStructure message. Does not implicitly {@link signal.proto.storage.PreKeyRecordStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PreKeyRecordStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.PreKeyRecordStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
                    if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified PreKeyRecordStructure message, length delimited. Does not implicitly {@link signal.proto.storage.PreKeyRecordStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PreKeyRecordStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.PreKeyRecordStructure} PreKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PreKeyRecordStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.PreKeyRecordStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.publicKey = reader.bytes();
                            break;
                        case 3:
                            message.privateKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PreKeyRecordStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.PreKeyRecordStructure} PreKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a PreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.PreKeyRecordStructure} PreKeyRecordStructure
                 */
                PreKeyRecordStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.PreKeyRecordStructure)
                        return object;
                    var message = new $root.signal.proto.storage.PreKeyRecordStructure();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.publicKey != null)
                        if (typeof object.publicKey === "string")
                            $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                        else if (object.publicKey.length)
                            message.publicKey = object.publicKey;
                    if (object.privateKey != null)
                        if (typeof object.privateKey === "string")
                            $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                        else if (object.privateKey.length)
                            message.privateKey = object.privateKey;
                    return message;
                };

                /**
                 * Creates a plain object from a PreKeyRecordStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.PreKeyRecordStructure} message PreKeyRecordStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PreKeyRecordStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = 0;
                        if (options.bytes === String)
                            object.publicKey = "";
                        else {
                            object.publicKey = [];
                            if (options.bytes !== Array)
                                object.publicKey = $util.newBuffer(object.publicKey);
                        }
                        if (options.bytes === String)
                            object.privateKey = "";
                        else {
                            object.privateKey = [];
                            if (options.bytes !== Array)
                                object.privateKey = $util.newBuffer(object.privateKey);
                        }
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                        object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                    if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                        object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                    return object;
                };

                /**
                 * Converts this PreKeyRecordStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.PreKeyRecordStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PreKeyRecordStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PreKeyRecordStructure;
            })();

            storage.SignedPreKeyRecordStructure = (function() {

                /**
                 * Properties of a SignedPreKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @interface ISignedPreKeyRecordStructure
                 * @property {number|null} [id] SignedPreKeyRecordStructure id
                 * @property {Uint8Array|null} [publicKey] SignedPreKeyRecordStructure publicKey
                 * @property {Uint8Array|null} [privateKey] SignedPreKeyRecordStructure privateKey
                 * @property {Uint8Array|null} [signature] SignedPreKeyRecordStructure signature
                 * @property {Long|null} [timestamp] SignedPreKeyRecordStructure timestamp
                 */

                /**
                 * Constructs a new SignedPreKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a SignedPreKeyRecordStructure.
                 * @implements ISignedPreKeyRecordStructure
                 * @constructor
                 * @param {signal.proto.storage.ISignedPreKeyRecordStructure=} [properties] Properties to set
                 */
                function SignedPreKeyRecordStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SignedPreKeyRecordStructure id.
                 * @member {number} id
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 */
                SignedPreKeyRecordStructure.prototype.id = 0;

                /**
                 * SignedPreKeyRecordStructure publicKey.
                 * @member {Uint8Array} publicKey
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 */
                SignedPreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

                /**
                 * SignedPreKeyRecordStructure privateKey.
                 * @member {Uint8Array} privateKey
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 */
                SignedPreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

                /**
                 * SignedPreKeyRecordStructure signature.
                 * @member {Uint8Array} signature
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 */
                SignedPreKeyRecordStructure.prototype.signature = $util.newBuffer([]);

                /**
                 * SignedPreKeyRecordStructure timestamp.
                 * @member {Long} timestamp
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 */
                SignedPreKeyRecordStructure.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified SignedPreKeyRecordStructure message. Does not implicitly {@link signal.proto.storage.SignedPreKeyRecordStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignedPreKeyRecordStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.SignedPreKeyRecordStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
                    if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.timestamp);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SignedPreKeyRecordStructure message, length delimited. Does not implicitly {@link signal.proto.storage.SignedPreKeyRecordStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignedPreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignedPreKeyRecordStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SignedPreKeyRecordStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.publicKey = reader.bytes();
                            break;
                        case 3:
                            message.privateKey = reader.bytes();
                            break;
                        case 4:
                            message.signature = reader.bytes();
                            break;
                        case 5:
                            message.timestamp = reader.fixed64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignedPreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a SignedPreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
                 */
                SignedPreKeyRecordStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.SignedPreKeyRecordStructure)
                        return object;
                    var message = new $root.signal.proto.storage.SignedPreKeyRecordStructure();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.publicKey != null)
                        if (typeof object.publicKey === "string")
                            $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                        else if (object.publicKey.length)
                            message.publicKey = object.publicKey;
                    if (object.privateKey != null)
                        if (typeof object.privateKey === "string")
                            $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                        else if (object.privateKey.length)
                            message.privateKey = object.privateKey;
                    if (object.signature != null)
                        if (typeof object.signature === "string")
                            $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                        else if (object.signature.length)
                            message.signature = object.signature;
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a SignedPreKeyRecordStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.SignedPreKeyRecordStructure} message SignedPreKeyRecordStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SignedPreKeyRecordStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = 0;
                        if (options.bytes === String)
                            object.publicKey = "";
                        else {
                            object.publicKey = [];
                            if (options.bytes !== Array)
                                object.publicKey = $util.newBuffer(object.publicKey);
                        }
                        if (options.bytes === String)
                            object.privateKey = "";
                        else {
                            object.privateKey = [];
                            if (options.bytes !== Array)
                                object.privateKey = $util.newBuffer(object.privateKey);
                        }
                        if (options.bytes === String)
                            object.signature = "";
                        else {
                            object.signature = [];
                            if (options.bytes !== Array)
                                object.signature = $util.newBuffer(object.signature);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                        object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                    if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                        object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                    return object;
                };

                /**
                 * Converts this SignedPreKeyRecordStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.SignedPreKeyRecordStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SignedPreKeyRecordStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SignedPreKeyRecordStructure;
            })();

            storage.IdentityKeyPairStructure = (function() {

                /**
                 * Properties of an IdentityKeyPairStructure.
                 * @memberof signal.proto.storage
                 * @interface IIdentityKeyPairStructure
                 * @property {Uint8Array|null} [publicKey] IdentityKeyPairStructure publicKey
                 * @property {Uint8Array|null} [privateKey] IdentityKeyPairStructure privateKey
                 */

                /**
                 * Constructs a new IdentityKeyPairStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents an IdentityKeyPairStructure.
                 * @implements IIdentityKeyPairStructure
                 * @constructor
                 * @param {signal.proto.storage.IIdentityKeyPairStructure=} [properties] Properties to set
                 */
                function IdentityKeyPairStructure(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IdentityKeyPairStructure publicKey.
                 * @member {Uint8Array} publicKey
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @instance
                 */
                IdentityKeyPairStructure.prototype.publicKey = $util.newBuffer([]);

                /**
                 * IdentityKeyPairStructure privateKey.
                 * @member {Uint8Array} privateKey
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @instance
                 */
                IdentityKeyPairStructure.prototype.privateKey = $util.newBuffer([]);

                /**
                 * Encodes the specified IdentityKeyPairStructure message. Does not implicitly {@link signal.proto.storage.IdentityKeyPairStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {signal.proto.storage.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IdentityKeyPairStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.IdentityKeyPairStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                    if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified IdentityKeyPairStructure message, length delimited. Does not implicitly {@link signal.proto.storage.IdentityKeyPairStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {signal.proto.storage.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IdentityKeyPairStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IdentityKeyPairStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.IdentityKeyPairStructure} IdentityKeyPairStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IdentityKeyPairStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.IdentityKeyPairStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.publicKey = reader.bytes();
                            break;
                        case 2:
                            message.privateKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IdentityKeyPairStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.IdentityKeyPairStructure} IdentityKeyPairStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IdentityKeyPairStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates an IdentityKeyPairStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.IdentityKeyPairStructure} IdentityKeyPairStructure
                 */
                IdentityKeyPairStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.IdentityKeyPairStructure)
                        return object;
                    var message = new $root.signal.proto.storage.IdentityKeyPairStructure();
                    if (object.publicKey != null)
                        if (typeof object.publicKey === "string")
                            $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                        else if (object.publicKey.length)
                            message.publicKey = object.publicKey;
                    if (object.privateKey != null)
                        if (typeof object.privateKey === "string")
                            $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                        else if (object.privateKey.length)
                            message.privateKey = object.privateKey;
                    return message;
                };

                /**
                 * Creates a plain object from an IdentityKeyPairStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @static
                 * @param {signal.proto.storage.IdentityKeyPairStructure} message IdentityKeyPairStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IdentityKeyPairStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.publicKey = "";
                        else {
                            object.publicKey = [];
                            if (options.bytes !== Array)
                                object.publicKey = $util.newBuffer(object.publicKey);
                        }
                        if (options.bytes === String)
                            object.privateKey = "";
                        else {
                            object.privateKey = [];
                            if (options.bytes !== Array)
                                object.privateKey = $util.newBuffer(object.privateKey);
                        }
                    }
                    if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                        object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                    if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                        object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                    return object;
                };

                /**
                 * Converts this IdentityKeyPairStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.IdentityKeyPairStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IdentityKeyPairStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return IdentityKeyPairStructure;
            })();

            storage.SenderKeyStateStructure = (function() {

                /**
                 * Properties of a SenderKeyStateStructure.
                 * @memberof signal.proto.storage
                 * @interface ISenderKeyStateStructure
                 * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId
                 * @property {signal.proto.storage.SenderKeyStateStructure.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey
                 * @property {signal.proto.storage.SenderKeyStateStructure.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey
                 * @property {Array.<signal.proto.storage.SenderKeyStateStructure.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys
                 */

                /**
                 * Constructs a new SenderKeyStateStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a SenderKeyStateStructure.
                 * @implements ISenderKeyStateStructure
                 * @constructor
                 * @param {signal.proto.storage.ISenderKeyStateStructure=} [properties] Properties to set
                 */
                function SenderKeyStateStructure(properties) {
                    this.senderMessageKeys = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SenderKeyStateStructure senderKeyId.
                 * @member {number} senderKeyId
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @instance
                 */
                SenderKeyStateStructure.prototype.senderKeyId = 0;

                /**
                 * SenderKeyStateStructure senderChainKey.
                 * @member {signal.proto.storage.SenderKeyStateStructure.ISenderChainKey|null|undefined} senderChainKey
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @instance
                 */
                SenderKeyStateStructure.prototype.senderChainKey = null;

                /**
                 * SenderKeyStateStructure senderSigningKey.
                 * @member {signal.proto.storage.SenderKeyStateStructure.ISenderSigningKey|null|undefined} senderSigningKey
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @instance
                 */
                SenderKeyStateStructure.prototype.senderSigningKey = null;

                /**
                 * SenderKeyStateStructure senderMessageKeys.
                 * @member {Array.<signal.proto.storage.SenderKeyStateStructure.ISenderMessageKey>} senderMessageKeys
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @instance
                 */
                SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;

                /**
                 * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {signal.proto.storage.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SenderKeyStateStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.SenderKeyStateStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.senderKeyId != null && Object.hasOwnProperty.call(message, "senderKeyId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);
                    if (message.senderChainKey != null && Object.hasOwnProperty.call(message, "senderChainKey"))
                        $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, "senderSigningKey"))
                        $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.senderMessageKeys != null && message.senderMessageKeys.length)
                        for (var i = 0; i < message.senderMessageKeys.length; ++i)
                            $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {signal.proto.storage.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SenderKeyStateStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.SenderKeyStateStructure} SenderKeyStateStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SenderKeyStateStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SenderKeyStateStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.senderKeyId = reader.uint32();
                            break;
                        case 2:
                            message.senderChainKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.senderSigningKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.senderMessageKeys && message.senderMessageKeys.length))
                                message.senderMessageKeys = [];
                            message.senderMessageKeys.push($root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.SenderKeyStateStructure} SenderKeyStateStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.SenderKeyStateStructure} SenderKeyStateStructure
                 */
                SenderKeyStateStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.SenderKeyStateStructure)
                        return object;
                    var message = new $root.signal.proto.storage.SenderKeyStateStructure();
                    if (object.senderKeyId != null)
                        message.senderKeyId = object.senderKeyId >>> 0;
                    if (object.senderChainKey != null) {
                        if (typeof object.senderChainKey !== "object")
                            throw TypeError(".signal.proto.storage.SenderKeyStateStructure.senderChainKey: object expected");
                        message.senderChainKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey.fromObject(object.senderChainKey);
                    }
                    if (object.senderSigningKey != null) {
                        if (typeof object.senderSigningKey !== "object")
                            throw TypeError(".signal.proto.storage.SenderKeyStateStructure.senderSigningKey: object expected");
                        message.senderSigningKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.fromObject(object.senderSigningKey);
                    }
                    if (object.senderMessageKeys) {
                        if (!Array.isArray(object.senderMessageKeys))
                            throw TypeError(".signal.proto.storage.SenderKeyStateStructure.senderMessageKeys: array expected");
                        message.senderMessageKeys = [];
                        for (var i = 0; i < object.senderMessageKeys.length; ++i) {
                            if (typeof object.senderMessageKeys[i] !== "object")
                                throw TypeError(".signal.proto.storage.SenderKeyStateStructure.senderMessageKeys: object expected");
                            message.senderMessageKeys[i] = $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.fromObject(object.senderMessageKeys[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @static
                 * @param {signal.proto.storage.SenderKeyStateStructure} message SenderKeyStateStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SenderKeyStateStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.senderMessageKeys = [];
                    if (options.defaults) {
                        object.senderKeyId = 0;
                        object.senderChainKey = null;
                        object.senderSigningKey = null;
                    }
                    if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                        object.senderKeyId = message.senderKeyId;
                    if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey"))
                        object.senderChainKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey.toObject(message.senderChainKey, options);
                    if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey"))
                        object.senderSigningKey = $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.toObject(message.senderSigningKey, options);
                    if (message.senderMessageKeys && message.senderMessageKeys.length) {
                        object.senderMessageKeys = [];
                        for (var j = 0; j < message.senderMessageKeys.length; ++j)
                            object.senderMessageKeys[j] = $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.toObject(message.senderMessageKeys[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SenderKeyStateStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.SenderKeyStateStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SenderKeyStateStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                SenderKeyStateStructure.SenderChainKey = (function() {

                    /**
                     * Properties of a SenderChainKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @interface ISenderChainKey
                     * @property {number|null} [iteration] SenderChainKey iteration
                     * @property {Uint8Array|null} [seed] SenderChainKey seed
                     */

                    /**
                     * Constructs a new SenderChainKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @classdesc Represents a SenderChainKey.
                     * @implements ISenderChainKey
                     * @constructor
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderChainKey=} [properties] Properties to set
                     */
                    function SenderChainKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SenderChainKey iteration.
                     * @member {number} iteration
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @instance
                     */
                    SenderChainKey.prototype.iteration = 0;

                    /**
                     * SenderChainKey seed.
                     * @member {Uint8Array} seed
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @instance
                     */
                    SenderChainKey.prototype.seed = $util.newBuffer([]);

                    /**
                     * Encodes the specified SenderChainKey message. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderChainKey.verify|verify} messages.
                     * @function encode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderChainKey} message SenderChainKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderChainKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        var fullyUnknown = [];
                        if (message.__unknownFields)
                            for (var i = 0; i < message.__unknownFields.length; ++i)
                                try {
                                    var known = $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey.decode(message.__unknownFields[i]);
                                    fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                    message = Object.assign(known, message);
                                } catch (_) {
                                }
                        if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
                        if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
                        for (var i = 0; i < fullyUnknown.length; ++i)
                            writer.__unknownField(fullyUnknown[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderChainKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderChainKey} message SenderChainKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SenderChainKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderChainKey} SenderChainKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderChainKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey();
                        while (reader.pos < end) {
                            var unknownStartPos = reader.pos;
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.iteration = reader.uint32();
                                break;
                            case 2:
                                message.seed = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                if (!message.__unknownFields)
                                    message.__unknownFields = [];
                                message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderChainKey} SenderChainKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderChainKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderChainKey} SenderChainKey
                     */
                    SenderChainKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey)
                            return object;
                        var message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderChainKey();
                        if (object.iteration != null)
                            message.iteration = object.iteration >>> 0;
                        if (object.seed != null)
                            if (typeof object.seed === "string")
                                $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                            else if (object.seed.length)
                                message.seed = object.seed;
                        return message;
                    };

                    /**
                     * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.SenderChainKey} message SenderChainKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SenderChainKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.iteration = 0;
                            if (options.bytes === String)
                                object.seed = "";
                            else {
                                object.seed = [];
                                if (options.bytes !== Array)
                                    object.seed = $util.newBuffer(object.seed);
                            }
                        }
                        if (message.iteration != null && message.hasOwnProperty("iteration"))
                            object.iteration = message.iteration;
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                        return object;
                    };

                    /**
                     * Converts this SenderChainKey to JSON.
                     * @function toJSON
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderChainKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SenderChainKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SenderChainKey;
                })();

                SenderKeyStateStructure.SenderMessageKey = (function() {

                    /**
                     * Properties of a SenderMessageKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @interface ISenderMessageKey
                     * @property {number|null} [iteration] SenderMessageKey iteration
                     * @property {Uint8Array|null} [seed] SenderMessageKey seed
                     */

                    /**
                     * Constructs a new SenderMessageKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @classdesc Represents a SenderMessageKey.
                     * @implements ISenderMessageKey
                     * @constructor
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderMessageKey=} [properties] Properties to set
                     */
                    function SenderMessageKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SenderMessageKey iteration.
                     * @member {number} iteration
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @instance
                     */
                    SenderMessageKey.prototype.iteration = 0;

                    /**
                     * SenderMessageKey seed.
                     * @member {Uint8Array} seed
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @instance
                     */
                    SenderMessageKey.prototype.seed = $util.newBuffer([]);

                    /**
                     * Encodes the specified SenderMessageKey message. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.verify|verify} messages.
                     * @function encode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderMessageKey} message SenderMessageKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderMessageKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        var fullyUnknown = [];
                        if (message.__unknownFields)
                            for (var i = 0; i < message.__unknownFields.length; ++i)
                                try {
                                    var known = $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.decode(message.__unknownFields[i]);
                                    fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                    message = Object.assign(known, message);
                                } catch (_) {
                                }
                        if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
                        if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
                        for (var i = 0; i < fullyUnknown.length; ++i)
                            writer.__unknownField(fullyUnknown[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderMessageKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderMessageKey} message SenderMessageKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SenderMessageKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderMessageKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey();
                        while (reader.pos < end) {
                            var unknownStartPos = reader.pos;
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.iteration = reader.uint32();
                                break;
                            case 2:
                                message.seed = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                if (!message.__unknownFields)
                                    message.__unknownFields = [];
                                message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
                     */
                    SenderMessageKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey)
                            return object;
                        var message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderMessageKey();
                        if (object.iteration != null)
                            message.iteration = object.iteration >>> 0;
                        if (object.seed != null)
                            if (typeof object.seed === "string")
                                $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                            else if (object.seed.length)
                                message.seed = object.seed;
                        return message;
                    };

                    /**
                     * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.SenderMessageKey} message SenderMessageKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SenderMessageKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.iteration = 0;
                            if (options.bytes === String)
                                object.seed = "";
                            else {
                                object.seed = [];
                                if (options.bytes !== Array)
                                    object.seed = $util.newBuffer(object.seed);
                            }
                        }
                        if (message.iteration != null && message.hasOwnProperty("iteration"))
                            object.iteration = message.iteration;
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                        return object;
                    };

                    /**
                     * Converts this SenderMessageKey to JSON.
                     * @function toJSON
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderMessageKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SenderMessageKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SenderMessageKey;
                })();

                SenderKeyStateStructure.SenderSigningKey = (function() {

                    /**
                     * Properties of a SenderSigningKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @interface ISenderSigningKey
                     * @property {Uint8Array|null} ["public"] SenderSigningKey public
                     * @property {Uint8Array|null} ["private"] SenderSigningKey private
                     */

                    /**
                     * Constructs a new SenderSigningKey.
                     * @memberof signal.proto.storage.SenderKeyStateStructure
                     * @classdesc Represents a SenderSigningKey.
                     * @implements ISenderSigningKey
                     * @constructor
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderSigningKey=} [properties] Properties to set
                     */
                    function SenderSigningKey(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SenderSigningKey public.
                     * @member {Uint8Array} public
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @instance
                     */
                    SenderSigningKey.prototype["public"] = $util.newBuffer([]);

                    /**
                     * SenderSigningKey private.
                     * @member {Uint8Array} private
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @instance
                     */
                    SenderSigningKey.prototype["private"] = $util.newBuffer([]);

                    /**
                     * Encodes the specified SenderSigningKey message. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.verify|verify} messages.
                     * @function encode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderSigningKey} message SenderSigningKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderSigningKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        var fullyUnknown = [];
                        if (message.__unknownFields)
                            for (var i = 0; i < message.__unknownFields.length; ++i)
                                try {
                                    var known = $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.decode(message.__unknownFields[i]);
                                    fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                    message = Object.assign(known, message);
                                } catch (_) {
                                }
                        if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["public"]);
                        if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
                        for (var i = 0; i < fullyUnknown.length; ++i)
                            writer.__unknownField(fullyUnknown[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link signal.proto.storage.SenderKeyStateStructure.SenderSigningKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.ISenderSigningKey} message SenderSigningKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SenderSigningKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderSigningKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey();
                        while (reader.pos < end) {
                            var unknownStartPos = reader.pos;
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message["public"] = reader.bytes();
                                break;
                            case 2:
                                message["private"] = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                if (!message.__unknownFields)
                                    message.__unknownFields = [];
                                message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signal.proto.storage.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
                     */
                    SenderSigningKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey)
                            return object;
                        var message = new $root.signal.proto.storage.SenderKeyStateStructure.SenderSigningKey();
                        if (object["public"] != null)
                            if (typeof object["public"] === "string")
                                $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
                            else if (object["public"].length)
                                message["public"] = object["public"];
                        if (object["private"] != null)
                            if (typeof object["private"] === "string")
                                $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
                            else if (object["private"].length)
                                message["private"] = object["private"];
                        return message;
                    };

                    /**
                     * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @static
                     * @param {signal.proto.storage.SenderKeyStateStructure.SenderSigningKey} message SenderSigningKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SenderSigningKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object["public"] = "";
                            else {
                                object["public"] = [];
                                if (options.bytes !== Array)
                                    object["public"] = $util.newBuffer(object["public"]);
                            }
                            if (options.bytes === String)
                                object["private"] = "";
                            else {
                                object["private"] = [];
                                if (options.bytes !== Array)
                                    object["private"] = $util.newBuffer(object["private"]);
                            }
                        }
                        if (message["public"] != null && message.hasOwnProperty("public"))
                            object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
                        if (message["private"] != null && message.hasOwnProperty("private"))
                            object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
                        return object;
                    };

                    /**
                     * Converts this SenderSigningKey to JSON.
                     * @function toJSON
                     * @memberof signal.proto.storage.SenderKeyStateStructure.SenderSigningKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SenderSigningKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SenderSigningKey;
                })();

                return SenderKeyStateStructure;
            })();

            storage.SenderKeyRecordStructure = (function() {

                /**
                 * Properties of a SenderKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @interface ISenderKeyRecordStructure
                 * @property {Array.<signal.proto.storage.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates
                 */

                /**
                 * Constructs a new SenderKeyRecordStructure.
                 * @memberof signal.proto.storage
                 * @classdesc Represents a SenderKeyRecordStructure.
                 * @implements ISenderKeyRecordStructure
                 * @constructor
                 * @param {signal.proto.storage.ISenderKeyRecordStructure=} [properties] Properties to set
                 */
                function SenderKeyRecordStructure(properties) {
                    this.senderKeyStates = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SenderKeyRecordStructure senderKeyStates.
                 * @member {Array.<signal.proto.storage.ISenderKeyStateStructure>} senderKeyStates
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @instance
                 */
                SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;

                /**
                 * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link signal.proto.storage.SenderKeyRecordStructure.verify|verify} messages.
                 * @function encode
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SenderKeyRecordStructure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    var fullyUnknown = [];
                    if (message.__unknownFields)
                        for (var i = 0; i < message.__unknownFields.length; ++i)
                            try {
                                var known = $root.signal.proto.storage.SenderKeyRecordStructure.decode(message.__unknownFields[i]);
                                fullyUnknown = fullyUnknown.concat(known.__unknownFields || []);
                                message = Object.assign(known, message);
                            } catch (_) {
                            }
                    if (message.senderKeyStates != null && message.senderKeyStates.length)
                        for (var i = 0; i < message.senderKeyStates.length; ++i)
                            $root.signal.proto.storage.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    for (var i = 0; i < fullyUnknown.length; ++i)
                        writer.__unknownField(fullyUnknown[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link signal.proto.storage.SenderKeyRecordStructure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.
                 * @function decode
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signal.proto.storage.SenderKeyRecordStructure} SenderKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SenderKeyRecordStructure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.signal.proto.storage.SenderKeyRecordStructure();
                    while (reader.pos < end) {
                        var unknownStartPos = reader.pos;
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.senderKeyStates && message.senderKeyStates.length))
                                message.senderKeyStates = [];
                            message.senderKeyStates.push($root.signal.proto.storage.SenderKeyStateStructure.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            if (!message.__unknownFields)
                                message.__unknownFields = [];
                            message.__unknownFields.push(reader.buf.slice(unknownStartPos, reader.pos));
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signal.proto.storage.SenderKeyRecordStructure} SenderKeyRecordStructure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signal.proto.storage.SenderKeyRecordStructure} SenderKeyRecordStructure
                 */
                SenderKeyRecordStructure.fromObject = function fromObject(object) {
                    if (object instanceof $root.signal.proto.storage.SenderKeyRecordStructure)
                        return object;
                    var message = new $root.signal.proto.storage.SenderKeyRecordStructure();
                    if (object.senderKeyStates) {
                        if (!Array.isArray(object.senderKeyStates))
                            throw TypeError(".signal.proto.storage.SenderKeyRecordStructure.senderKeyStates: array expected");
                        message.senderKeyStates = [];
                        for (var i = 0; i < object.senderKeyStates.length; ++i) {
                            if (typeof object.senderKeyStates[i] !== "object")
                                throw TypeError(".signal.proto.storage.SenderKeyRecordStructure.senderKeyStates: object expected");
                            message.senderKeyStates[i] = $root.signal.proto.storage.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @static
                 * @param {signal.proto.storage.SenderKeyRecordStructure} message SenderKeyRecordStructure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SenderKeyRecordStructure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.senderKeyStates = [];
                    if (message.senderKeyStates && message.senderKeyStates.length) {
                        object.senderKeyStates = [];
                        for (var j = 0; j < message.senderKeyStates.length; ++j)
                            object.senderKeyStates[j] = $root.signal.proto.storage.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SenderKeyRecordStructure to JSON.
                 * @function toJSON
                 * @memberof signal.proto.storage.SenderKeyRecordStructure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SenderKeyRecordStructure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SenderKeyRecordStructure;
            })();

            return storage;
        })();

        return proto;
    })();

    return signal;
})();

module.exports = $root;
